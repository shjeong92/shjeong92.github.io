<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://shjeong92.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://shjeong92.github.io/" rel="alternate" type="text/html" hreflang="ko" /><updated>2021-06-09T19:41:00+09:00</updated><id>https://shjeong92.github.io/feed.xml</id><title type="html">Hyuk’s devlog</title><subtitle>Your Site Description
</subtitle><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><entry><title type="html">[ #11 ] 클러스터 보안 - 2</title><link href="https://shjeong92.github.io/2021/06/09/Learning-Kubernetes-11.html" rel="alternate" type="text/html" title="[ #11 ] 클러스터 보안 - 2" /><published>2021-06-09T00:00:00+09:00</published><updated>2021-06-09T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/09/Learning-Kubernetes-11</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/09/Learning-Kubernetes-11.html">&lt;h2 id=&quot;1-tls--ssl--https-란&quot;&gt;1. TLS / SSL / HTTPS 란?&lt;/h2&gt;

&lt;h3 id=&quot;sslsecure-socket-layer&quot;&gt;&lt;strong&gt;SSL(Secure Socket Layer)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;SSL은 웹사이트와 브라우저(혹은, 두 서버) 사이에 전송된 데이터를 암호화하여 인터넷 연결 보안을 유지하는 표준 기술입니다.&lt;/p&gt;

&lt;p&gt;이는 해커가 개인 정보 및 금융 정보를 포함한 전송되는 모든 정보를 열람하거나 훔치는 것을 방지합니다.&lt;/p&gt;

&lt;p&gt;쉽게 말하자면, &lt;strong&gt;네트워크 통신을 할 때 보안을 제공하기 위해 설계된 암호 규약&lt;/strong&gt;이며, TCP/IP 네트워크를 사용하는 통신에 적용됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SSL의 구조&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121298850-7ea01b80-c92f-11eb-8f4c-2f01adc53c1f.jpeg&quot; alt=&quot;ssl-arch&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tlstransport-layer-socket&quot;&gt;TLS(Transport Layer Socket)&lt;/h3&gt;

&lt;p&gt;이름은 SSL 과 다르지만 사실 둘은 같다고 합니다. TLS1.0은 SSL 3.0을 그대로 계승한 것이라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;http--https&quot;&gt;HTTP / HTTPS&lt;/h3&gt;

&lt;h4 id=&quot;--http&quot;&gt;- HTTP&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP 는 다음과 같이 암호화 되지 않은 평문으로 데이터를 전송합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121309439-24a65280-c93d-11eb-8bb3-c1d429e260e2.png&quot; alt=&quot;http&quot; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 누군가 패킷을 훔쳐보는 스니핑(Sniffing) 공격에 취약하지요.&lt;/p&gt;

&lt;p&gt;HTTP 통신에선 해커가 Wire Shark를 통해 패킷을 확인하면 내 비밀번호가 그대로 서버로 전송되는 것을 볼 수 있는것이죠&lt;/p&gt;

&lt;h4 id=&quot;--https&quot;&gt;- HTTPS&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;HTTPS 는 다음과 같이 암호화 된 데이터를 전송합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121309445-27a14300-c93d-11eb-8c69-f6f5cc6a9e6f.png&quot; alt=&quot;https&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이때 사용하는 보안 인증(암호화 + 서버인증 등)이 TLS(SSL)입니다.&lt;/p&gt;

&lt;p&gt;즉, HTTPS는 TLS 프로토콜 위에서 돌아가는 HTTP 프로토콜입니다.&lt;/p&gt;

&lt;p&gt;간단하게 말해서 통신할 떄에 데이터를 ‘암호화’ 하는 보안이 필요하다,&lt;/p&gt;

&lt;p&gt;HTTP 통신에서 보안을 추가한 것이 HTTPS이며&lt;/p&gt;

&lt;p&gt;이때 보안은 TLS를 통해 한다 정도로 알고 넘어가면 되겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-암호화&quot;&gt;2. 암호화&lt;/h2&gt;

&lt;p&gt;이제 TCP/IP 통신을 할 땐 데이터를 암호화 하는 보안이 필요하고,&lt;/p&gt;

&lt;p&gt;그 보안 인증에 TLS가 있다는 것도 알았으니 &lt;strong&gt;TLS가 어떻게 데이터를 암호화 하는지&lt;/strong&gt; 알아봅시다.&lt;/p&gt;

&lt;p&gt;먼저, TLS는 보안과 성능상 이슈로 두 가지의 암호화 방법을 혼용해서 사용합니다.&lt;/p&gt;

&lt;p&gt;따라서 다음 두 가지 암호화 방법을 이해해야 합니다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;대칭키 암호화(Symmetric key algorithm)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비대칭키 암호화(Asymmetric key algorithm)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;암호화를 하기 위해선 일종의 키(key)가 필요합니다.&lt;/p&gt;

&lt;p&gt;키는 뭐 문자가 될 수도 있고 숫자가 될 수도 있고 마음대로 정할 수 있지요.&lt;/p&gt;

&lt;p&gt;암호화는 그냥 하는 것이 아니라 이 &lt;strong&gt;[키]&lt;/strong&gt; + &lt;strong&gt;[데이터]&lt;/strong&gt;를 이용하여 &lt;strong&gt;[암호화된 데이터]&lt;/strong&gt;를 만들어 내는 것입니다&lt;/p&gt;

&lt;p&gt;따라서 키가 단 한 글자라도 다르다면 암호화의 내용도 전혀 달라집니다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;대칭키-암호화&quot;&gt;대칭키 암호화&lt;/h3&gt;
    &lt;p&gt;&lt;strong&gt;대칭키 암호화는, 암호화를 하는 키와 암호를 해독하는 키가 같은 방식입니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;이때 암호화와 복호화에 동시에 사용되는 이 키를  &lt;strong&gt;대칭키&lt;/strong&gt;  라고 합니다.&lt;/p&gt;

    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;구매자: 총 삽니다.
&lt;span class=&quot;c&quot;&gt;#판매자: 불법이니까 위치를 암호화해서 보내줘 암호화키 0528를 사용해서 암호화해서 보내줘&lt;/span&gt;
        
      구매자: &lt;span class=&quot;s2&quot;&gt;&quot;창원에서 만나요&quot;&lt;/span&gt; 를 대칭키인 0528로 암호화

구매자: &lt;span class=&quot;nv&quot;&gt;AgjgkeALAk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gjkfgsdfgjlkaD
        
      판매자: 받은 암호화 메세지를 대칭키인 0528로 복호화
  
&lt;span class=&quot;c&quot;&gt;#판매자: 거기서 봅시다&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;자, 여기서 이제 대칭키 암호화의 단점이 드러납니다.&lt;/p&gt;

    &lt;p&gt;대칭키는 상대방도 나도 서로 공유를 해야하기 때문에,&lt;/p&gt;

    &lt;p&gt;대칭키를 전달하는 과정에서 누가 훔쳐볼 위험이 있습니다.&lt;/p&gt;

    &lt;p&gt;만약 대칭키가 해킹당한다면 그럼 당연히 복호화가 가능하니, 데이터도 누출되게 되겠죠 :b&lt;/p&gt;

    &lt;p&gt;이처럼 대칭키 암호화 방식에선, &lt;strong&gt;대칭키를 상대에게 전달하는 방식에서 해킹당할 리스크가&lt;/strong&gt; 있습니다.&lt;/p&gt;

    &lt;p&gt;이러한 대칭키 암호화의 근본적인 문제를 해결하고자 나온것이 다음에 소개하는 &lt;strong&gt;비대칭키 암호화 방식&lt;/strong&gt;입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;비대칭키-암호화&quot;&gt;비대칭키 암호화&lt;/h3&gt;
    &lt;p&gt;&lt;strong&gt;하나의 키를 갖는 대칭키 암호화 방식과 달리,  비대칭키 암호화 방식 은 한 쌍의 키를 갖게 됩니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;한마디로 비대칭키 암호화 방식에선 키가 2개 입니다.&lt;/p&gt;

    &lt;p&gt;이 두개의 키로 각각 암호화, 복호화를 할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;만일 A, B라는 두 개의 키가 있다면 A키로 암호화한 데이터는 B키로만 복호화를 할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;또한 B키로 암호화한 데이터는 A키로만 복호화를 할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;A키로 암호화한 데이터를 A키로 복호화 할 순 없으며, B키도 마찬가지 입니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;통상적으로 비대칭키 방식에서 가지는 두개의 키에서&lt;/p&gt;

    &lt;p&gt;하나는  &lt;strong&gt;공개 키(Public Key)&lt;/strong&gt; ,  하나는  &lt;strong&gt;개인키(비밀키, Private Key)&lt;/strong&gt; 라고 부릅니다.&lt;/p&gt;

    &lt;p&gt;이렇기 때문에 공개키는 암호화를, 개인키는 복호화를 한다고 알려져 있는데 그렇지 않답니다.&lt;/p&gt;

    &lt;p&gt;이를 그림으로 설명하자면 다음과 같습니다&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121317973-c631a200-c945-11eb-90c2-4779f59efea7.png&quot; alt=&quot;enc&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;
이렇듯 한 쌍의 키로 암호화, 복호화를 하는 방식을  &lt;strong&gt;RSA 알고리즘&lt;/strong&gt;  이라 합니다!
&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;조금더 이해하기쉽게 그림으로 표현해보자면 아래와 같습니다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121333638-f122f280-c953-11eb-8ce0-3f6b8763e3c8.png&quot; alt=&quot;rsa&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;상대방의 공개키를 바탕으로 암호화해서 보내면 해당 공개키의 쌍인 비밀키를 가진 상대방 만이 암호를 해독할 수가 있겠죠?&lt;/p&gt;

    &lt;p&gt;해커가 공개키를 얻는다고해도 암호를 해독할 수 없기때문에 더욱 안전한 암호화 방식입니다.&lt;/p&gt;

    &lt;p&gt;언뜻 보면 &lt;strong&gt;비대칭키(RSA)&lt;/strong&gt; 방식의 방법이 이렇게 완벽해 보이는데&lt;/p&gt;

    &lt;p&gt;왜 TLS는 대칭키 방식과 비대칭키 방식을 같이 사용 할까요?&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;
그 이유는 RSA 알고리즘을 이용한 암호화 방식은 복잡한 수학적 원리로 이루어져 있어,&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;CPU 리소스를 크게 소모한다는 단점&lt;/strong&gt;이 있기 때문입니다.&lt;/p&gt;

    &lt;p&gt;이때문에, RSA 비대칭키 방식으로만 통신을 하기에 성능상 어려움이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-tls의-암호화-방식&quot;&gt;3. TLS의 암호화 방식&lt;/h2&gt;

&lt;p&gt;지금까지 대칭키 방식과 비대칭키 방식의 원리를 알아보았습니다.&lt;/p&gt;

&lt;p&gt;위에서 설명드린 두 방식의 단점 때문에, TLS에서는 이 두 가지 방식을 보완하여 사용합니다.&lt;/p&gt;

&lt;p&gt;대칭키 방식에서의 가장 큰 문제점은 대칭키를 전달할 때 해킹당할 리스크였죠?&lt;/p&gt;

&lt;p&gt;이를 RSA 비대칭키 방식으로 보안한 것입니다.&lt;/p&gt;

&lt;p&gt;실제 통신을 할 때는 CPU 리소스 소모가 적은 대칭키 방식으로 데이터를 주고 받습니다.&lt;/p&gt;

&lt;p&gt;이하기쉽게 그림으로 설명드리도록 하겠습니다!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121340354-7b6e5500-c95a-11eb-9450-97a64678b9cc.png&quot; alt=&quot;tls&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU 리소스를 크게 소모한다는 RSA&lt;/strong&gt;방식은 한번만 사용하여 대칭키를 알아내는용도로만 쓰이고&lt;/p&gt;

&lt;p&gt;나머지 통신은 값이 싼 대칭키 방식을 사용하는 것입니다.&lt;/p&gt;

&lt;p&gt;그림으로 보니 더 쉽게 이해가 되시지요?&lt;/p&gt;

&lt;p&gt;이렇게  TLS, SSL, 대칭키, 비대칭키(공개키, 개인키)에 대해선 모두 알아보았구요&lt;/p&gt;

&lt;p&gt;이번 포스팅은 길어지니 여기서 마치고,&lt;/p&gt;

&lt;p&gt;이 다음 포스팅에선 인증서, 디지털 서명, CA 등등에 대해 다뤄보겠습니다~&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Kubernetes" /><category term="HTTPS" /><category term="static" /><category term="SSL" /><category term="TLS" /><category term="쿠버네티스" /><category term="보안" /><category term="Security" /><category term="대칭키" /><category term="비대칭키" /><summary type="html">1. TLS / SSL / HTTPS 란? SSL(Secure Socket Layer) SSL은 웹사이트와 브라우저(혹은, 두 서버) 사이에 전송된 데이터를 암호화하여 인터넷 연결 보안을 유지하는 표준 기술입니다. 이는 해커가 개인 정보 및 금융 정보를 포함한 전송되는 모든 정보를 열람하거나 훔치는 것을 방지합니다. 쉽게 말하자면, 네트워크 통신을 할 때 보안을 제공하기 위해 설계된 암호 규약이며, TCP/IP 네트워크를 사용하는 통신에 적용됩니다. SSL의 구조 TLS(Transport Layer Socket) 이름은 SSL 과 다르지만 사실 둘은 같다고 합니다. TLS1.0은 SSL 3.0을 그대로 계승한 것이라고 합니다. HTTP / HTTPS - HTTP HTTP 는 다음과 같이 암호화 되지 않은 평문으로 데이터를 전송합니다 따라서 누군가 패킷을 훔쳐보는 스니핑(Sniffing) 공격에 취약하지요. HTTP 통신에선 해커가 Wire Shark를 통해 패킷을 확인하면 내 비밀번호가 그대로 서버로 전송되는 것을 볼 수 있는것이죠 - HTTPS HTTPS 는 다음과 같이 암호화 된 데이터를 전송합니다 이때 사용하는 보안 인증(암호화 + 서버인증 등)이 TLS(SSL)입니다. 즉, HTTPS는 TLS 프로토콜 위에서 돌아가는 HTTP 프로토콜입니다. 간단하게 말해서 통신할 떄에 데이터를 ‘암호화’ 하는 보안이 필요하다, HTTP 통신에서 보안을 추가한 것이 HTTPS이며 이때 보안은 TLS를 통해 한다 정도로 알고 넘어가면 되겠습니다. 2. 암호화 이제 TCP/IP 통신을 할 땐 데이터를 암호화 하는 보안이 필요하고, 그 보안 인증에 TLS가 있다는 것도 알았으니 TLS가 어떻게 데이터를 암호화 하는지 알아봅시다. 먼저, TLS는 보안과 성능상 이슈로 두 가지의 암호화 방법을 혼용해서 사용합니다. 따라서 다음 두 가지 암호화 방법을 이해해야 합니다 대칭키 암호화(Symmetric key algorithm) 비대칭키 암호화(Asymmetric key algorithm) 암호화를 하기 위해선 일종의 키(key)가 필요합니다. 키는 뭐 문자가 될 수도 있고 숫자가 될 수도 있고 마음대로 정할 수 있지요. 암호화는 그냥 하는 것이 아니라 이 [키] + [데이터]를 이용하여 [암호화된 데이터]를 만들어 내는 것입니다 따라서 키가 단 한 글자라도 다르다면 암호화의 내용도 전혀 달라집니다! 대칭키 암호화 대칭키 암호화는, 암호화를 하는 키와 암호를 해독하는 키가 같은 방식입니다. 이때 암호화와 복호화에 동시에 사용되는 이 키를 대칭키 라고 합니다. 구매자: 총 삽니다. #판매자: 불법이니까 위치를 암호화해서 보내줘 암호화키 0528를 사용해서 암호화해서 보내줘 구매자: &quot;창원에서 만나요&quot; 를 대칭키인 0528로 암호화 구매자: AgjgkeALAk=gjkfgsdfgjlkaD 판매자: 받은 암호화 메세지를 대칭키인 0528로 복호화 #판매자: 거기서 봅시다 자, 여기서 이제 대칭키 암호화의 단점이 드러납니다. 대칭키는 상대방도 나도 서로 공유를 해야하기 때문에, 대칭키를 전달하는 과정에서 누가 훔쳐볼 위험이 있습니다. 만약 대칭키가 해킹당한다면 그럼 당연히 복호화가 가능하니, 데이터도 누출되게 되겠죠 :b 이처럼 대칭키 암호화 방식에선, 대칭키를 상대에게 전달하는 방식에서 해킹당할 리스크가 있습니다. 이러한 대칭키 암호화의 근본적인 문제를 해결하고자 나온것이 다음에 소개하는 비대칭키 암호화 방식입니다. 비대칭키 암호화 하나의 키를 갖는 대칭키 암호화 방식과 달리, 비대칭키 암호화 방식 은 한 쌍의 키를 갖게 됩니다. 한마디로 비대칭키 암호화 방식에선 키가 2개 입니다. 이 두개의 키로 각각 암호화, 복호화를 할 수 있습니다. 만일 A, B라는 두 개의 키가 있다면 A키로 암호화한 데이터는 B키로만 복호화를 할 수 있습니다. 또한 B키로 암호화한 데이터는 A키로만 복호화를 할 수 있습니다. A키로 암호화한 데이터를 A키로 복호화 할 순 없으며, B키도 마찬가지 입니다. 통상적으로 비대칭키 방식에서 가지는 두개의 키에서 하나는 공개 키(Public Key) , 하나는 개인키(비밀키, Private Key) 라고 부릅니다. 이렇기 때문에 공개키는 암호화를, 개인키는 복호화를 한다고 알려져 있는데 그렇지 않답니다. 이를 그림으로 설명하자면 다음과 같습니다 이렇듯 한 쌍의 키로 암호화, 복호화를 하는 방식을 RSA 알고리즘 이라 합니다! 조금더 이해하기쉽게 그림으로 표현해보자면 아래와 같습니다. 상대방의 공개키를 바탕으로 암호화해서 보내면 해당 공개키의 쌍인 비밀키를 가진 상대방 만이 암호를 해독할 수가 있겠죠? 해커가 공개키를 얻는다고해도 암호를 해독할 수 없기때문에 더욱 안전한 암호화 방식입니다. 언뜻 보면 비대칭키(RSA) 방식의 방법이 이렇게 완벽해 보이는데 왜 TLS는 대칭키 방식과 비대칭키 방식을 같이 사용 할까요? 그 이유는 RSA 알고리즘을 이용한 암호화 방식은 복잡한 수학적 원리로 이루어져 있어, CPU 리소스를 크게 소모한다는 단점이 있기 때문입니다. 이때문에, RSA 비대칭키 방식으로만 통신을 하기에 성능상 어려움이 있습니다. 3. TLS의 암호화 방식 지금까지 대칭키 방식과 비대칭키 방식의 원리를 알아보았습니다. 위에서 설명드린 두 방식의 단점 때문에, TLS에서는 이 두 가지 방식을 보완하여 사용합니다. 대칭키 방식에서의 가장 큰 문제점은 대칭키를 전달할 때 해킹당할 리스크였죠? 이를 RSA 비대칭키 방식으로 보안한 것입니다. 실제 통신을 할 때는 CPU 리소스 소모가 적은 대칭키 방식으로 데이터를 주고 받습니다. 이하기쉽게 그림으로 설명드리도록 하겠습니다! CPU 리소스를 크게 소모한다는 RSA방식은 한번만 사용하여 대칭키를 알아내는용도로만 쓰이고 나머지 통신은 값이 싼 대칭키 방식을 사용하는 것입니다. 그림으로 보니 더 쉽게 이해가 되시지요? 이렇게 TLS, SSL, 대칭키, 비대칭키(공개키, 개인키)에 대해선 모두 알아보았구요 이번 포스팅은 길어지니 여기서 마치고, 이 다음 포스팅에선 인증서, 디지털 서명, CA 등등에 대해 다뤄보겠습니다~</summary></entry><entry><title type="html">[ #10 ] 클러스터 보안 - 1</title><link href="https://shjeong92.github.io/2021/06/07/Learning-Kubernetes-10.html" rel="alternate" type="text/html" title="[ #10 ] 클러스터 보안 - 1" /><published>2021-06-07T00:00:00+09:00</published><updated>2021-06-07T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/07/Learning-Kubernetes-10</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/07/Learning-Kubernetes-10.html">&lt;p&gt;기본적인 인증 수단에는 &lt;strong&gt;Static Password File&lt;/strong&gt;을 통한 방법과, &lt;strong&gt;Static Token File&lt;/strong&gt;을 이용한 방법이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;1---static-password-file&quot;&gt;1 - Static Password File&lt;/h2&gt;

&lt;p&gt;아래의 유저정보가 담긴 csv파일을 통하여 인증 할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#user-details.csv
password123,username1,userId1
password133,username2,userId2
password113,username3,userId3 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;kubeadm으로 클러스터를 구성하였으면 
그러기 위해선 staticpodpath위치에 kube-apiserver.yaml 이 존재하는데, 아래와같이 실행 옵션을 추가해주면 됩니다&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;...중략&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;- command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-apiserver&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--advertise-address=10.178.0.2&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--allow-privileged=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--authorization-mode=Node,RBAC&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--client-ca-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--enable-admission-plugins=NodeRestriction&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--enable-bootstrap-token-auth=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-servers=https://127.0.0.1:2379&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--insecure-port=0&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--basic-auth-file=user-details.csv        &amp;lt;-----추가된 실행옵션&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한 이 파일은 선택적으로 4번째 컬럼에 그룹명을 넣을 수도 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#user-details.csv 
password123,username1,userId1,group1
password133,username2,userId2,group2
password113,username3,userId3,group2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2---static-token-file&quot;&gt;2 - Static Token File&lt;/h2&gt;

&lt;p&gt;두번째 기본 인증 방법으로 Password 대신에 Token을 사용하는 방법인데요&lt;/p&gt;

&lt;p&gt;첫번째 컬럼에 비밀번호 대신에 토큰이 들어가는 차이가 있고,&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user-token-details.csv
AjkfgljADSKFfjkwelkasdfKdfgkdlfga,username1,userId1,group1(optional)
RAakjkfskfgElkasdfjkERlfkglgDFFLg,username2,userId2,group2(optional)
lfkjgkqlwemdfgEaklFKSGkejsfdkgkas,username1,userId2,group2(optional)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행 옵션이 다른 차이점이 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;...중략&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;- command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-apiserver&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--advertise-address=10.178.0.2&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--allow-privileged=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--authorization-mode=Node,RBAC&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--client-ca-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--enable-admission-plugins=NodeRestriction&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--enable-bootstrap-token-auth=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-servers=https://127.0.0.1:2379&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--insecure-port=0&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--token-auth-file=user-details.csv        &amp;lt;-----추가된 실행옵션&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 두가지 방법은 추천되는 인증 방식이 아니라고합니다.
다음 포스트에서는 실제로 쓰이는 방식에 대해 다뤄보겠습니다.&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Kubernetes" /><category term="maintenance" /><category term="static" /><category term="pod" /><category term="strategy" /><category term="쿠버네티스" /><category term="update" /><summary type="html">기본적인 인증 수단에는 Static Password File을 통한 방법과, Static Token File을 이용한 방법이 있습니다. 1 - Static Password File 아래의 유저정보가 담긴 csv파일을 통하여 인증 할 수 있습니다. #user-details.csv password123,username1,userId1 password133,username2,userId2 password113,username3,userId3 kubeadm으로 클러스터를 구성하였으면 그러기 위해선 staticpodpath위치에 kube-apiserver.yaml 이 존재하는데, 아래와같이 실행 옵션을 추가해주면 됩니다 ...중략 - command: - kube-apiserver - --advertise-address=10.178.0.2 - --allow-privileged=true - --authorization-mode=Node,RBAC - --client-ca-file=/etc/kubernetes/pki/ca.crt - --enable-admission-plugins=NodeRestriction - --enable-bootstrap-token-auth=true - --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt - --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt - --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key - --etcd-servers=https://127.0.0.1:2379 - --insecure-port=0 - --basic-auth-file=user-details.csv &amp;lt;-----추가된 실행옵션 ... 또한 이 파일은 선택적으로 4번째 컬럼에 그룹명을 넣을 수도 있습니다. #user-details.csv password123,username1,userId1,group1 password133,username2,userId2,group2 password113,username3,userId3,group2 2 - Static Token File 두번째 기본 인증 방법으로 Password 대신에 Token을 사용하는 방법인데요 첫번째 컬럼에 비밀번호 대신에 토큰이 들어가는 차이가 있고, user-token-details.csv AjkfgljADSKFfjkwelkasdfKdfgkdlfga,username1,userId1,group1(optional) RAakjkfskfgElkasdfjkERlfkglgDFFLg,username2,userId2,group2(optional) lfkjgkqlwemdfgEaklFKSGkejsfdkgkas,username1,userId2,group2(optional) 실행 옵션이 다른 차이점이 있습니다. ...중략 - command: - kube-apiserver - --advertise-address=10.178.0.2 - --allow-privileged=true - --authorization-mode=Node,RBAC - --client-ca-file=/etc/kubernetes/pki/ca.crt - --enable-admission-plugins=NodeRestriction - --enable-bootstrap-token-auth=true - --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt - --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt - --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key - --etcd-servers=https://127.0.0.1:2379 - --insecure-port=0 - --token-auth-file=user-details.csv &amp;lt;-----추가된 실행옵션 ... 위 두가지 방법은 추천되는 인증 방식이 아니라고합니다. 다음 포스트에서는 실제로 쓰이는 방식에 대해 다뤄보겠습니다.</summary></entry><entry><title type="html">[ #9 ] 클러스터 백업 &amp;amp; 복구</title><link href="https://shjeong92.github.io/2021/06/04/Learning-Kubernetes-09.html" rel="alternate" type="text/html" title="[ #9 ] 클러스터 백업 &amp;amp; 복구" /><published>2021-06-04T00:00:00+09:00</published><updated>2021-06-04T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/04/Learning-Kubernetes-09</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/04/Learning-Kubernetes-09.html">&lt;p&gt;이번 포스트에서는 ETCD database를 이용한 클러스터 백업 및 복구 방법에 대해서 다뤄보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;etcd란&quot;&gt;etcd란&lt;/h2&gt;

&lt;p&gt;etcd는 모든 클러스터 데이터에 대한 Kubernetes의 백업 저장소로 사용되는 일관되고 가용성이 높은 키 값 저장소입니다&lt;/p&gt;

&lt;p&gt;그리고 ETCD는 각 마스터노드에 존재하고, key=value의 데이터는 마스터 노드의 /var/lib/etcd 에 저장됩니다.&lt;/p&gt;

&lt;p&gt;ETCD는 built in 스냅샷 solution을 가지고 있는데요 이를통해 현재 실행중인 모든 리소스의 정보를 백업하고, 복구할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;step1---etcd가-설치되어-있지-않을경우-설치합니다&quot;&gt;STEP1 - etcd가 설치되어 있지 않을경우 설치합니다.&lt;/h3&gt;

&lt;p&gt;제 쿠버네티 클러스터는 1 개의 마스터노드, 3개의 워커노드로 구성되어 있습니다. googld cloud compute engine 인스턴스를 사용하여 구성하였으며 모든 노드는 Ubuntu 18.04.5 LTS 버전입니다.&lt;/p&gt;

&lt;p&gt;아래 커맨드를 이용해 etcd-client를 설치해줍니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;etcd-client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step2---복구시킬-환경-구성&quot;&gt;STEP2 - 복구시킬 환경 구성&lt;/h3&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#depl.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-deployment&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-pod&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx:1.19&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단한 yaml파일을 통해 3개의 nginx 파드를 배포합니다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; depl.yml 
deployment.apps/myapp-deployment created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 현재 어떤 리소스들이 돌아가고있는지 확인해주고 이 상황의 스냅샷을 생성할겁니다&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get all
NAME                                    READY   STATUS    RESTARTS   AGE
pod/myapp-deployment-7f6679cc7d-5qwxx   1/1     Running   0          32s
pod/myapp-deployment-7f6679cc7d-855lp   1/1     Running   0          32s
pod/myapp-deployment-7f6679cc7d-bxxjx   1/1     Running   0          32s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    &amp;lt;none&amp;gt;        443/TCP   8d

NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/myapp-deployment   3/3     3            3           32s

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/myapp-deployment-7f6679cc7d   3         3         3       32s
shjeong920522@master:~/Pod$ 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;스냅샷-생성하기&quot;&gt;스냅샷 생성하기&lt;/h2&gt;

&lt;p&gt;etcdctl의 스냅샷을 생성하기위해선 아래와같은 옵션이 필요합니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;etcdctl &lt;span class=&quot;nt&quot;&gt;--cacert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;옵션값 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--cert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;옵션값 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;옵션값 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
snapshot save 백업경로 및 파일이름
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;그렇다면 이 옵션값은 어디서 확인가능할까요?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ps명령어 와 grep을 를 활용하면 된답니다&lt;/p&gt;

&lt;p&gt;아래 명령어를 사용하여 다 찾아서 값을 가져와도되지만&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ps &lt;span class=&quot;nt&quot;&gt;-ef&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;etcd
root      2863  2764  1 05:36 ?        00:00:23 etcd &lt;span class=&quot;nt&quot;&gt;--advertise-client-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2379 &lt;span class=&quot;nt&quot;&gt;--cert-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.crt &lt;span class=&quot;nt&quot;&gt;--client-cert-auth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--data-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/etcd &lt;span class=&quot;nt&quot;&gt;--initial-advertise-peer-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;nt&quot;&gt;--initial-cluster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;nt&quot;&gt;--key-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.key &lt;span class=&quot;nt&quot;&gt;--listen-client-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://127.0.0.1:2379,https://10.178.0.2:2379 &lt;span class=&quot;nt&quot;&gt;--listen-metrics-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://127.0.0.1:2381 &lt;span class=&quot;nt&quot;&gt;--listen-peer-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;master &lt;span class=&quot;nt&quot;&gt;--peer-cert-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/peer.crt &lt;span class=&quot;nt&quot;&gt;--peer-client-cert-auth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--peer-key-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/peer.key &lt;span class=&quot;nt&quot;&gt;--peer-trusted-ca-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/ca.crt &lt;span class=&quot;nt&quot;&gt;--snapshot-count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10000 &lt;span class=&quot;nt&quot;&gt;--trusted-ca-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/ca.crt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;표에 들어간 커맨드로 원하는 부분을 강조시켜 찾는방법을 추천드립니다. 눈알굴려서 찾는것보다 훨씬 빠르더라구요&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;etcdctl 명령 옵션&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;etcd &lt;br /&gt;프로세스 실행옵션&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;값&lt;/center&gt;&lt;/th&gt;
      &lt;th&gt;&lt;center&gt;커맨드로 빨리찾기&lt;/center&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cacert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--trusted-ca-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/ca.crt&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep trusted&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cert-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/server.crt&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--cert&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--key&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--key-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/server.key&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--key&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그리고 값 부분은 항상 같은것이 아닐 수도 있기에 커맨드로 직접 확인하셔야 합니다.&lt;/p&gt;

&lt;p&gt;자 이제 스냅샷을 생성하기위하여 우선 루트계정으로 전환해줍니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 환경변수를 등록해줍니다
ETCDCTL_API 3버전을 사용하기 위함입니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root# &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ETCDCTL_API&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root# etcdctl &lt;span class=&quot;nt&quot;&gt;--cacert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/ca.crt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--cert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.crt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.key &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; snapshot save /opt/backup
Snapshot saved at /opt/backup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스냅샷을 생성하였으니 아까 배포하였던 deployment 를 delete하고 etcdctl 복구를하여
정말 동작하던 deployment를 다시 배포해주는지 확인해봅시다&lt;/p&gt;

&lt;p&gt;우선 루트계정에서 로그아웃 해주시구요&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root# &lt;span class=&quot;nb&quot;&gt;exit
logout&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;deployment를 삭제시켜줍니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; depl.yml 
deployment.apps &lt;span class=&quot;s2&quot;&gt;&quot;myapp-deployment&quot;&lt;/span&gt; deleted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;복구하기로 넘어갑니다.&lt;/p&gt;

&lt;h2 id=&quot;스냅샷으로-복구하기&quot;&gt;스냅샷으로 복구하기&lt;/h2&gt;

&lt;p&gt;복구할때는 스냅샷을 만들때 넣었던 옵션에서 네가지의 옵션이 더 추가됩니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;etcdctl 명령 옵션&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;etcd &lt;br /&gt;프로세스 실행옵션&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;값&lt;/center&gt;&lt;/th&gt;
      &lt;th&gt;&lt;center&gt;커맨드로 빨리찾기&lt;/center&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cacert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--trusted-ca-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/ca.crt&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep trusted&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cert-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/server.crt&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--cert&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--key&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--key-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/server.key&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--key&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--initial-advertise-peer-urls&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--initial-advertise-peer-urls&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;https://10.178.0.2:2380&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep initial&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--initial-cluster=master&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--initial-cluster=master&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;https://10.178.0.2:2380&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep initial&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--data-dir&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--data-dir&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/var/lib/etcd_backup&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--data-dir&quot; &lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--name&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--name&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;master(마스터노드이름)&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--name&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자 여기까지가 restore 할때 필요한 모든 옵션입니다.&lt;/p&gt;

&lt;p&gt;이제 아까 찍어놨던 스냅샷으로 복구되는지 확인해봅시다.&lt;/p&gt;

&lt;p&gt;우선 루트 계정으로 전환하구요&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;restore 명령어를 입력해주고 로그아웃해줍니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root# etcdctl &lt;span class=&quot;nt&quot;&gt;--cacert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/ca.crt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--cert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.crt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.key &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--initial-advertise-peer-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--initial-cluster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--data-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/etcd_backup &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;master &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; snapshot restore /opt/backup

root# &lt;span class=&quot;nb&quot;&gt;exit
logout&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;/opt/backup 에 생성해뒀던 스냅샷을이용해서 /var/lib 위치에 etcd_backup 파일을 생성합니다
staticpod에서 실행되는 etcd가 이를 바라보도록 해줘야하겠지요&lt;/p&gt;

&lt;p&gt;staticpod의 위치인 /etc/kubernetes/manifest로 이동후 etcd.yaml을 수정해야합니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /etc/kubernetes/manifest

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vim etcd.yaml

~~~yaml
&lt;span class=&quot;c&quot;&gt;#etcd.yaml&lt;/span&gt;
...중략

volumes:
- hostPath:
    path: /etc/kubernetes/pki/etcd
    &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: DirectoryOrCreate
  name: etcd-certs
- hostPath:
    path: /var/lib/etcd_backup     &amp;lt;&lt;span class=&quot;nt&quot;&gt;-----------&lt;/span&gt;  backup한 스냅샷을 바라보게 수정해줍니다
    &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: DirectoryOrCreate
  name: etcd-data

...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변경사항을 저장해주면 새로 로드될때까지 시간이 조금걸립니다&lt;/p&gt;

&lt;p&gt;잠시후 정말 실행 중이던 deployment가 실행중인지 확인해봅시다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get deploy
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
myapp-deployment   3/3     3            3           20s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;짜잔~ 잘 복구된것을 확인할 수 있었습니다&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Kubernetes" /><category term="maintenance" /><category term="static" /><category term="pod" /><category term="strategy" /><category term="쿠버네티스" /><category term="update" /><summary type="html">이번 포스트에서는 ETCD database를 이용한 클러스터 백업 및 복구 방법에 대해서 다뤄보겠습니다. etcd란 etcd는 모든 클러스터 데이터에 대한 Kubernetes의 백업 저장소로 사용되는 일관되고 가용성이 높은 키 값 저장소입니다 그리고 ETCD는 각 마스터노드에 존재하고, key=value의 데이터는 마스터 노드의 /var/lib/etcd 에 저장됩니다. ETCD는 built in 스냅샷 solution을 가지고 있는데요 이를통해 현재 실행중인 모든 리소스의 정보를 백업하고, 복구할 수 있습니다. STEP1 - etcd가 설치되어 있지 않을경우 설치합니다. 제 쿠버네티 클러스터는 1 개의 마스터노드, 3개의 워커노드로 구성되어 있습니다. googld cloud compute engine 인스턴스를 사용하여 구성하였으며 모든 노드는 Ubuntu 18.04.5 LTS 버전입니다. 아래 커맨드를 이용해 etcd-client를 설치해줍니다 $ sudo apt update $ sudo apt install etcd-client STEP2 - 복구시킬 환경 구성 #depl.yaml apiVersion: apps/v1 kind: Deployment metadata: name: myapp-deployment labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx:1.19 replicas: 3 selector: matchLabels: type: front-end 간단한 yaml파일을 통해 3개의 nginx 파드를 배포합니다 $ kubectl apply -f depl.yml deployment.apps/myapp-deployment created 그리고 현재 어떤 리소스들이 돌아가고있는지 확인해주고 이 상황의 스냅샷을 생성할겁니다 $ kubectl get all NAME READY STATUS RESTARTS AGE pod/myapp-deployment-7f6679cc7d-5qwxx 1/1 Running 0 32s pod/myapp-deployment-7f6679cc7d-855lp 1/1 Running 0 32s pod/myapp-deployment-7f6679cc7d-bxxjx 1/1 Running 0 32s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/kubernetes ClusterIP 10.96.0.1 &amp;lt;none&amp;gt; 443/TCP 8d NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/myapp-deployment 3/3 3 3 32s NAME DESIRED CURRENT READY AGE replicaset.apps/myapp-deployment-7f6679cc7d 3 3 3 32s shjeong920522@master:~/Pod$ 스냅샷 생성하기 etcdctl의 스냅샷을 생성하기위해선 아래와같은 옵션이 필요합니다. etcdctl --cacert=옵션값 \ --cert=옵션값 \ --key=옵션값 \ snapshot save 백업경로 및 파일이름 그렇다면 이 옵션값은 어디서 확인가능할까요? ps명령어 와 grep을 를 활용하면 된답니다 아래 명령어를 사용하여 다 찾아서 값을 가져와도되지만 $ ps -ef | grep etcd root 2863 2764 1 05:36 ? 00:00:23 etcd --advertise-client-urls=https://10.178.0.2:2379 --cert-file=/etc/kubernetes/pki/etcd/server.crt --client-cert-auth=true --data-dir=/var/lib/etcd --initial-advertise-peer-urls=https://10.178.0.2:2380 --initial-cluster=master=https://10.178.0.2:2380 --key-file=/etc/kubernetes/pki/etcd/server.key --listen-client-urls=https://127.0.0.1:2379,https://10.178.0.2:2379 --listen-metrics-urls=http://127.0.0.1:2381 --listen-peer-urls=https://10.178.0.2:2380 --name=master --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt --peer-client-cert-auth=true --peer-key-file=/etc/kubernetes/pki/etcd/peer.key --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt --snapshot-count=10000 --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt 표에 들어간 커맨드로 원하는 부분을 강조시켜 찾는방법을 추천드립니다. 눈알굴려서 찾는것보다 훨씬 빠르더라구요 etcdctl 명령 옵션 etcd 프로세스 실행옵션 값 커맨드로 빨리찾기 --cacert --trusted-ca-file /etc/kubernetes/pki/etcd/ca.crt ps -ef | grep etcd | grep trusted --cert --cert-file /etc/kubernetes/pki/etcd/server.crt ps -ef | grep etcd | grep &quot;\--cert&quot; --key --key-file /etc/kubernetes/pki/etcd/server.key ps -ef | grep etcd | grep &quot;\--key&quot; 그리고 값 부분은 항상 같은것이 아닐 수도 있기에 커맨드로 직접 확인하셔야 합니다. 자 이제 스냅샷을 생성하기위하여 우선 루트계정으로 전환해줍니다 $ sudo -i 아래와 같이 환경변수를 등록해줍니다 ETCDCTL_API 3버전을 사용하기 위함입니다. root# export ETCDCTL_API=3 root# etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \ &amp;gt; --cert=/etc/kubernetes/pki/etcd/server.crt \ &amp;gt; --key=/etc/kubernetes/pki/etcd/server.key \ &amp;gt; snapshot save /opt/backup Snapshot saved at /opt/backup 스냅샷을 생성하였으니 아까 배포하였던 deployment 를 delete하고 etcdctl 복구를하여 정말 동작하던 deployment를 다시 배포해주는지 확인해봅시다 우선 루트계정에서 로그아웃 해주시구요 root# exit logout deployment를 삭제시켜줍니다. $ kubectl delete -f depl.yml deployment.apps &quot;myapp-deployment&quot; deleted 복구하기로 넘어갑니다. 스냅샷으로 복구하기 복구할때는 스냅샷을 만들때 넣었던 옵션에서 네가지의 옵션이 더 추가됩니다. etcdctl 명령 옵션 etcd 프로세스 실행옵션 값 커맨드로 빨리찾기 --cacert --trusted-ca-file /etc/kubernetes/pki/etcd/ca.crt ps -ef | grep etcd | grep trusted --cert --cert-file /etc/kubernetes/pki/etcd/server.crt ps -ef | grep etcd | grep &quot;\--cert&quot; --key --key-file /etc/kubernetes/pki/etcd/server.key ps -ef | grep etcd | grep &quot;\--key&quot; --initial-advertise-peer-urls --initial-advertise-peer-urls https://10.178.0.2:2380 ps -ef | grep etcd | grep initial --initial-cluster=master --initial-cluster=master https://10.178.0.2:2380 ps -ef | grep etcd | grep initial --data-dir --data-dir /var/lib/etcd_backup ps -ef | grep etcd | grep &quot;\--data-dir&quot; --name --name master(마스터노드이름) ps -ef | grep etcd | grep &quot;\--name&quot; 자 여기까지가 restore 할때 필요한 모든 옵션입니다. 이제 아까 찍어놨던 스냅샷으로 복구되는지 확인해봅시다. 우선 루트 계정으로 전환하구요 $ sudo -i restore 명령어를 입력해주고 로그아웃해줍니다 root# etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \ &amp;gt; --cert=/etc/kubernetes/pki/etcd/server.crt \ &amp;gt; --key=/etc/kubernetes/pki/etcd/server.key \ &amp;gt; --initial-advertise-peer-urls=https://10.178.0.2:2380 \ &amp;gt; --initial-cluster=master=https://10.178.0.2:2380 \ &amp;gt; --data-dir=/var/lib/etcd_backup \ &amp;gt; --name=master \ &amp;gt; snapshot restore /opt/backup root# exit logout /opt/backup 에 생성해뒀던 스냅샷을이용해서 /var/lib 위치에 etcd_backup 파일을 생성합니다 staticpod에서 실행되는 etcd가 이를 바라보도록 해줘야하겠지요 staticpod의 위치인 /etc/kubernetes/manifest로 이동후 etcd.yaml을 수정해야합니다 $ cd /etc/kubernetes/manifest $ sudo vim etcd.yaml ~~~yaml #etcd.yaml ...중략 volumes: - hostPath: path: /etc/kubernetes/pki/etcd type: DirectoryOrCreate name: etcd-certs - hostPath: path: /var/lib/etcd_backup &amp;lt;----------- backup한 스냅샷을 바라보게 수정해줍니다 type: DirectoryOrCreate name: etcd-data ... 변경사항을 저장해주면 새로 로드될때까지 시간이 조금걸립니다 잠시후 정말 실행 중이던 deployment가 실행중인지 확인해봅시다 $ kubectl get deploy NAME READY UP-TO-DATE AVAILABLE AGE myapp-deployment 3/3 3 3 20s 짜잔~ 잘 복구된것을 확인할 수 있었습니다</summary></entry><entry><title type="html">[ #8 ] 클러스터 유지보수</title><link href="https://shjeong92.github.io/2021/06/03/Learning-Kubernetes-08.html" rel="alternate" type="text/html" title="[ #8 ] 클러스터 유지보수" /><published>2021-06-03T00:00:00+09:00</published><updated>2021-06-03T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/03/Learning-Kubernetes-08</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/03/Learning-Kubernetes-08.html">&lt;p&gt;오늘은 클러스터의 유지보수에 관련한 포스트를 써볼까 합니다.&lt;/p&gt;

&lt;p&gt;쿠버네티스를 이용하여 서비스를 구축하고나서 언젠가는 시스템을 업데이트 시켜야할 일이 생길 것이며, 오류로 인하여 노드가 먹통이 되는일도 생길 것입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 노드의 작동을 중지시키면, 또는 오류로 중지된다면 어떻게 될까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;master node의 kube-contoller-manager에는 pod-eviction-timeout이 존재합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;컨디션&quot;&gt;컨디션&lt;/h2&gt;

&lt;p&gt;각 노드에는 아래와 같이 여러가지 condition이 존재합니다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;노드 컨디션&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;Ready&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;노드가 상태 양호하며 파드를 수용할 준비가 되어 있는 경우 True, 노드의 상태가 불량하여 파드를 수용하지 못할 경우 False, 그리고 노드 컨트롤러가 마지막 node-monitor-grace-period (기본값 40 기간 동안 노드로부터 응답을 받지 못한 경우) Unknown&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;DiskPressure&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;디스크 사이즈 상에 압박이 있는 경우, 즉 디스크 용량이 넉넉치 않은 경우 True, 반대의 경우 False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;MemoryPressure&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;노드 메모리 상에 압박이 있는 경우, 즉 노드 메모리가 넉넉치 않은 경우 True, 반대의 경우 False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;PIDPressure&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프로세스 상에 압박이 있는 경우, 즉 노드 상에 많은 프로세스들이 존재하는 경우 True, 반대의 경우 False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;strong&gt;NetworkUnavailable&lt;/strong&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;노드에 대해 네트워크가 올바르게 구성되지 않은 경우 True, 반대의 경우 False&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;또한 노드 lifecycle controller는 컨디션을 아래와 같은 &lt;strong&gt;&lt;em&gt;built-in taint&lt;/em&gt;&lt;/strong&gt;를 자동으로 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;built-in-taints&quot;&gt;built-in taints&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;node.kubernetes.io/not-ready: 노드가 준비되지 않음. 이는 NodeCondition Ready 가 “False”로 됨에 해당.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/unreachable: 노드가 노드 컨트롤러에서 도달할 수 없음. 이는  NodeCondition Ready 가 “Unknown”로 됨에 해당.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/memory-pressure: 노드에 메모리 할당 압박이 있음.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/disk-pressure: 노드에 디스크 할당 압박이 있음.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/pid-pressure: 노드에 PID 할당 압박이 있음.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/network-unavailable: 노드의 네트워크를 사용할 수 없음.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/unschedulable: 노드를 스케줄할 수 없음.&lt;/li&gt;
  &lt;li&gt;node.cloudprovider.kubernetes.io/uninitialized: “외부” 클라우드 공급자로 kubelet을 시작하면, 이 테인트가 노드에서 사용 불가능으로 표시되도록 설정됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 중에서도 &lt;code&gt;ready&lt;/code&gt; 컨디션은 좀 특별한데요. 
ready 컨디션의 상태가 pod-eviction-timeout (kube-controller-manager에 전달된 인수) 보다 더 길게 Unknown 또는 False로 유지되는 경우, 노드 상에 모든 파드는 노드 컨트롤러에 의해 삭제되도록 스케줄 됩니다.&lt;/p&gt;

&lt;p&gt;클라우드-컨트롤러-관리자의 컨트롤러가 이 노드를 초기화하면, kubelet이 이 테인트를 제거합니다 즉 다시 pod가 배정될 수 있는 상태가 되는것이죠. 기본 축출 타임아웃 기간은 기본 5분으로 설정되어 있습니다. 만약 노드가 다운되었다가 5분안에 복구가 되었다면 노드 내의 pod들은 그대로 존재하지만, 설정된 타임아웃 시간을 초과한다면 그안의 파드들은 모두 중단 되는것입니다.&lt;/p&gt;

&lt;p&gt;만약 수정하고 싶다면 마스터 노드의 kube-system 네임스페이스에 있는 kube-controller-manager-master을 edit해주면됩니다.&lt;/p&gt;

&lt;p&gt;그런데 말이죠 이 pod는 static pod입니다. 
&lt;a href=&quot;https://shjeong92.github.io/2021/05/31/Learning-Kubernetes-06.html&quot;&gt;6번째 포스트&lt;/a&gt;에서 설명 했었는데 static pod 를 수정하려면 
static pod을 생성한 yaml파일 자체를 수정한다고 했었죠?&lt;/p&gt;

&lt;p&gt;static pod의 위치를 찾는것 부터 복습해봅시다&lt;/p&gt;

&lt;p&gt;우선 config.yaml파일의 위치를 찾아줍니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ps &lt;span class=&quot;nt&quot;&gt;-ef&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;kubelet | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\-&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-config&quot;&lt;/span&gt;

root     10476     1  3 May28 ?        05:09:26 /usr/bin/kubelet &lt;span class=&quot;nt&quot;&gt;--bootstrap-kubeconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/bootstrap-kubelet.conf &lt;span class=&quot;nt&quot;&gt;--kubeconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/kubelet.conf &lt;span class=&quot;nt&quot;&gt;--config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/kubelet/config.yaml &lt;span class=&quot;nt&quot;&gt;--network-plugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cni &lt;span class=&quot;nt&quot;&gt;--pod-infra-container-image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;k8s.gcr.io/pause:3.4.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;config.yaml파일 내에서 staticpath를 찾아냅시다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; static /var/lib/kubelet/config.yaml
staticPodPath: /etc/kubernetes/manifests
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;staticPodPath로 이동후 뭐가있나 확인해봅니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /etc/kubernetes/manifests

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;etcd.yaml  kube-apiserver.yaml  kube-controller-manager.yaml  kube-scheduler.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자 이제 이 yaml파일을 수정하면 됩니다.
저는 이 기본 5분인 eviction-timeout을 60초로 바꾸어 보겠습니다.&lt;/p&gt;

&lt;p&gt;command에 &lt;code&gt;--pod-eviction-timeout=60s&lt;/code&gt; 옵션을 추가해 줌으로써 말이죠.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/config.hash&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;47cace34a635d6f3e305eee20e0e7b30&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/config.mirror&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;47cace34a635d6f3e305eee20e0e7b30&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/config.seen&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2021-05-28T03:40:42.961803243Z&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/config.source&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;file&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2021-05-28T03:40:55Z&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-controller-manager&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tier&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;control-plane&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-controller-manager-master&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-system&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ownerReferences&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Node&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;master&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;69f4d243-9420-45a9-928e-672a1d3b977a&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resourceVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;478&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;4cfad35d-8664-42cf-9ed9-5fd5b4d771a4&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-controller-manager&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--allocate-node-cidrs=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--pod-eviction-timeout=60s&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;#&amp;lt;----------- 해당라인을 추가하면 이제 5분이아닌 60초로 변경됩니다.&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--authentication-kubeconfig=/etc/kubernetes/controller-manager.conf&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--authorization-kubeconfig=/etc/kubernetes/controller-manager.conf&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--bind-address=127.0.0.1&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--client-ca-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--cluster-cidr=10.244.0.0/16&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--cluster-name=kubernetes&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--cluster-signing-key-file=/etc/kubernetes/pki/ca.key&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--controllers=*,bootstrapsigner,tokencleaner&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--kubeconfig=/etc/kubernetes/controller-manager.conf&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--leader-elect=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--port=0&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--root-ca-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--service-account-private-key-file=/etc/kubernetes/pki/sa.key&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--service-cluster-ip-range=10.96.0.0/12&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--use-service-account-credentials=true&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;k8s.gcr.io/kube-controller-manager:v1.21.1&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;...중략&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;저장해주면 멈췄다가&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kube-controller-manager-master    0/1     Running   0          3s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;옵션을 적용시켜 pod시 재시동됩니다~&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kube-controller-manager-master    1/1     Running   0          3s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;eviction-timeout의-존재이유&quot;&gt;eviction timeout의 존재이유?&lt;/h2&gt;
&lt;p&gt;위에서 eviction timeout의 값을 바꾸는 실습을 해보았는데요 이 timeout은 무엇과 연관이 있는지 두가지 케이스를 통해서 알아보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;case1: node가 먹통이 되었다가 설정해놓은 eviction-timeout보다 짦은시간안에 복구된경우&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;노드내에 있던 pod들이 kubectl에 의해 다시 해당노드에서 재시작됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;case2: node가 먹통이 된후 eviction-timeout을 초과한경우&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 노드에있는 pod들을 모두 축출한 후에 노드가 재시동됩니다.&lt;/li&gt;
      &lt;li&gt;해당 노드에있던 pod이 replicaset을 통해 생성되었다면 다시 다른노드에 잘 생성이 되겠지만, 일반 pod이라면 다시 살아나지 못할겁니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;노드관련-명령어&quot;&gt;노드관련 명령어&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt; kubectl drain node &lt;/code&gt;
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl drain node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;해당 노드에있는 pod들을 종료시키고, 다른노드에 재시작시킵니다 (graceful node shutdown) 또한 해당 노드를 unschedulable하게 만든다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kubernetes의 버전 또는 리눅스 커널등의 업그레이드할 때 사용할 수 있겠습니다(kubeadm, kubelet, kubectl, …)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt; kubectl cordon node &lt;/code&gt;
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl cordon node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 노드를 unschedulable하게 만듭니다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;실행 중인 Pod를 축출하지는 않습니다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt; kubectl uncordon node &lt;/code&gt;
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl uncordon node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 노드를 schedulable하게 만든다&lt;/li&gt;
      &lt;li&gt;업그레이드를 마친 노드를 스케쥴러블하게 만듭니다 (taint를 제거)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;drain명령에 의해서 집나간 pod들이 다시 집을 찾아오진 않습니다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;쿠버네티스-버전-및-버전차이-지원&quot;&gt;쿠버네티스 버전 및 버전차이 지원&lt;/h2&gt;

&lt;h3 id=&quot;버전&quot;&gt;버전&lt;/h3&gt;
&lt;p&gt;쿠버네티스 버전은 x.y.z로 표현되는데, 여기서 x는 메이저 버전, y는 마이너 버전, z는 시맨틱 버전 용어에 따른 패치 버전입니다.
kubernetes에는 여러가지 컴포넌트가 있습니다.
각각의 버전은 전부 동일해야할까요? 아닙니다.&lt;/p&gt;

&lt;p&gt;kube-apiserver의 버전이 주축이되고, 나머지 컴포넌트는 각각 다르게 한 두단계 버전이 낮거나 같아도 상관이 없습니다. 특별하게 &lt;strong&gt;kubectl&lt;/strong&gt;의 경우는 kube-apiserver의 버전보다 한단계 높은경우도 지원이 됩니다.&lt;/p&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://kubernetes.io/ko/docs/setup/release/version-skew-policy/&quot;&gt;공식문서&lt;/a&gt;에서 확인가능 합니다&lt;/p&gt;

&lt;h2 id=&quot;클러스터-업그레이드&quot;&gt;클러스터 업그레이드&lt;/h2&gt;

&lt;p&gt;kubernets는 latest버전부터 두단계 낮은버전까지 서비스를 지원하는데요, 만약에 현재 1.19버전을 사용하고 있는데 1.22버전이 출시 된다면 업그레이드를 해야겠죠.&lt;/p&gt;

&lt;p&gt;그렇다면 1.19버전에서 한번에 1.22번으로 업그레이드 시키면될까요? 추천되는 방법에 의하면
한단계 한단계씩 차례차례로 업그레이드 해야된다고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;업그레이드-방법&quot;&gt;업그레이드 방법&lt;/h3&gt;

&lt;p&gt;쿠버네티스 환경을 어떻게 구성하였는가에 따라 업그레이드 방법이 다양합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;구글의 GKE, AWS의 EKS등의 kubernete를 지원하는 cloud의 경우&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;간단한 클릭 몇번으로 업그레이드 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The hard way로 설치한경우&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한땀한땀 설치한 것처럼 업그레이드 또한 한땀한땀 해야합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;저는 &lt;strong&gt;kubeadm&lt;/strong&gt;을 이용하여 kubernetes환경을 구축하였고, &lt;strong&gt;kubeadm&lt;/strong&gt;을 통한 업그레이드 방법에 대해 자세히 설명해 보겠습니다.&lt;/p&gt;

&lt;p&gt;저의 쿠버네티스 환경은 한개의 master노드, 3개의 worker노드로 구성되어있습니다. 1.20버전을 이용하고 있는데 1.21버전으로 업그레이드 해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;step1---마스터-노드에-kubeadm-업그레이드-시키기&quot;&gt;STEP1 - 마스터 노드에 kubeadm 업그레이드 시키기.&lt;/h3&gt;

&lt;p&gt;마스터 노드에 접속합니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh gcloud
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ssh config&lt;/strong&gt;에 설정을 해놨기에 이렇게 간단하게 접속가능합니다. &lt;strong&gt;ssh config 설정방법&lt;/strong&gt;이 궁금하시면 &lt;a href=&quot;https://shjeong92.github.io/2021/06/01/Handling-ssh-config.html&quot;&gt;여기&lt;/a&gt;로 이동하세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고  kubernetes환경을 구축할때 hold시켜놨었던 kubeadm을 unhold시켜주고, apt-get 색인 업데이트후, kubeadm을 업데이트 한다음 다시 kubeadm을 hold시켜 줄겁니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 1.21.x-00에서 x를 최신 패치 버전으로 바꿉니다&lt;/span&gt;
apt-mark unhold kubeadm &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;kubeadm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.x-00 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
apt-mark hold kubeadm

&lt;span class=&quot;c&quot;&gt;#버전 확인해주기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm version
kubeadm version: &amp;amp;version.Info&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;Major:&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;, Minor:&lt;span class=&quot;s2&quot;&gt;&quot;21&quot;&lt;/span&gt;, GitVersion:&lt;span class=&quot;s2&quot;&gt;&quot;v1.21.1&quot;&lt;/span&gt;, GitCommit:&lt;span class=&quot;s2&quot;&gt;&quot;5e58841cce77d4bc13713ad2b91fa0d961e69192&quot;&lt;/span&gt;, GitTreeState:&lt;span class=&quot;s2&quot;&gt;&quot;clean&quot;&lt;/span&gt;, BuildDate:&lt;span class=&quot;s2&quot;&gt;&quot;2021-05-12T14:17:27Z&quot;&lt;/span&gt;, GoVersion:&lt;span class=&quot;s2&quot;&gt;&quot;go1.16.4&quot;&lt;/span&gt;, Compiler:&lt;span class=&quot;s2&quot;&gt;&quot;gc&quot;&lt;/span&gt;, Platform:&lt;span class=&quot;s2&quot;&gt;&quot;linux/amd64&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;apt-mark unhold&lt;/strong&gt;와 &lt;strong&gt;apt-mark hold&lt;/strong&gt; 해주는 이유는 kubeadm을 업그레이드하면 설치시 kubelet과 같은 다른 구성 요소가 기본적으로 최신 버전 으로 자동으로 업그레이드되기 때문입니다. (kubernetes는 여러버전을 한꺼번에 업그레이드 권장하지 않기때문입니다!) 이를 해결하기 위해 보류를 사용하여 패키지를 보류 된 것으로 표시하여 패키지가 자동으로 설치, 업그레이드 또는 제거되지 않도록합니다.&lt;/p&gt;

&lt;h3 id=&quot;step2---업그레이드-정보-확인하기&quot;&gt;STEP2 - 업그레이드 정보 확인하기&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade plan

...

COMPONENT            CURRENT AVAILABLE

API Server           v1.20.0 v1.21.1

Controller Manager   v1.20.0 v1.21.1

Scheduler            v1.20.0 v1.21.1

Kube Proxy           v1.20.0 v1.21.1

...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step3---업그레이드-적용시키기&quot;&gt;STEP3 - 업그레이드 적용시키기&lt;/h3&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade plan apply v1.21.1
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;조금 오래걸릴 수도 있습니다&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

아래와같이뜨면 성공
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;upgrade/successful] SUCCESS! Your cluster was upgraded to &lt;span class=&quot;s2&quot;&gt;&quot;v1.21.1&quot;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; Enjoy!

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;you haven&lt;span class=&quot;s1&quot;&gt;&apos;t already done so.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step4---node-drain후-kubelet-kubectl-업데이트후-재시작하기&quot;&gt;STEP4 - node drain후 kubelet, kubectl 업데이트후 재시작하기&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#노드 드레인하기(모든 pod 종료후 다른노드에 새로 실행하기 및 해당노드 unschedulable하게 만듬)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl drain &amp;lt;node-to-drain&amp;gt; &lt;span class=&quot;nt&quot;&gt;--ignore-daemonsets&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark unhold kubelet kubectl &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;kubelet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.1-00 &lt;span class=&quot;nv&quot;&gt;kubectl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.1-00 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark hold kubelet kubectl

&lt;span class=&quot;c&quot;&gt;#설정 수정사항 재로딩&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl daemon-reload
&lt;span class=&quot;c&quot;&gt;#kubelet 재시작&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl restart kubelet

&lt;span class=&quot;c&quot;&gt;#업데이트가 끝났으므로 다시 schedulable하게 만들어주기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl uncordon &amp;lt;node-to-uncordon&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기까지가 마스터노드의 업그레이드 방법이었습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;rocket-여기서부터는-워커노드들을-업그레이드-합니다&quot;&gt;:rocket: 여기서부터는 워커노드들을 업그레이드 합니다.&lt;/h1&gt;

&lt;h3 id=&quot;step5---워커-노드에-kubeadm-설치하기&quot;&gt;STEP5 - 워커 노드에 kubeadm 설치하기&lt;/h3&gt;

&lt;p&gt;우선 3개의 워커노드중 하나인 worker-1에 접속합니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh worker-1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그 다음, 마스터노드에 설치했던과 같은방법으로 kubeadm를 설치합니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark unhold kubeadm &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;kubeadm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.x-00 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark hold kubeadm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아까 마스터노드에서 아래의 커맨드를 이용해 upgrade가능 버전을 확인하고 v1.21.1로 apply했었습니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade plan
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade apply v1.21.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;하지만 워커노드에서는 아래의 커맨드를 이용하여 클러스터에서 kubeadm ClusterConfiguration 을 가져오며,
이 노드의 kubelet 구성을 업그레이드 합니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 마스터 노드로 이동하여 업그레이드 할 워커노드를 드레인 해줍니다. (마스터 노드에서 워커노드로 접속했었기에 접속 종료하면 마스터노드로 이동합니다.)&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit
logout
&lt;/span&gt;Connection to 10.128.0.5 closed.

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl drain worker-1 &lt;span class=&quot;nt&quot;&gt;--ignore-daemonsets&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step6---워커노드의-kubelet-및-kubectl-업그레이드&quot;&gt;STEP6 - 워커노드의 kubelet 및 kubectl 업그레이드&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 다시 워커노드로 접속하기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh worker-1
 

&lt;span class=&quot;c&quot;&gt;# kubectl 과 kubelet 업데이트하기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark unhold kubectl kubelet &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;kubectl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.1-00 &lt;span class=&quot;nv&quot;&gt;kubelet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.1-00 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark hold kubectl kubelet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step7---kubelet-다시-시작하기&quot;&gt;STEP7 - kubelet 다시 시작하기&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl daemon-reload
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl restart kubelet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step8---cordon-해재하기&quot;&gt;STEP8 - cordon 해재하기&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#마스터노드로 이동하기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl uncordon worker-1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step9---반복하기&quot;&gt;STEP9 - 반복하기&lt;/h3&gt;

&lt;p&gt;업그레이드 할 워커노드에
STEP5 ~ STEP8을 똑같이 진행해줍니다&lt;/p&gt;

&lt;p&gt;마지막으로 업데이트가 잘 되었는지 확인해줍니다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get nodes
NAME         STATUS   ROLES                  AGE    VERSION
master       Ready    control-plane,master   6d8h   v1.21.1
worker-1     Ready    &amp;lt;none&amp;gt;                 6d8h   v1.21.1
worker-2     Ready    &amp;lt;none&amp;gt;                 6d8h   v1.21.1
worker-3     Ready    &amp;lt;none&amp;gt;                 6d8h   v1.21.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;버전이 v1.21.1로 잘 업그레이드 된것을 확인할 수 있습니다.&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Kubernetes" /><category term="maintenance" /><category term="static" /><category term="pod" /><category term="strategy" /><category term="쿠버네티스" /><category term="update" /><summary type="html">오늘은 클러스터의 유지보수에 관련한 포스트를 써볼까 합니다. 쿠버네티스를 이용하여 서비스를 구축하고나서 언젠가는 시스템을 업데이트 시켜야할 일이 생길 것이며, 오류로 인하여 노드가 먹통이 되는일도 생길 것입니다. 그렇다면 노드의 작동을 중지시키면, 또는 오류로 중지된다면 어떻게 될까요? master node의 kube-contoller-manager에는 pod-eviction-timeout이 존재합니다 컨디션 각 노드에는 아래와 같이 여러가지 condition이 존재합니다 노드 컨디션 설명 Ready 노드가 상태 양호하며 파드를 수용할 준비가 되어 있는 경우 True, 노드의 상태가 불량하여 파드를 수용하지 못할 경우 False, 그리고 노드 컨트롤러가 마지막 node-monitor-grace-period (기본값 40 기간 동안 노드로부터 응답을 받지 못한 경우) Unknown DiskPressure 디스크 사이즈 상에 압박이 있는 경우, 즉 디스크 용량이 넉넉치 않은 경우 True, 반대의 경우 False MemoryPressure 노드 메모리 상에 압박이 있는 경우, 즉 노드 메모리가 넉넉치 않은 경우 True, 반대의 경우 False PIDPressure 프로세스 상에 압박이 있는 경우, 즉 노드 상에 많은 프로세스들이 존재하는 경우 True, 반대의 경우 False NetworkUnavailable 노드에 대해 네트워크가 올바르게 구성되지 않은 경우 True, 반대의 경우 False 또한 노드 lifecycle controller는 컨디션을 아래와 같은 built-in taint를 자동으로 생성합니다. built-in taints node.kubernetes.io/not-ready: 노드가 준비되지 않음. 이는 NodeCondition Ready 가 “False”로 됨에 해당. node.kubernetes.io/unreachable: 노드가 노드 컨트롤러에서 도달할 수 없음. 이는 NodeCondition Ready 가 “Unknown”로 됨에 해당. node.kubernetes.io/memory-pressure: 노드에 메모리 할당 압박이 있음. node.kubernetes.io/disk-pressure: 노드에 디스크 할당 압박이 있음. node.kubernetes.io/pid-pressure: 노드에 PID 할당 압박이 있음. node.kubernetes.io/network-unavailable: 노드의 네트워크를 사용할 수 없음. node.kubernetes.io/unschedulable: 노드를 스케줄할 수 없음. node.cloudprovider.kubernetes.io/uninitialized: “외부” 클라우드 공급자로 kubelet을 시작하면, 이 테인트가 노드에서 사용 불가능으로 표시되도록 설정됨. 그 중에서도 ready 컨디션은 좀 특별한데요. ready 컨디션의 상태가 pod-eviction-timeout (kube-controller-manager에 전달된 인수) 보다 더 길게 Unknown 또는 False로 유지되는 경우, 노드 상에 모든 파드는 노드 컨트롤러에 의해 삭제되도록 스케줄 됩니다. 클라우드-컨트롤러-관리자의 컨트롤러가 이 노드를 초기화하면, kubelet이 이 테인트를 제거합니다 즉 다시 pod가 배정될 수 있는 상태가 되는것이죠. 기본 축출 타임아웃 기간은 기본 5분으로 설정되어 있습니다. 만약 노드가 다운되었다가 5분안에 복구가 되었다면 노드 내의 pod들은 그대로 존재하지만, 설정된 타임아웃 시간을 초과한다면 그안의 파드들은 모두 중단 되는것입니다. 만약 수정하고 싶다면 마스터 노드의 kube-system 네임스페이스에 있는 kube-controller-manager-master을 edit해주면됩니다. 그런데 말이죠 이 pod는 static pod입니다. 6번째 포스트에서 설명 했었는데 static pod 를 수정하려면 static pod을 생성한 yaml파일 자체를 수정한다고 했었죠? static pod의 위치를 찾는것 부터 복습해봅시다 우선 config.yaml파일의 위치를 찾아줍니다. $ ps -ef | grep kubelet | grep &quot;\--config&quot; root 10476 1 3 May28 ? 05:09:26 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --network-plugin=cni --pod-infra-container-image=k8s.gcr.io/pause:3.4.1 config.yaml파일 내에서 staticpath를 찾아냅시다 $ sudo grep -i static /var/lib/kubelet/config.yaml staticPodPath: /etc/kubernetes/manifests staticPodPath로 이동후 뭐가있나 확인해봅니다. $ cd /etc/kubernetes/manifests $ ls etcd.yaml kube-apiserver.yaml kube-controller-manager.yaml kube-scheduler.yaml 자 이제 이 yaml파일을 수정하면 됩니다. 저는 이 기본 5분인 eviction-timeout을 60초로 바꾸어 보겠습니다. command에 --pod-eviction-timeout=60s 옵션을 추가해 줌으로써 말이죠. apiVersion: v1 kind: Pod metadata: annotations: kubernetes.io/config.hash: 47cace34a635d6f3e305eee20e0e7b30 kubernetes.io/config.mirror: 47cace34a635d6f3e305eee20e0e7b30 kubernetes.io/config.seen: &quot;2021-05-28T03:40:42.961803243Z&quot; kubernetes.io/config.source: file creationTimestamp: &quot;2021-05-28T03:40:55Z&quot; labels: component: kube-controller-manager tier: control-plane name: kube-controller-manager-master namespace: kube-system ownerReferences: - apiVersion: v1 controller: true kind: Node name: master uid: 69f4d243-9420-45a9-928e-672a1d3b977a resourceVersion: &quot;478&quot; uid: 4cfad35d-8664-42cf-9ed9-5fd5b4d771a4 spec: containers: - command: - kube-controller-manager - --allocate-node-cidrs=true - --pod-eviction-timeout=60s #&amp;lt;----------- 해당라인을 추가하면 이제 5분이아닌 60초로 변경됩니다. - --authentication-kubeconfig=/etc/kubernetes/controller-manager.conf - --authorization-kubeconfig=/etc/kubernetes/controller-manager.conf - --bind-address=127.0.0.1 - --client-ca-file=/etc/kubernetes/pki/ca.crt - --cluster-cidr=10.244.0.0/16 - --cluster-name=kubernetes - --cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt - --cluster-signing-key-file=/etc/kubernetes/pki/ca.key - --controllers=*,bootstrapsigner,tokencleaner - --kubeconfig=/etc/kubernetes/controller-manager.conf - --leader-elect=true - --port=0 - --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt - --root-ca-file=/etc/kubernetes/pki/ca.crt - --service-account-private-key-file=/etc/kubernetes/pki/sa.key - --service-cluster-ip-range=10.96.0.0/12 - --use-service-account-credentials=true image: k8s.gcr.io/kube-controller-manager:v1.21.1 ...중략 저장해주면 멈췄다가 kube-controller-manager-master 0/1 Running 0 3s 옵션을 적용시켜 pod시 재시동됩니다~ kube-controller-manager-master 1/1 Running 0 3s eviction timeout의 존재이유? 위에서 eviction timeout의 값을 바꾸는 실습을 해보았는데요 이 timeout은 무엇과 연관이 있는지 두가지 케이스를 통해서 알아보겠습니다. case1: node가 먹통이 되었다가 설정해놓은 eviction-timeout보다 짦은시간안에 복구된경우 노드내에 있던 pod들이 kubectl에 의해 다시 해당노드에서 재시작됩니다. case2: node가 먹통이 된후 eviction-timeout을 초과한경우 해당 노드에있는 pod들을 모두 축출한 후에 노드가 재시동됩니다. 해당 노드에있던 pod이 replicaset을 통해 생성되었다면 다시 다른노드에 잘 생성이 되겠지만, 일반 pod이라면 다시 살아나지 못할겁니다. 노드관련 명령어 kubectl drain node $ kubectl drain node 해당 노드에있는 pod들을 종료시키고, 다른노드에 재시작시킵니다 (graceful node shutdown) 또한 해당 노드를 unschedulable하게 만든다. kubernetes의 버전 또는 리눅스 커널등의 업그레이드할 때 사용할 수 있겠습니다(kubeadm, kubelet, kubectl, …) kubectl cordon node $ kubectl cordon node 해당 노드를 unschedulable하게 만듭니다 실행 중인 Pod를 축출하지는 않습니다 kubectl uncordon node $ kubectl uncordon node 해당 노드를 schedulable하게 만든다 업그레이드를 마친 노드를 스케쥴러블하게 만듭니다 (taint를 제거) drain명령에 의해서 집나간 pod들이 다시 집을 찾아오진 않습니다. 쿠버네티스 버전 및 버전차이 지원 버전 쿠버네티스 버전은 x.y.z로 표현되는데, 여기서 x는 메이저 버전, y는 마이너 버전, z는 시맨틱 버전 용어에 따른 패치 버전입니다. kubernetes에는 여러가지 컴포넌트가 있습니다. 각각의 버전은 전부 동일해야할까요? 아닙니다. kube-apiserver의 버전이 주축이되고, 나머지 컴포넌트는 각각 다르게 한 두단계 버전이 낮거나 같아도 상관이 없습니다. 특별하게 kubectl의 경우는 kube-apiserver의 버전보다 한단계 높은경우도 지원이 됩니다. 더 자세한 내용은 공식문서에서 확인가능 합니다 클러스터 업그레이드 kubernets는 latest버전부터 두단계 낮은버전까지 서비스를 지원하는데요, 만약에 현재 1.19버전을 사용하고 있는데 1.22버전이 출시 된다면 업그레이드를 해야겠죠. 그렇다면 1.19버전에서 한번에 1.22번으로 업그레이드 시키면될까요? 추천되는 방법에 의하면 한단계 한단계씩 차례차례로 업그레이드 해야된다고 합니다. 업그레이드 방법 쿠버네티스 환경을 어떻게 구성하였는가에 따라 업그레이드 방법이 다양합니다. 구글의 GKE, AWS의 EKS등의 kubernete를 지원하는 cloud의 경우 간단한 클릭 몇번으로 업그레이드 가능 The hard way로 설치한경우 한땀한땀 설치한 것처럼 업그레이드 또한 한땀한땀 해야합니다 저는 kubeadm을 이용하여 kubernetes환경을 구축하였고, kubeadm을 통한 업그레이드 방법에 대해 자세히 설명해 보겠습니다. 저의 쿠버네티스 환경은 한개의 master노드, 3개의 worker노드로 구성되어있습니다. 1.20버전을 이용하고 있는데 1.21버전으로 업그레이드 해보겠습니다. STEP1 - 마스터 노드에 kubeadm 업그레이드 시키기. 마스터 노드에 접속합니다 $ ssh gcloud ssh config에 설정을 해놨기에 이렇게 간단하게 접속가능합니다. ssh config 설정방법이 궁금하시면 여기로 이동하세요. 그리고 kubernetes환경을 구축할때 hold시켜놨었던 kubeadm을 unhold시켜주고, apt-get 색인 업데이트후, kubeadm을 업데이트 한다음 다시 kubeadm을 hold시켜 줄겁니다. # 1.21.x-00에서 x를 최신 패치 버전으로 바꿉니다 apt-mark unhold kubeadm &amp;amp;&amp;amp; \ apt-get update &amp;amp;&amp;amp; apt-get install -y kubeadm=1.21.x-00 &amp;amp;&amp;amp; \ apt-mark hold kubeadm #버전 확인해주기 $ kubeadm version kubeadm version: &amp;amp;version.Info{Major:&quot;1&quot;, Minor:&quot;21&quot;, GitVersion:&quot;v1.21.1&quot;, GitCommit:&quot;5e58841cce77d4bc13713ad2b91fa0d961e69192&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2021-05-12T14:17:27Z&quot;, GoVersion:&quot;go1.16.4&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;} apt-mark unhold와 apt-mark hold 해주는 이유는 kubeadm을 업그레이드하면 설치시 kubelet과 같은 다른 구성 요소가 기본적으로 최신 버전 으로 자동으로 업그레이드되기 때문입니다. (kubernetes는 여러버전을 한꺼번에 업그레이드 권장하지 않기때문입니다!) 이를 해결하기 위해 보류를 사용하여 패키지를 보류 된 것으로 표시하여 패키지가 자동으로 설치, 업그레이드 또는 제거되지 않도록합니다. STEP2 - 업그레이드 정보 확인하기 $ kubeadm upgrade plan ... COMPONENT CURRENT AVAILABLE API Server v1.20.0 v1.21.1 Controller Manager v1.20.0 v1.21.1 Scheduler v1.20.0 v1.21.1 Kube Proxy v1.20.0 v1.21.1 ... STEP3 - 업그레이드 적용시키기 $ kubeadm upgrade plan apply v1.21.1 (조금 오래걸릴 수도 있습니다) 아래와같이뜨면 성공 [upgrade/successful] SUCCESS! Your cluster was upgraded to &quot;v1.21.1&quot;. Enjoy! [upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven&apos;t already done so. STEP4 - node drain후 kubelet, kubectl 업데이트후 재시작하기 #노드 드레인하기(모든 pod 종료후 다른노드에 새로 실행하기 및 해당노드 unschedulable하게 만듬) $ kubectl drain &amp;lt;node-to-drain&amp;gt; --ignore-daemonsets $ apt-mark unhold kubelet kubectl &amp;amp;&amp;amp; \ $ apt-get update &amp;amp;&amp;amp; apt-get install -y kubelet=1.21.1-00 kubectl=1.21.1-00 &amp;amp;&amp;amp; \ $ apt-mark hold kubelet kubectl #설정 수정사항 재로딩 $ sudo systemctl daemon-reload #kubelet 재시작 $ sudo systemctl restart kubelet #업데이트가 끝났으므로 다시 schedulable하게 만들어주기 $ kubectl uncordon &amp;lt;node-to-uncordon&amp;gt; 여기까지가 마스터노드의 업그레이드 방법이었습니다. :rocket: 여기서부터는 워커노드들을 업그레이드 합니다. STEP5 - 워커 노드에 kubeadm 설치하기 우선 3개의 워커노드중 하나인 worker-1에 접속합니다. ssh worker-1 그 다음, 마스터노드에 설치했던과 같은방법으로 kubeadm를 설치합니다. $ apt-mark unhold kubeadm &amp;amp;&amp;amp; \ $ apt-get update &amp;amp;&amp;amp; apt-get install -y kubeadm=1.21.x-00 &amp;amp;&amp;amp; \ $ apt-mark hold kubeadm 아까 마스터노드에서 아래의 커맨드를 이용해 upgrade가능 버전을 확인하고 v1.21.1로 apply했었습니다. $ kubeadm upgrade plan $ kubeadm upgrade apply v1.21.1 하지만 워커노드에서는 아래의 커맨드를 이용하여 클러스터에서 kubeadm ClusterConfiguration 을 가져오며, 이 노드의 kubelet 구성을 업그레이드 합니다. $ kubeadm upgrade node 그리고 마스터 노드로 이동하여 업그레이드 할 워커노드를 드레인 해줍니다. (마스터 노드에서 워커노드로 접속했었기에 접속 종료하면 마스터노드로 이동합니다.) $ exit logout Connection to 10.128.0.5 closed. $ kubectl drain worker-1 --ignore-daemonsets STEP6 - 워커노드의 kubelet 및 kubectl 업그레이드 # 다시 워커노드로 접속하기 $ ssh worker-1 # kubectl 과 kubelet 업데이트하기 $ apt-mark unhold kubectl kubelet &amp;amp;&amp;amp; \ $ apt-get update &amp;amp;&amp;amp; apt-get install -y kubectl=1.21.1-00 kubelet=1.21.1-00 &amp;amp;&amp;amp; \ $ apt-mark hold kubectl kubelet STEP7 - kubelet 다시 시작하기 $ sudo systemctl daemon-reload $ sudo systemctl restart kubelet STEP8 - cordon 해재하기 #마스터노드로 이동하기 $ exit $ kubectl uncordon worker-1 STEP9 - 반복하기 업그레이드 할 워커노드에 STEP5 ~ STEP8을 똑같이 진행해줍니다 마지막으로 업데이트가 잘 되었는지 확인해줍니다 $ kubectl get nodes NAME STATUS ROLES AGE VERSION master Ready control-plane,master 6d8h v1.21.1 worker-1 Ready &amp;lt;none&amp;gt; 6d8h v1.21.1 worker-2 Ready &amp;lt;none&amp;gt; 6d8h v1.21.1 worker-3 Ready &amp;lt;none&amp;gt; 6d8h v1.21.1 버전이 v1.21.1로 잘 업그레이드 된것을 확인할 수 있습니다.</summary></entry><entry><title type="html">[ #7 ] 배포 전략</title><link href="https://shjeong92.github.io/2021/06/02/Learning-Kubernetes-07.html" rel="alternate" type="text/html" title="[ #7 ] 배포 전략" /><published>2021-06-02T00:00:00+09:00</published><updated>2021-06-02T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/02/Learning-Kubernetes-07</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/02/Learning-Kubernetes-07.html">&lt;p&gt;쿠버네티스에는아래 그림과 같이 두가지 배포방법이 있습니다&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/120428975-9582c300-c3af-11eb-95cf-ba8825576440.png&quot; alt=&quot;deplstrategy&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;recreate&quot;&gt;Recreate&lt;/h2&gt;
&lt;p&gt;Recreate 방식은 이전버전 A를 종료시킨후 신규버전 B를 롤아웃 시키는 방식입니다.&lt;/p&gt;

&lt;h3 id=&quot;pros&quot;&gt;pros&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;가장 쉬운 배포방법&lt;/li&gt;
  &lt;li&gt;클라우드 리소스 비요이 적음&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cons&quot;&gt;cons&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;A가 중지되고 B가 배포되기전까지 서비스가 중단되어 사용자에게 악영향을 줌&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rolling-update&quot;&gt;Rolling Update&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기존서버를 순차적으로 중지시키며 순차적으로 업그레이드 시키는 방식으로, kubernetes에서 spec.strategy.type을 지정하지 않으면 기본적으로 RollingUpdate를 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;처음 쿠버네티스에 입문하였을때 replicaset과, deployment의 차이점은 yaml파일로만 놓고 봤을때는 다른점이 kind 부분 말고는 없었습니다. 똑같이 파드를 적정갯수 만큼 생성해주고, crash되면 다시 복구시켜주는 점에서는 말이죠.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오늘은 배포방식에 대해 공부하면서 왜 deployment를 사용하여 pod을 배포하는가에 대한 궁금증을 풀 수 있었습니다.&lt;/p&gt;

&lt;p&gt;Deployment를 사용하여 pod을 배포 하게되면 롤아웃을 생성합니다. 그리고 이 롤아웃은 새로운 배포 버전(revision)을 생성합니다. 이말이 잘 이해가 안 되실수도 있는데&lt;/p&gt;

&lt;p&gt;자세한 설명은 실습을 진행하면서 하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;아래와같이 deployment definition을 작성한 yaml파일이 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#depl.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-deployment&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-pod&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래의 명령어를 사용하여 deployment를 생성하게되면&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; depl.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;myapp-deployment라는 이름을가진 deployment와, myapp-deployment-hash값 을 가진 replicaset, 그리고 deployment를 통해 생성된 replicaset에 의해 생성된 pod을 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl get all
NAME                                    READY   STATUS    RESTARTS   AGE
pod/myapp-deployment-7df67f74c5-4nkmq   1/1     Running   0          5m27s
pod/myapp-deployment-7df67f74c5-bnl9r   1/1     Running   0          5m27s
pod/myapp-deployment-7df67f74c5-jsd9p   1/1     Running   0          5m27s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;S&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   AGE
service/kubernetes   ClusterIP   10.96.0.1    &amp;lt;none&amp;gt;        443/TCP   5d2h

NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/myapp-deployment   3/3     3            3           5m27s

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/myapp-deployment-7df67f74c5   3         3         3       5m27s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아직까지는 별 차이가 없지요, deployment가 생겼다는것 외에는 말입니다.&lt;/p&gt;

&lt;p&gt;하지만 사실은 이외에도 &lt;code&gt;revision&lt;/code&gt;이라는 것을 생성합니다.&lt;/p&gt;

&lt;p&gt;이는 해당 deployment를 업데이트 할때마다 생기고, 이전 &lt;code&gt;revision&lt;/code&gt;의 정보도 가집니다. 또한, 새로운 버전의 &lt;code&gt;replicaset&lt;/code&gt;을 생성하고, 이전버전의 &lt;code&gt;replicaset&lt;/code&gt;의 정보를 남겨놓습니다.&lt;/p&gt;

&lt;p&gt;만약에 업데이트후에 문제가 생겼을시에 롤백을 가능케 하기 위해서 입니다. 그리고 이러한점이 &lt;strong&gt;deployment&lt;/strong&gt;를 사용해서 pod을 배포했을때랑 &lt;strong&gt;replicaset&lt;/strong&gt;을 사용했을때의 가장 큰 차이점이 아닐까 싶습니다.&lt;/p&gt;

&lt;h2 id=&quot;rollout-상태확인&quot;&gt;Rollout 상태확인&lt;/h2&gt;

&lt;p&gt;deployment를 사용하여 pod을 배포하게되면 rollout을 생성한다고 했었는데 
추가로 사용할 수 있는 커맨드도 생깁니다. &lt;code&gt;rollout&lt;/code&gt; 이라는 커맨드인데요.&lt;/p&gt;

&lt;p&gt;rollout 커맨드를 통하여 deployment의 revision및 history를 확인할 수 있습니다&lt;/p&gt;

&lt;p&gt;&lt;code&gt; kubectl rollout status deployment &lt;/code&gt; 커맨드를 사용하여 다음과 같이 롤아웃 생성의 상태를 확인할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl rollout status deployment/myapp-deployment
Waiting &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;deployment &lt;span class=&quot;s2&quot;&gt;&quot;myapp-deployment&quot;&lt;/span&gt; rollout to finish: 0 of 3 updated replicas are available...
Waiting &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;deployment &lt;span class=&quot;s2&quot;&gt;&quot;myapp-deployment&quot;&lt;/span&gt; rollout to finish: 1 of 3 updated replicas are available...
Waiting &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;deployment &lt;span class=&quot;s2&quot;&gt;&quot;myapp-deployment&quot;&lt;/span&gt; rollout to finish: 2 of 3 updated replicas are available...
deployment &lt;span class=&quot;s2&quot;&gt;&quot;myapp-deployment&quot;&lt;/span&gt; successfully rolled out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;rollout-history-확인&quot;&gt;Rollout history 확인&lt;/h2&gt;

&lt;p&gt;또한 &lt;code&gt; kubectl rollout history deployment &lt;/code&gt; 커맨드를 사용하면 아래와 같이 리비전 정보를 확인할 수 있는데요&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl rollout &lt;span class=&quot;nb&quot;&gt;history &lt;/span&gt;deploy/myapp-deployment
deployment.apps/myapp-deployment 
REVISION  CHANGE-CAUSE
1         &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하나의 revision 밖에 보이지않습니다. 그 이유는 depl.yaml을 이용하여 처음으로 배포한 버전이기 때문입니다.&lt;/p&gt;

&lt;h2 id=&quot;rollout-update&quot;&gt;Rollout update&lt;/h2&gt;
&lt;p&gt;해당 deployment를 업데이트하면 어떤일이 생기는지 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;우선 yaml파일을 수정해줍니다&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#depl.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-deployment&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-pod&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx:1.20-alpine       &amp;lt;----- 바뀐부분&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이미지를 바꿀때에는 간단하게 set image를 통해서도 가능하지만 개인적으로 변경상황을 이력으로 남기는게 좋다고 생각하여 해당 방법을 사용합니다.&lt;/p&gt;

&lt;p&gt;변경사항을 적용시켜줍니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; depl.yaml
deployment.apps/myapp-deployment configured
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그다음 replicaset과 revision을 확인해봅시다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get rs
NAME                          DESIRED   CURRENT   READY   AGE
myapp-deployment-79896f8f68   3         3         3       5m14s
myapp-deployment-7df67f74c5   0         0         0       5m42s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;replicaset이 하나더 생겼으며,&lt;/p&gt;

&lt;p&gt;revision도 하나더 생긴것을 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl rollout history deploy myapp-deployment
deployment.apps/myapp-deployment 
REVISION  CHANGE-CAUSE
2         &amp;lt;none&amp;gt;
1         &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 change-cause가 None 으로 되있으면 무엇이 바뀌었는지 알 수 가없는데, 아래 커맨드를 이용하면 따로 설정이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;kubectl annotate deployment.v1.apps/[deployment name] kubernetes.io/change-cause=&quot;reason of update&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;해당커맨드를 사용하여 주석을 달고 다시 확인해봅시다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl annotate deployment.v1.apps/myapp-deployment kubernetes.io/change-cause&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;image updated to 1.20&quot;&lt;/span&gt;
deployment.apps/myapp-deployment annotated


&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl rollout &lt;span class=&quot;nb&quot;&gt;history &lt;/span&gt;deployment myapp-deployment
deployment.apps/myapp-deployment 
REVISION  CHANGE-CAUSE
1         &amp;lt;none&amp;gt;
2         image updated to 1.20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;주석이 잘 달린것을 확인할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;rollback&quot;&gt;Rollback&lt;/h2&gt;
&lt;p&gt;만약에 새로운 버전으로 업데이트를 했는데 문제가 생겼을때 이전 버전 으로 돌아갈 수 있는 기능입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt; kubeclt rollout undo deployment &lt;/code&gt;커맨드를 사용하여 롤백 시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;직접 실습해봅시다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl rollout undo deployment myapp-deployment
deployment.apps/myapp-deployment rolled back
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;성공적으로 롤백 되었다고 뜹니다.&lt;/p&gt;

&lt;p&gt;우선 image가 다시 원래대로 돌아왔는지 확인해봅니다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl describe deployment myapp-deployment
Name:                   myapp-deployment
Namespace:              default
CreationTimestamp:      Wed, 02 Jun 2021 07:05:06 +0000
Labels:                 &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;myapp
                        &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;front-end
Annotations:            deployment.kubernetes.io/revision: 3
                        kubernetes.io/change-cause: 
Selector:               &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;front-end
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;myapp
           &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;front-end
  Containers:
   nginx-container:
    Image:        nginx          &amp;lt;&lt;span class=&quot;nt&quot;&gt;-------&lt;/span&gt; 1.20 에서 다시 원래대로 돌아온것을 확인할 수 있습니다.
    Port:         &amp;lt;none&amp;gt;
    Host Port:    &amp;lt;none&amp;gt;
    Environment:  &amp;lt;none&amp;gt;
    Mounts:       &amp;lt;none&amp;gt;
  Volumes:        &amp;lt;none&amp;gt;
Conditions:
  Type           Status  Reason
  &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;           &lt;span class=&quot;nt&quot;&gt;------&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;------&lt;/span&gt;
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &amp;lt;none&amp;gt;
NewReplicaSet:   myapp-deployment-7df67f74c5 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3/3 replicas created&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Events:
  Type    Reason             Age                  From                   Message
  &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;    &lt;span class=&quot;nt&quot;&gt;------&lt;/span&gt;             &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;                 &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;                   &lt;span class=&quot;nt&quot;&gt;-------&lt;/span&gt;
  Normal  ScalingReplicaSet  23m                  deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 1
  Normal  ScalingReplicaSet  23m                  deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 2
  Normal  ScalingReplicaSet  23m                  deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 2
  Normal  ScalingReplicaSet  23m                  deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 1
  Normal  ScalingReplicaSet  23m                  deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 3
  Normal  ScalingReplicaSet  23m                  deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 0
  Normal  ScalingReplicaSet  4m28s                deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 1
  Normal  ScalingReplicaSet  4m24s                deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 2
  Normal  ScalingReplicaSet  4m24s                deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 2
  Normal  ScalingReplicaSet  4m20s &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x2 over 24m&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 3
  Normal  ScalingReplicaSet  4m20s                deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 1
  Normal  ScalingReplicaSet  4m16s                deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그럼 replicaset과 revision은 어떨까요?&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#이미지 1.20으로 업데이트후 replicaset 상태&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get rs
NAME                          DESIRED   CURRENT   READY   AGE
myapp-deployment-79896f8f68   3         3         3       5m14s
myapp-deployment-7df67f74c5   0         0         0       5m42s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#롤백후 replicaset상태&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get rs
NAME                          DESIRED   CURRENT   READY   AGE
myapp-deployment-79896f8f68   0         0         0       25m
myapp-deployment-7df67f74c5   3         3         3       26m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;revision&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl rollout &lt;span class=&quot;nb&quot;&gt;history &lt;/span&gt;deployment myapp-deployment
deployment.apps/myapp-deployment 
REVISION  CHANGE-CAUSE
2         image updated to 1.20
3         &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;replicaset은 이전 버전의 replicaset으로 바뀐것을 확인할 수가 있는데 revision은 1로돌아가는것이아닌 1이 증가한 것을 확인할 수 있습니다.
여기서 궁금한점이 생겼습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;undo를 여러번하면 어떻게될까요?&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl rollout &lt;span class=&quot;nb&quot;&gt;history &lt;/span&gt;deployment myapp-deployment
deployment.apps/myapp-deployment 
REVISION  CHANGE-CAUSE
3         &amp;lt;none&amp;gt;
4         image updated to 1.20
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;결과&quot;&gt;결과&lt;/h3&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl describe deployment myapp-deployment
Name:                   myapp-deployment
Namespace:              default
CreationTimestamp:      Wed, 02 Jun 2021 07:05:06 +0000
Labels:                 &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;myapp
                        &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;front-end
Annotations:            deployment.kubernetes.io/revision: 4
                        kubernetes.io/change-cause: image updated to 1.20
Selector:               &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;front-end
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  &lt;span class=&quot;nv&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;myapp
           &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;front-end
  Containers:
   nginx-container:
    Image:        nginx:1.20
    Port:         &amp;lt;none&amp;gt;
    Host Port:    &amp;lt;none&amp;gt;
    Environment:  &amp;lt;none&amp;gt;
    Mounts:       &amp;lt;none&amp;gt;
  Volumes:        &amp;lt;none&amp;gt;
Conditions:
  Type           Status  Reason
  &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;           &lt;span class=&quot;nt&quot;&gt;------&lt;/span&gt;  &lt;span class=&quot;nt&quot;&gt;------&lt;/span&gt;
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &amp;lt;none&amp;gt;
NewReplicaSet:   myapp-deployment-79896f8f68 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3/3 replicas created&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Events:
  Type    Reason             Age                  From                   Message
  &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;    &lt;span class=&quot;nt&quot;&gt;------&lt;/span&gt;             &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;                 &lt;span class=&quot;nt&quot;&gt;----&lt;/span&gt;                   &lt;span class=&quot;nt&quot;&gt;-------&lt;/span&gt;
  Normal  ScalingReplicaSet  14m                  deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 1
  Normal  ScalingReplicaSet  14m                  deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 2
  Normal  ScalingReplicaSet  14m                  deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 2
  Normal  ScalingReplicaSet  14m &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x2 over 33m&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;    deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 3
  Normal  ScalingReplicaSet  14m                  deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 1
  Normal  ScalingReplicaSet  13m                  deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 0
  Normal  ScalingReplicaSet  2m13s &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x2 over 33m&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 1
  Normal  ScalingReplicaSet  2m9s &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x2 over 33m&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 2
  Normal  ScalingReplicaSet  2m9s &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x2 over 33m&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 2
  Normal  ScalingReplicaSet  2m5s &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x2 over 33m&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 1
  Normal  ScalingReplicaSet  2m5s &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x2 over 33m&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   deployment-controller  Scaled up replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-79896f8f68 to 3
  Normal  ScalingReplicaSet  2m1s &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x2 over 33m&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;   deployment-controller  Scaled down replica &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;myapp-deployment-7df67f74c5 to 0

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;undo 를 여러번하니 nginx &amp;lt;-&amp;gt; nginx:1.20 왔다 갔다 하는 모습을 보여줍니다.&lt;/p&gt;

&lt;h2 id=&quot;rocket-history&quot;&gt;:rocket: history&lt;/h2&gt;
&lt;p&gt;history를 보아도 두줄의 결과만 보여주기도했고, 정말 바로 이전단계까지만 이동할 수 있는건지도 궁금했습니다.&lt;/p&gt;

&lt;p&gt;궁금한건 못참기에 바로 kubernetes.io를 찾다보니 원하는 revision으로 가려면 &lt;strong&gt;–to-revision=[resion-number]&lt;/strong&gt; 를 입력해야되는것을 알 수 있었습니다.&lt;/p&gt;

&lt;p&gt;deployment 의 spec 밑에 revisionHistoryLimit: 10 으로 설정되어 있는것도 확인했으며 이 또한 수정할 수 있었군요 ㅎㅎ&lt;/p&gt;

&lt;p&gt;바로 이전 단계만 이동 가능하다고 포스트 올렸다가 호다닥 수정하네요&lt;/p&gt;

&lt;p&gt;그나저나 history에는 왜 사람 햇갈리게 두줄만을 보여줬던 걸까요?&lt;/p&gt;

&lt;p&gt;kubernetes는 상당히 &lt;strong&gt;똑똑했기&lt;/strong&gt; 때문입니다.&lt;/p&gt;

&lt;p&gt;이미 기억하고있는 replicaset랑 다름이 없기에 새로운 replicaset을 생성하지 않는것이었습니다.&lt;/p&gt;

&lt;p&gt;history에 없는 다른 버전의 nginx의 이미지로 바꾸어주니 replicaset과 history 각각 하나씩 더 생기는것을 확인할 수 있었습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get rs
NAME                          DESIRED   CURRENT   READY   AGE
myapp-deployment-54d59f8648   3         3         3       17m
myapp-deployment-79896f8f68   0         0         0       117m
myapp-deployment-7df67f74c5   0         0         0       118m

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl rollout &lt;span class=&quot;nb&quot;&gt;history &lt;/span&gt;deploy myapp-deployment
deployment.apps/myapp-deployment 
REVISION  CHANGE-CAUSE
3         image updated to 1.20
4         &amp;lt;none&amp;gt;
5         &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Docker" /><category term="Kubernetes" /><category term="Replicasets" /><category term="Deployment" /><category term="static" /><category term="pod" /><category term="strategy" /><category term="쿠버네티스" /><category term="rolling" /><category term="update" /><summary type="html">쿠버네티스에는아래 그림과 같이 두가지 배포방법이 있습니다 Recreate Recreate 방식은 이전버전 A를 종료시킨후 신규버전 B를 롤아웃 시키는 방식입니다. pros 가장 쉬운 배포방법 클라우드 리소스 비요이 적음 cons A가 중지되고 B가 배포되기전까지 서비스가 중단되어 사용자에게 악영향을 줌 Rolling Update 기존서버를 순차적으로 중지시키며 순차적으로 업그레이드 시키는 방식으로, kubernetes에서 spec.strategy.type을 지정하지 않으면 기본적으로 RollingUpdate를 사용합니다. 처음 쿠버네티스에 입문하였을때 replicaset과, deployment의 차이점은 yaml파일로만 놓고 봤을때는 다른점이 kind 부분 말고는 없었습니다. 똑같이 파드를 적정갯수 만큼 생성해주고, crash되면 다시 복구시켜주는 점에서는 말이죠. 오늘은 배포방식에 대해 공부하면서 왜 deployment를 사용하여 pod을 배포하는가에 대한 궁금증을 풀 수 있었습니다. Deployment를 사용하여 pod을 배포 하게되면 롤아웃을 생성합니다. 그리고 이 롤아웃은 새로운 배포 버전(revision)을 생성합니다. 이말이 잘 이해가 안 되실수도 있는데 자세한 설명은 실습을 진행하면서 하도록 하겠습니다. 아래와같이 deployment definition을 작성한 yaml파일이 있습니다. #depl.yaml apiVersion: apps/v1 kind: Deployment metadata: name: myapp-deployment labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx replicas: 3 selector: matchLabels: type: front-end 아래의 명령어를 사용하여 deployment를 생성하게되면 kubectl apply -f depl.yaml myapp-deployment라는 이름을가진 deployment와, myapp-deployment-hash값 을 가진 replicaset, 그리고 deployment를 통해 생성된 replicaset에 의해 생성된 pod을 확인할 수 있습니다. kubectl get all NAME READY STATUS RESTARTS AGE pod/myapp-deployment-7df67f74c5-4nkmq 1/1 Running 0 5m27s pod/myapp-deployment-7df67f74c5-bnl9r 1/1 Running 0 5m27s pod/myapp-deployment-7df67f74c5-jsd9p 1/1 Running 0 5m27s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/kubernetes ClusterIP 10.96.0.1 &amp;lt;none&amp;gt; 443/TCP 5d2h NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/myapp-deployment 3/3 3 3 5m27s NAME DESIRED CURRENT READY AGE replicaset.apps/myapp-deployment-7df67f74c5 3 3 3 5m27s 아직까지는 별 차이가 없지요, deployment가 생겼다는것 외에는 말입니다. 하지만 사실은 이외에도 revision이라는 것을 생성합니다. 이는 해당 deployment를 업데이트 할때마다 생기고, 이전 revision의 정보도 가집니다. 또한, 새로운 버전의 replicaset을 생성하고, 이전버전의 replicaset의 정보를 남겨놓습니다. 만약에 업데이트후에 문제가 생겼을시에 롤백을 가능케 하기 위해서 입니다. 그리고 이러한점이 deployment를 사용해서 pod을 배포했을때랑 replicaset을 사용했을때의 가장 큰 차이점이 아닐까 싶습니다. Rollout 상태확인 deployment를 사용하여 pod을 배포하게되면 rollout을 생성한다고 했었는데 추가로 사용할 수 있는 커맨드도 생깁니다. rollout 이라는 커맨드인데요. rollout 커맨드를 통하여 deployment의 revision및 history를 확인할 수 있습니다 kubectl rollout status deployment 커맨드를 사용하여 다음과 같이 롤아웃 생성의 상태를 확인할 수 있습니다. $ kubectl rollout status deployment/myapp-deployment Waiting for deployment &quot;myapp-deployment&quot; rollout to finish: 0 of 3 updated replicas are available... Waiting for deployment &quot;myapp-deployment&quot; rollout to finish: 1 of 3 updated replicas are available... Waiting for deployment &quot;myapp-deployment&quot; rollout to finish: 2 of 3 updated replicas are available... deployment &quot;myapp-deployment&quot; successfully rolled out Rollout history 확인 또한 kubectl rollout history deployment 커맨드를 사용하면 아래와 같이 리비전 정보를 확인할 수 있는데요 $ kubectl rollout history deploy/myapp-deployment deployment.apps/myapp-deployment REVISION CHANGE-CAUSE 1 &amp;lt;none&amp;gt; 하나의 revision 밖에 보이지않습니다. 그 이유는 depl.yaml을 이용하여 처음으로 배포한 버전이기 때문입니다. Rollout update 해당 deployment를 업데이트하면 어떤일이 생기는지 보도록 하겠습니다. 우선 yaml파일을 수정해줍니다 #depl.yaml apiVersion: apps/v1 kind: Deployment metadata: name: myapp-deployment labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx:1.20-alpine &amp;lt;----- 바뀐부분 replicas: 3 selector: matchLabels: type: front-end 이미지를 바꿀때에는 간단하게 set image를 통해서도 가능하지만 개인적으로 변경상황을 이력으로 남기는게 좋다고 생각하여 해당 방법을 사용합니다. 변경사항을 적용시켜줍니다. $ kubectl apply -f depl.yaml deployment.apps/myapp-deployment configured 그다음 replicaset과 revision을 확인해봅시다 $ kubectl get rs NAME DESIRED CURRENT READY AGE myapp-deployment-79896f8f68 3 3 3 5m14s myapp-deployment-7df67f74c5 0 0 0 5m42s replicaset이 하나더 생겼으며, revision도 하나더 생긴것을 확인할 수 있습니다. $ kubectl rollout history deploy myapp-deployment deployment.apps/myapp-deployment REVISION CHANGE-CAUSE 2 &amp;lt;none&amp;gt; 1 &amp;lt;none&amp;gt; 하지만 change-cause가 None 으로 되있으면 무엇이 바뀌었는지 알 수 가없는데, 아래 커맨드를 이용하면 따로 설정이 가능합니다. kubectl annotate deployment.v1.apps/[deployment name] kubernetes.io/change-cause=&quot;reason of update&quot; 해당커맨드를 사용하여 주석을 달고 다시 확인해봅시다 $ kubectl annotate deployment.v1.apps/myapp-deployment kubernetes.io/change-cause=&quot;image updated to 1.20&quot; deployment.apps/myapp-deployment annotated $ kubectl rollout history deployment myapp-deployment deployment.apps/myapp-deployment REVISION CHANGE-CAUSE 1 &amp;lt;none&amp;gt; 2 image updated to 1.20 주석이 잘 달린것을 확인할 수 있습니다. Rollback 만약에 새로운 버전으로 업데이트를 했는데 문제가 생겼을때 이전 버전 으로 돌아갈 수 있는 기능입니다. kubeclt rollout undo deployment 커맨드를 사용하여 롤백 시킬 수 있습니다. 직접 실습해봅시다. $ kubectl rollout undo deployment myapp-deployment deployment.apps/myapp-deployment rolled back 성공적으로 롤백 되었다고 뜹니다. 우선 image가 다시 원래대로 돌아왔는지 확인해봅니다 $ kubectl describe deployment myapp-deployment Name: myapp-deployment Namespace: default CreationTimestamp: Wed, 02 Jun 2021 07:05:06 +0000 Labels: app=myapp type=front-end Annotations: deployment.kubernetes.io/revision: 3 kubernetes.io/change-cause: Selector: type=front-end Replicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailable StrategyType: RollingUpdate MinReadySeconds: 0 RollingUpdateStrategy: 25% max unavailable, 25% max surge Pod Template: Labels: app=myapp type=front-end Containers: nginx-container: Image: nginx &amp;lt;------- 1.20 에서 다시 원래대로 돌아온것을 확인할 수 있습니다. Port: &amp;lt;none&amp;gt; Host Port: &amp;lt;none&amp;gt; Environment: &amp;lt;none&amp;gt; Mounts: &amp;lt;none&amp;gt; Volumes: &amp;lt;none&amp;gt; Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailable OldReplicaSets: &amp;lt;none&amp;gt; NewReplicaSet: myapp-deployment-7df67f74c5 (3/3 replicas created) Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 23m deployment-controller Scaled up replica set myapp-deployment-79896f8f68 to 1 Normal ScalingReplicaSet 23m deployment-controller Scaled down replica set myapp-deployment-7df67f74c5 to 2 Normal ScalingReplicaSet 23m deployment-controller Scaled up replica set myapp-deployment-79896f8f68 to 2 Normal ScalingReplicaSet 23m deployment-controller Scaled down replica set myapp-deployment-7df67f74c5 to 1 Normal ScalingReplicaSet 23m deployment-controller Scaled up replica set myapp-deployment-79896f8f68 to 3 Normal ScalingReplicaSet 23m deployment-controller Scaled down replica set myapp-deployment-7df67f74c5 to 0 Normal ScalingReplicaSet 4m28s deployment-controller Scaled up replica set myapp-deployment-7df67f74c5 to 1 Normal ScalingReplicaSet 4m24s deployment-controller Scaled down replica set myapp-deployment-79896f8f68 to 2 Normal ScalingReplicaSet 4m24s deployment-controller Scaled up replica set myapp-deployment-7df67f74c5 to 2 Normal ScalingReplicaSet 4m20s (x2 over 24m) deployment-controller Scaled up replica set myapp-deployment-7df67f74c5 to 3 Normal ScalingReplicaSet 4m20s deployment-controller Scaled down replica set myapp-deployment-79896f8f68 to 1 Normal ScalingReplicaSet 4m16s deployment-controller Scaled down replica set myapp-deployment-79896f8f68 to 0 그럼 replicaset과 revision은 어떨까요? #이미지 1.20으로 업데이트후 replicaset 상태 $ kubectl get rs NAME DESIRED CURRENT READY AGE myapp-deployment-79896f8f68 3 3 3 5m14s myapp-deployment-7df67f74c5 0 0 0 5m42s #롤백후 replicaset상태 $ kubectl get rs NAME DESIRED CURRENT READY AGE myapp-deployment-79896f8f68 0 0 0 25m myapp-deployment-7df67f74c5 3 3 3 26m revision $ kubectl rollout history deployment myapp-deployment deployment.apps/myapp-deployment REVISION CHANGE-CAUSE 2 image updated to 1.20 3 &amp;lt;none&amp;gt; replicaset은 이전 버전의 replicaset으로 바뀐것을 확인할 수가 있는데 revision은 1로돌아가는것이아닌 1이 증가한 것을 확인할 수 있습니다. 여기서 궁금한점이 생겼습니다. undo를 여러번하면 어떻게될까요? $ kubectl rollout history deployment myapp-deployment deployment.apps/myapp-deployment REVISION CHANGE-CAUSE 3 &amp;lt;none&amp;gt; 4 image updated to 1.20 결과 $ kubectl describe deployment myapp-deployment Name: myapp-deployment Namespace: default CreationTimestamp: Wed, 02 Jun 2021 07:05:06 +0000 Labels: app=myapp type=front-end Annotations: deployment.kubernetes.io/revision: 4 kubernetes.io/change-cause: image updated to 1.20 Selector: type=front-end Replicas: 3 desired | 3 updated | 3 total | 3 available | 0 unavailable StrategyType: RollingUpdate MinReadySeconds: 0 RollingUpdateStrategy: 25% max unavailable, 25% max surge Pod Template: Labels: app=myapp type=front-end Containers: nginx-container: Image: nginx:1.20 Port: &amp;lt;none&amp;gt; Host Port: &amp;lt;none&amp;gt; Environment: &amp;lt;none&amp;gt; Mounts: &amp;lt;none&amp;gt; Volumes: &amp;lt;none&amp;gt; Conditions: Type Status Reason ---- ------ ------ Available True MinimumReplicasAvailable Progressing True NewReplicaSetAvailable OldReplicaSets: &amp;lt;none&amp;gt; NewReplicaSet: myapp-deployment-79896f8f68 (3/3 replicas created) Events: Type Reason Age From Message ---- ------ ---- ---- ------- Normal ScalingReplicaSet 14m deployment-controller Scaled up replica set myapp-deployment-7df67f74c5 to 1 Normal ScalingReplicaSet 14m deployment-controller Scaled down replica set myapp-deployment-79896f8f68 to 2 Normal ScalingReplicaSet 14m deployment-controller Scaled up replica set myapp-deployment-7df67f74c5 to 2 Normal ScalingReplicaSet 14m (x2 over 33m) deployment-controller Scaled up replica set myapp-deployment-7df67f74c5 to 3 Normal ScalingReplicaSet 14m deployment-controller Scaled down replica set myapp-deployment-79896f8f68 to 1 Normal ScalingReplicaSet 13m deployment-controller Scaled down replica set myapp-deployment-79896f8f68 to 0 Normal ScalingReplicaSet 2m13s (x2 over 33m) deployment-controller Scaled up replica set myapp-deployment-79896f8f68 to 1 Normal ScalingReplicaSet 2m9s (x2 over 33m) deployment-controller Scaled down replica set myapp-deployment-7df67f74c5 to 2 Normal ScalingReplicaSet 2m9s (x2 over 33m) deployment-controller Scaled up replica set myapp-deployment-79896f8f68 to 2 Normal ScalingReplicaSet 2m5s (x2 over 33m) deployment-controller Scaled down replica set myapp-deployment-7df67f74c5 to 1 Normal ScalingReplicaSet 2m5s (x2 over 33m) deployment-controller Scaled up replica set myapp-deployment-79896f8f68 to 3 Normal ScalingReplicaSet 2m1s (x2 over 33m) deployment-controller Scaled down replica set myapp-deployment-7df67f74c5 to 0 undo 를 여러번하니 nginx &amp;lt;-&amp;gt; nginx:1.20 왔다 갔다 하는 모습을 보여줍니다. :rocket: history history를 보아도 두줄의 결과만 보여주기도했고, 정말 바로 이전단계까지만 이동할 수 있는건지도 궁금했습니다. 궁금한건 못참기에 바로 kubernetes.io를 찾다보니 원하는 revision으로 가려면 –to-revision=[resion-number] 를 입력해야되는것을 알 수 있었습니다. deployment 의 spec 밑에 revisionHistoryLimit: 10 으로 설정되어 있는것도 확인했으며 이 또한 수정할 수 있었군요 ㅎㅎ 바로 이전 단계만 이동 가능하다고 포스트 올렸다가 호다닥 수정하네요 그나저나 history에는 왜 사람 햇갈리게 두줄만을 보여줬던 걸까요? kubernetes는 상당히 똑똑했기 때문입니다. 이미 기억하고있는 replicaset랑 다름이 없기에 새로운 replicaset을 생성하지 않는것이었습니다. history에 없는 다른 버전의 nginx의 이미지로 바꾸어주니 replicaset과 history 각각 하나씩 더 생기는것을 확인할 수 있었습니다. $ kubectl get rs NAME DESIRED CURRENT READY AGE myapp-deployment-54d59f8648 3 3 3 17m myapp-deployment-79896f8f68 0 0 0 117m myapp-deployment-7df67f74c5 0 0 0 118m $ kubectl rollout history deploy myapp-deployment deployment.apps/myapp-deployment REVISION CHANGE-CAUSE 3 image updated to 1.20 4 &amp;lt;none&amp;gt; 5 &amp;lt;none&amp;gt;</summary></entry><entry><title type="html">ssh config 설정으로 간편하게 ssh접속하기</title><link href="https://shjeong92.github.io/2021/06/01/Handling-ssh-config.html" rel="alternate" type="text/html" title="ssh config 설정으로 간편하게 ssh접속하기" /><published>2021-06-01T00:00:00+09:00</published><updated>2021-06-01T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/01/Handling-ssh-config</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/01/Handling-ssh-config.html">&lt;p&gt;최근 몇일간 kubernetes를 공부하면서 구글 클라우드에 ssh접속을 하는일이 잦았는데요, 접속 할 때마다 구글 클라우드에 접속해서 인스턴스의 외부 IP를 확인 하여야하고 긴 ssh 접속문을 쓰는게 귀찮았는데 알고보니 이를 간편하게 해주는 설정이 있더군요.&lt;/p&gt;

&lt;p&gt;이 글에선 맥에서 GCP에 접속하기 위한 &lt;code&gt;RSA key pair&lt;/code&gt;를 생성하는 부분부터 &lt;code&gt;ssh config&lt;/code&gt; 설정하는법을 다루겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;key-pair-생성하기&quot;&gt;key pair 생성하기&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#-t 암호화타입 -f key pair 저장할 위치 -C 주석(보통 사용자 로그인ID를 적음)
$ssh-keygen -t rsa -f ~/.ssh/&amp;lt;KEY_FILE_NAME&amp;gt; -C &quot;account@gmail.com&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와같이 입력하면 RSA key pair가 생성됩니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh-keygen &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; rsa &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; ~/.ssh/test &lt;span class=&quot;nt&quot;&gt;-C&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;test@gmail.com&quot;&lt;/span&gt;
Generating public/private rsa key pair.
Enter passphrase &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;empty &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;no passphrase&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: 
Enter same passphrase again: 
Your identification has been saved &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /Users/sanghyukjeong/.ssh/test.
Your public key has been saved &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /Users/sanghyukjeong/.ssh/test.pub.
The key fingerprint is:
SHA256:6TjvkM1IFHeI5ywCVgt8DFJpqiK+K4SZO4eTuBcEHkQ &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;@gmail.com
The key&lt;span class=&quot;s1&quot;&gt;&apos;s randomart image is:
+---[RSA 3072]----+
|+E+=. .....      |
|.o*.o..oo.       |
|.=.o. .+         |
|... ... o.       |
|o+   ...S        |
|B..  . B         |
|*+ .  * +        |
|O.o    +         |
|oOo    .o        |
+----[SHA256]-----+
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이후 cat명령어로 rsa 공개키를 확인할 수 있는데
구글 클라우드 인스턴스에 이 키를 등록하기위해 복사 해놓습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cat&lt;/span&gt; ~/.ssh/test.pub
ssh-rsa AAAB3NzaC1yc2EAAAADAQABAAABgQDIlHiLTIM6oCQtjILfmIaTZv6j37J0kZNNjIgK0dFOxSYnMgXirh8gbRqFQY7kMWXZwAo82akxyTAP65GcjsqR+L1RarkKlYA7/lj7rvAf2VMJXy0X6yCbGo3yHcPGEoWLlsOgeYZDAk3Wld/hGdBWKXX4404iUQygjWbIircQ6BNZBb14nbhJK+pLWXMB7TmaRvtDsumBAko0shkA5g6y1oNGdpGBsUTQHk+rqQhqZElP9hgXp71qGhTO0V11kH41n0beReBoi9YngrpJtu6b4h1Ttm4N7CpCU5rUW38i5s71aInLuPolCDXlA8b6qVtBqg6dQ6/IgNQgQFRpwIkcf4v0EHKygcdm+QM25x3VAx1XC51gqHxhdU71/24EiUw0EW3cIvER6150aZF3PiAe5odstk9vx4L/1Vtu1GySQ2Qz8LcK1J3lawh3i8yaobVPUOIOxGDhme+tRMuyy16PhumtxSI5SeSwoIhYEIZtHKHFHKztNGV6m5aNSLZwzbk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;@gmail.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;key-등록하기&quot;&gt;key 등록하기&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/120263396-9136a700-c2d6-11eb-8c97-65769591c66c.png&quot; alt=&quot;gcp&quot; /&gt;&lt;/p&gt;

&lt;p&gt;compute엔진 -&amp;gt; 메타데이터 -&amp;gt; SSH 키로 이동후에&lt;/p&gt;

&lt;p&gt;항목추가를 클릭하여 공개키를 추가합니다.&lt;/p&gt;

&lt;p&gt;키등록이 끝났으니 ssh 접속을 해봅시다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; ~/.ssh/test yourID@your.gcloudExternal.ip

Welcome to Ubuntu 18.04.5 LTS &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;GNU/Linux 5.4.0-1043-gcp x86_64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Documentation:  https://help.ubuntu.com
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Management:     https://landscape.canonical.com
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Support:        https://ubuntu.com/advantage

  System information as of Tue Jun  1 03:44:22 UTC 2021

  System load:  0.27               Users logged &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;:        0
  Usage of /:   14.2% of 28.90GB   IP address &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;ens4:    10.178.0.2
  Memory usage: 44%                IP address &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;docker0: 172.17.0.1
  Swap usage:   0%                 IP address &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;cni0:    10.244.0.1
  Processes:    143

 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Super-optimized &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;small spaces - &lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;how we shrank the memory
   footprint of MicroK8s to make it the smallest full K8s around.

   https://ubuntu.com/blog/microk8s-memory-optimisation
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 접속 되는것을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;그러나 접속할때마다 저 커맨드를 다 입력하는것은 참 귀찮은일입니다. ip정도는 한번보면 외우시는분이 아니라면요 ㅎㅎ&lt;/p&gt;

&lt;p&gt;이제 ssh config파일 설정에대해 알아봅시다&lt;/p&gt;

&lt;h2 id=&quot;ssh-config-설정하여-ssh-접속-간편하게-하기&quot;&gt;ssh config 설정하여 ssh 접속 간편하게 하기&lt;/h2&gt;

&lt;p&gt;Linux/Unix서버 접속 계정들을 여러 가지 관리하는 경우, 별도로 메모나 파일에 접속 계정 / 비밀번호 등을 관리하거나 alias에 접속 명령어를 설정하는 번거로움이 있습니다.&lt;/p&gt;

&lt;p&gt;하지만 .ssh 경로 밑 config 파일에 계정 정보들을 저장하여 관리하면 정말 편리하게 접속들을 관리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;우선 사용자 홈 디렉토리에서 .ssh 폴더로 접근합니다. .ssh 폴더는 ssh 접속을 한 번이라도 했다면, rsa 파일이나 known_hosts 등이 생성되기 때문에 자동으로 생성되는 디렉토리입니다.&lt;/p&gt;

&lt;p&gt;홈디렉토리에 있는 .ssh폴더에 들어가서 config 파일을 생성해줍니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/.ssh

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host gcloud
        HostName 10.178.0.3
        User shjeong920522
        IdentityFile: ~/.ssh/test
        Port 22
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Host: 접속할 정보의 이름입니다.&lt;/li&gt;
  &lt;li&gt;HostName: 접속할 서버의 외부 IP 주소를 입력하세요&lt;/li&gt;
  &lt;li&gt;User: 접속할 서버의 user 정보입니다.&lt;/li&gt;
  &lt;li&gt;IdentityFile: 인증 키파일이 필요한 경우, 키파일 경로를 설정합니다. 이전 단계에 rsa 키페어 만든거 기억나시죠?&lt;/li&gt;
  &lt;li&gt;Port: ssh 접속 포트입니다. 생략 가능하며, 생략할 경우에 디폴트로 22번 포트로 실생됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모든 설정이 끝났으니 google cloud에 접속해보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# config 에서 Host에 등록한 접속할 정보만 적어주면 접속이되는 마법....&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh gcloud
Welcome to Ubuntu 18.04.5 LTS &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;GNU/Linux 5.4.0-1043-gcp x86_64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Documentation:  https://help.ubuntu.com
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Management:     https://landscape.canonical.com
 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Support:        https://ubuntu.com/advantage

  System information as of Tue Jun  1 04:05:52 UTC 2021

  System load:  0.65               Users logged &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;:        0
  Usage of /:   14.2% of 28.90GB   IP address &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;ens4:    12.178.0.2
  Memory usage: 44%                IP address &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;docker0: 172.17.0.1
  Swap usage:   0%                 IP address &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;cni0:    12.244.0.1
  Processes:    144

 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; Super-optimized &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;small spaces - &lt;span class=&quot;nb&quot;&gt;read &lt;/span&gt;how we shrank the memory
   footprint of MicroK8s to make it the smallest full K8s around.

   https://ubuntu.com/blog/microk8s-memory-optimisation

11 updates can be applied immediately.
To see these additional updates run: apt list &lt;span class=&quot;nt&quot;&gt;--upgradable&lt;/span&gt;

New release &lt;span class=&quot;s1&quot;&gt;&apos;20.04.2 LTS&apos;&lt;/span&gt; available.
Run &lt;span class=&quot;s1&quot;&gt;&apos;do-release-upgrade&apos;&lt;/span&gt; to upgrade to it.


Last login: Tue Jun  1 03:44:23 2021 from 122.32.103.55
shjeong920522@master:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 한번 설정해 놓으면 외부 ip포트 확인하러 gcloud 콘솔에 접속하지 않아도되고, 정말 간편하게 ssh 접속을 할 수 있습니다.&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="gcloud" /><category term="ssh" /><category term="key-gen" /><category term="rsa" /><category term="config" /><summary type="html">최근 몇일간 kubernetes를 공부하면서 구글 클라우드에 ssh접속을 하는일이 잦았는데요, 접속 할 때마다 구글 클라우드에 접속해서 인스턴스의 외부 IP를 확인 하여야하고 긴 ssh 접속문을 쓰는게 귀찮았는데 알고보니 이를 간편하게 해주는 설정이 있더군요. 이 글에선 맥에서 GCP에 접속하기 위한 RSA key pair를 생성하는 부분부터 ssh config 설정하는법을 다루겠습니다. key pair 생성하기 #-t 암호화타입 -f key pair 저장할 위치 -C 주석(보통 사용자 로그인ID를 적음) $ssh-keygen -t rsa -f ~/.ssh/&amp;lt;KEY_FILE_NAME&amp;gt; -C &quot;account@gmail.com&quot; 위와같이 입력하면 RSA key pair가 생성됩니다. ssh-keygen -t rsa -f ~/.ssh/test -C &quot;test@gmail.com&quot; Generating public/private rsa key pair. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/sanghyukjeong/.ssh/test. Your public key has been saved in /Users/sanghyukjeong/.ssh/test.pub. The key fingerprint is: SHA256:6TjvkM1IFHeI5ywCVgt8DFJpqiK+K4SZO4eTuBcEHkQ test@gmail.com The key&apos;s randomart image is: +---[RSA 3072]----+ |+E+=. ..... | |.o*.o..oo. | |.=.o. .+ | |... ... o. | |o+ ...S | |B.. . B | |*+ . * + | |O.o + | |oOo .o | +----[SHA256]-----+ 이후 cat명령어로 rsa 공개키를 확인할 수 있는데 구글 클라우드 인스턴스에 이 키를 등록하기위해 복사 해놓습니다. $ cat ~/.ssh/test.pub ssh-rsa AAAB3NzaC1yc2EAAAADAQABAAABgQDIlHiLTIM6oCQtjILfmIaTZv6j37J0kZNNjIgK0dFOxSYnMgXirh8gbRqFQY7kMWXZwAo82akxyTAP65GcjsqR+L1RarkKlYA7/lj7rvAf2VMJXy0X6yCbGo3yHcPGEoWLlsOgeYZDAk3Wld/hGdBWKXX4404iUQygjWbIircQ6BNZBb14nbhJK+pLWXMB7TmaRvtDsumBAko0shkA5g6y1oNGdpGBsUTQHk+rqQhqZElP9hgXp71qGhTO0V11kH41n0beReBoi9YngrpJtu6b4h1Ttm4N7CpCU5rUW38i5s71aInLuPolCDXlA8b6qVtBqg6dQ6/IgNQgQFRpwIkcf4v0EHKygcdm+QM25x3VAx1XC51gqHxhdU71/24EiUw0EW3cIvER6150aZF3PiAe5odstk9vx4L/1Vtu1GySQ2Qz8LcK1J3lawh3i8yaobVPUOIOxGDhme+tRMuyy16PhumtxSI5SeSwoIhYEIZtHKHFHKztNGV6m5aNSLZwzbk= test@gmail.com key 등록하기 compute엔진 -&amp;gt; 메타데이터 -&amp;gt; SSH 키로 이동후에 항목추가를 클릭하여 공개키를 추가합니다. 키등록이 끝났으니 ssh 접속을 해봅시다 $ ssh -i ~/.ssh/test yourID@your.gcloudExternal.ip Welcome to Ubuntu 18.04.5 LTS (GNU/Linux 5.4.0-1043-gcp x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Tue Jun 1 03:44:22 UTC 2021 System load: 0.27 Users logged in: 0 Usage of /: 14.2% of 28.90GB IP address for ens4: 10.178.0.2 Memory usage: 44% IP address for docker0: 172.17.0.1 Swap usage: 0% IP address for cni0: 10.244.0.1 Processes: 143 * Super-optimized for small spaces - read how we shrank the memory footprint of MicroK8s to make it the smallest full K8s around. https://ubuntu.com/blog/microk8s-memory-optimisation 잘 접속 되는것을 확인할 수 있습니다. 그러나 접속할때마다 저 커맨드를 다 입력하는것은 참 귀찮은일입니다. ip정도는 한번보면 외우시는분이 아니라면요 ㅎㅎ 이제 ssh config파일 설정에대해 알아봅시다 ssh config 설정하여 ssh 접속 간편하게 하기 Linux/Unix서버 접속 계정들을 여러 가지 관리하는 경우, 별도로 메모나 파일에 접속 계정 / 비밀번호 등을 관리하거나 alias에 접속 명령어를 설정하는 번거로움이 있습니다. 하지만 .ssh 경로 밑 config 파일에 계정 정보들을 저장하여 관리하면 정말 편리하게 접속들을 관리할 수 있습니다. 우선 사용자 홈 디렉토리에서 .ssh 폴더로 접근합니다. .ssh 폴더는 ssh 접속을 한 번이라도 했다면, rsa 파일이나 known_hosts 등이 생성되기 때문에 자동으로 생성되는 디렉토리입니다. 홈디렉토리에 있는 .ssh폴더에 들어가서 config 파일을 생성해줍니다. $ cd ~/.ssh $ vim config Host gcloud HostName 10.178.0.3 User shjeong920522 IdentityFile: ~/.ssh/test Port 22 Host: 접속할 정보의 이름입니다. HostName: 접속할 서버의 외부 IP 주소를 입력하세요 User: 접속할 서버의 user 정보입니다. IdentityFile: 인증 키파일이 필요한 경우, 키파일 경로를 설정합니다. 이전 단계에 rsa 키페어 만든거 기억나시죠? Port: ssh 접속 포트입니다. 생략 가능하며, 생략할 경우에 디폴트로 22번 포트로 실생됩니다. 모든 설정이 끝났으니 google cloud에 접속해보겠습니다. # config 에서 Host에 등록한 접속할 정보만 적어주면 접속이되는 마법.... $ ssh gcloud Welcome to Ubuntu 18.04.5 LTS (GNU/Linux 5.4.0-1043-gcp x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage System information as of Tue Jun 1 04:05:52 UTC 2021 System load: 0.65 Users logged in: 0 Usage of /: 14.2% of 28.90GB IP address for ens4: 12.178.0.2 Memory usage: 44% IP address for docker0: 172.17.0.1 Swap usage: 0% IP address for cni0: 12.244.0.1 Processes: 144 * Super-optimized for small spaces - read how we shrank the memory footprint of MicroK8s to make it the smallest full K8s around. https://ubuntu.com/blog/microk8s-memory-optimisation 11 updates can be applied immediately. To see these additional updates run: apt list --upgradable New release &apos;20.04.2 LTS&apos; available. Run &apos;do-release-upgrade&apos; to upgrade to it. Last login: Tue Jun 1 03:44:23 2021 from 122.32.103.55 shjeong920522@master:~$ 이렇게 한번 설정해 놓으면 외부 ip포트 확인하러 gcloud 콘솔에 접속하지 않아도되고, 정말 간편하게 ssh 접속을 할 수 있습니다.</summary></entry><entry><title type="html">[ #5 ] pod 스케쥴링-2</title><link href="https://shjeong92.github.io/2021/05/31/Learning-Kubernetes-05.html" rel="alternate" type="text/html" title="[ #5 ] pod 스케쥴링-2" /><published>2021-05-31T00:00:00+09:00</published><updated>2021-05-31T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/05/31/Learning-Kubernetes-05</id><content type="html" xml:base="https://shjeong92.github.io/2021/05/31/Learning-Kubernetes-05.html">&lt;h2 id=&quot;nodeselector&quot;&gt;nodeSelector&lt;/h2&gt;
&lt;p&gt;nodeSelector 는 파드를 특정 레이블이 있는 노드로 제한하는 매우 간단한 방법을 제공합니다.&lt;/p&gt;
&lt;h3 id=&quot;1-노드에-레이블-붙이기&quot;&gt;1. 노드에 레이블 붙이기&lt;/h3&gt;

&lt;p&gt;노드에 레이블을 붙여서 추후 pod을 원하는 노드에 할당할때 사용할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl label nodes &amp;lt;노드 이름&amp;gt; &amp;lt;레이블 키&amp;gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&amp;lt;레이블 값&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-pod설정에-nodeselector-필드-추가하기&quot;&gt;2. pod설정에 nodeSelector 필드 추가하기&lt;/h3&gt;
&lt;p&gt;실행하고자 하는 파드의 설정 파일을 가져오고, 이처럼 nodeSelector 섹션을 추가합니다. 아래의 예를 들어보면&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;spec아래에 nodeSelector을 추가해줍니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;IfNotPresent&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;nodeSelector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;#&amp;lt;레이블 키&amp;gt;: &amp;lt;레이블 값&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;disktype&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ssd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;node-affinity&quot;&gt;node affinity&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;nodeSelector&lt;/strong&gt; 을 사용했을때는 매칭 조건이 레이블에 key=value, key와 value가 일치했을때 pod을 노드에 있었습니다.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nodeAffinity&lt;/strong&gt; 는 operator로 Equal, In, NotIn, Exists, DoseNotExist 를 사용할 수 있어, 더 여러가지 제약을 정의 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 &lt;strong&gt;nodeAffinity&lt;/strong&gt; 에는 아래와 같이 두가지 타입이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
  &lt;li&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;첫번째 타입은 파드가 노드에 스케줄되려면 규칙을 만족해야만 하는것이고, 없다면 pod는 pending 상태가 됩니다
두번째 타입은 선호하는 선호하는 또다른 키와 벨류, 연산자를 추가할 수 있는데요, 첫번째 조건을 만족하는 노드가 여러개 있을경우에, 두번째 조건의 weight(선호도) 점수에따라
pod이 스케쥴되는 형태입니다.&lt;/p&gt;

&lt;p&gt;미래에는 requiredDuringSchedulingRequiredDuringExecution 라는 새로운 타입이 나올것이라고 합니다, 앞서 소개드린 두 타입은 이미 pod이 스케줄 되었을때 node의 label이 바뀌거나 없어지면서
affinity의 조건과 맞지 않더라도 이미 배정되었음으로 무시합니다. 하지만 미래에 나올 새로운 타입은 이미 배정받은 pod이라도 노드의 label이 삭제,변경되면 조건에 맞지 않는 pod을 중지 시키는 타입 이라고합니다.&lt;/p&gt;

&lt;h3 id=&quot;예제&quot;&gt;예제&lt;/h3&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;with-node-affinity&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;affinity&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;nodeAffinity&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;nodeSelectorTerms&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;matchExpressions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kubernetes.io/e2e-az-name&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;In&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;e2e-az1&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;e2e-az2&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;preference&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;na&quot;&gt;matchExpressions&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
          &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;another-node-label-key&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;In&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;another-node-label-value&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;with-node-affinity&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;k8s.gcr.io/pause:2.0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Node affinity는 여러 affinity를 동시에 적용할 수 있는데요 저는 아래와 같은 경우에 대해 실험해 보았습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;requiredDuringSchedulingIgnoredDuringExecution 만 적용했을 경우&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;조건을 만족하는 노드가 없을경우 pod는 스케쥴되지않고 pending상태가 됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;requiredDuringSchedulingIgnoredDuringExecution 과 preferredDuringSchedulingIgnoredDuringExecution 를 동시에 적용할경우&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;첫번째 조건을 을 만족하는 노드가 여러개 있을때 두번째 조건을 만족하는 노드가 있다면 두번째 조건을 만족하는 노드에 pod가 배치됩니다.&lt;/li&gt;
      &lt;li&gt;두번째 조건만을 만족하는 경우에는 pod는 스케쥴링되지 않고 pending 상태가 됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;preferredDuringSchedulingIgnoredDuringExecution 만 적용할 경우&lt;/strong&gt;:
    &lt;ul&gt;
      &lt;li&gt;조건을 만족하는 노드가 있을경우 해당 노드에 스케쥴링되고, 조건을 만족하는 노드가 없다면 랜덤으로 스케쥴 되었습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위의 예제에서는 두 개의 Affinity가 정의되어 있는데요 만약 노드들중 &lt;strong&gt;requiredDuringSchedulingIgnoredDuringExecution&lt;/strong&gt; 을 만족하는 노드가 없다면 해당 pod은 pending 상태가
될것이며, 해당 조건을 만족하는 노드가 여러개일 경우 &lt;strong&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/strong&gt; 조건이 맞는 노드로 배정 될 것입니다. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;weight&lt;/code&gt; 는 선호도입니다 만약 여러개의 &lt;strong&gt;preferredDuringSchedulingIgnoredDuringExecution&lt;/strong&gt; 을 적용하였을때에는 weight이 높은 노드에 스케쥴됩니다.&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Docker" /><category term="Kubernetes" /><category term="Replicasets" /><category term="Deployment" /><category term="Google" /><category term="cloud" /><summary type="html">nodeSelector nodeSelector 는 파드를 특정 레이블이 있는 노드로 제한하는 매우 간단한 방법을 제공합니다. 1. 노드에 레이블 붙이기 노드에 레이블을 붙여서 추후 pod을 원하는 노드에 할당할때 사용할 수 있습니다. kubectl label nodes &amp;lt;노드 이름&amp;gt; &amp;lt;레이블 키&amp;gt;=&amp;lt;레이블 값&amp;gt; 2. pod설정에 nodeSelector 필드 추가하기 실행하고자 하는 파드의 설정 파일을 가져오고, 이처럼 nodeSelector 섹션을 추가합니다. 아래의 예를 들어보면 apiVersion: v1 kind: Pod metadata: name: nginx labels: env: test spec: containers: - name: nginx image: nginx spec아래에 nodeSelector을 추가해줍니다. apiVersion: v1 kind: Pod metadata: name: nginx labels: env: test spec: containers: - name: nginx image: nginx imagePullPolicy: IfNotPresent nodeSelector: #&amp;lt;레이블 키&amp;gt;: &amp;lt;레이블 값&amp;gt; disktype: ssd node affinity nodeSelector 을 사용했을때는 매칭 조건이 레이블에 key=value, key와 value가 일치했을때 pod을 노드에 있었습니다. nodeAffinity 는 operator로 Equal, In, NotIn, Exists, DoseNotExist 를 사용할 수 있어, 더 여러가지 제약을 정의 할 수 있습니다. 또한 nodeAffinity 에는 아래와 같이 두가지 타입이 있습니다. requiredDuringSchedulingIgnoredDuringExecution preferredDuringSchedulingIgnoredDuringExecution 첫번째 타입은 파드가 노드에 스케줄되려면 규칙을 만족해야만 하는것이고, 없다면 pod는 pending 상태가 됩니다 두번째 타입은 선호하는 선호하는 또다른 키와 벨류, 연산자를 추가할 수 있는데요, 첫번째 조건을 만족하는 노드가 여러개 있을경우에, 두번째 조건의 weight(선호도) 점수에따라 pod이 스케쥴되는 형태입니다. 미래에는 requiredDuringSchedulingRequiredDuringExecution 라는 새로운 타입이 나올것이라고 합니다, 앞서 소개드린 두 타입은 이미 pod이 스케줄 되었을때 node의 label이 바뀌거나 없어지면서 affinity의 조건과 맞지 않더라도 이미 배정되었음으로 무시합니다. 하지만 미래에 나올 새로운 타입은 이미 배정받은 pod이라도 노드의 label이 삭제,변경되면 조건에 맞지 않는 pod을 중지 시키는 타입 이라고합니다. 예제 apiVersion: v1 kind: Pod metadata: name: with-node-affinity spec: affinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/e2e-az-name operator: In values: - e2e-az1 - e2e-az2 preferredDuringSchedulingIgnoredDuringExecution: - weight: 1 preference: matchExpressions: - key: another-node-label-key operator: In values: - another-node-label-value containers: - name: with-node-affinity image: k8s.gcr.io/pause:2.0 Node affinity는 여러 affinity를 동시에 적용할 수 있는데요 저는 아래와 같은 경우에 대해 실험해 보았습니다. requiredDuringSchedulingIgnoredDuringExecution 만 적용했을 경우: 조건을 만족하는 노드가 없을경우 pod는 스케쥴되지않고 pending상태가 됩니다. requiredDuringSchedulingIgnoredDuringExecution 과 preferredDuringSchedulingIgnoredDuringExecution 를 동시에 적용할경우: 첫번째 조건을 을 만족하는 노드가 여러개 있을때 두번째 조건을 만족하는 노드가 있다면 두번째 조건을 만족하는 노드에 pod가 배치됩니다. 두번째 조건만을 만족하는 경우에는 pod는 스케쥴링되지 않고 pending 상태가 됩니다. preferredDuringSchedulingIgnoredDuringExecution 만 적용할 경우: 조건을 만족하는 노드가 있을경우 해당 노드에 스케쥴링되고, 조건을 만족하는 노드가 없다면 랜덤으로 스케쥴 되었습니다. 위의 예제에서는 두 개의 Affinity가 정의되어 있는데요 만약 노드들중 requiredDuringSchedulingIgnoredDuringExecution 을 만족하는 노드가 없다면 해당 pod은 pending 상태가 될것이며, 해당 조건을 만족하는 노드가 여러개일 경우 preferredDuringSchedulingIgnoredDuringExecution 조건이 맞는 노드로 배정 될 것입니다. weight 는 선호도입니다 만약 여러개의 preferredDuringSchedulingIgnoredDuringExecution 을 적용하였을때에는 weight이 높은 노드에 스케쥴됩니다.</summary></entry><entry><title type="html">[ #6 ] static pod</title><link href="https://shjeong92.github.io/2021/05/31/Learning-Kubernetes-06.html" rel="alternate" type="text/html" title="[ #6 ] static pod" /><published>2021-05-31T00:00:00+09:00</published><updated>2021-05-31T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/05/31/Learning-Kubernetes-06</id><content type="html" xml:base="https://shjeong92.github.io/2021/05/31/Learning-Kubernetes-06.html">&lt;h2 id=&quot;static-pods이란&quot;&gt;Static pods이란&lt;/h2&gt;

&lt;p&gt;제일 처음에 kubernetes의 구조에서 공부했을때 마스터노드에 &lt;code&gt;kube-apiserver&lt;/code&gt;가 있고, 각 워커노드에는 &lt;code&gt;kubelet&lt;/code&gt; 이 존재하며 마스터노드의 kube-apiserver의 명령에따라 pod을 지우거나 삭제하거나 했었죠. &lt;br /&gt;
이번 시간에는 마스터 노드의 kube-scheduler의 영향을 받지 않는 Static pod 에 대해서 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;각 워커노드에 존재하는 kubelet 또한 pod이 죽거나 에러가 발생했을떄 아래의 방법으로 다시 살릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;우선 static pod을 생성할 노드를 선택하여 ssh 접속해줍니다. 저는 worker-1에 접속하도록 하겠습니다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get nodes &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; wide
NAME         STATUS   ROLES                  AGE    VERSION
instance-1   Ready    &amp;lt;none&amp;gt;                 3d3h   v1.21.1
master       Ready    control-plane,master   3d3h   v1.21.1
worker-1     Ready    &amp;lt;none&amp;gt;                 3d3h   v1.21.1
worker-2     Ready    &amp;lt;none&amp;gt;                 3d3h   v1.21.1

&lt;span class=&quot;c&quot;&gt;#worker 에 접속하기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; ~/.ssh/rsa-gcp-worker-1 shjeong920522@10.178.0.5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;특징-1&quot;&gt;특징 1&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;kubelet&lt;/strong&gt; 은 기본적으로 /etc/kubernetes/manifests 파일안의 pod.yaml 을 바라보는데, 이는 kubelet.service 의 config.yaml파일안에 staticPodPath에 정의되어있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;직접 확인해봅시다&lt;/p&gt;

&lt;p&gt;우선 아래 커맨드를 입력하여 config.yaml파일의 위치를 알아냅니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 모든서비스 확장 | kubelet 정보중에서 | --config 포함하는줄 가져오기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ps &lt;span class=&quot;nt&quot;&gt;-ef&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;kubelet | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\-&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;-config&quot;&lt;/span&gt;
root     18270     1  1 May28 ?        01:31:14 /usr/bin/kubelet &lt;span class=&quot;nt&quot;&gt;--bootstrap-kubeconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/bootstrap-kubelet.conf &lt;span class=&quot;nt&quot;&gt;--kubeconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/kubelet.conf &lt;span class=&quot;nt&quot;&gt;--config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/kubelet/config.yaml &lt;span class=&quot;nt&quot;&gt;--network-plugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cni &lt;span class=&quot;nt&quot;&gt;--pod-infra-container-image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;k8s.gcr.io/pause:3.4.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;해당 파일을 확인해 봅시다&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;$ sudo vi config=/var/lib/kubelet/config.yaml&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kubelet.config.k8s.io/v1beta1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;authentication&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;anonymous&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;false&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;webhook&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;cacheTTL&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;enabled&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;x509&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;clientCAFile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/etc/kubernetes/pki/ca.crt&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;authorization&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Webhook&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;webhook&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;cacheAuthorizedTTL&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;cacheUnauthorizedTTL&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;cgroupDriver&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;systemd&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;clusterDNS&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;10.96.0.10&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;clusterDomain&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;cluster.local&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;cpuManagerReconcilePeriod&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;evictionPressureTransitionPeriod&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;fileCheckFrequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;healthzBindAddress&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;127.0.0.1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;healthzPort&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10248&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;httpCheckFrequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;imageMinimumGCAge&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;KubeletConfiguration&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;logging&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;nodeStatusReportFrequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;nodeStatusUpdateFrequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;resolvConf&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/run/systemd/resolve/resolv.conf&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;rotateCertificates&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;runtimeRequestTimeout&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;shutdownGracePeriod&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;shutdownGracePeriodCriticalPods&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;staticPodPath&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;/etc/kubernetes/manifests        &amp;lt;------------------------------ staticPodPath 가 설정되어 있는것을 확인할 수 있습니다.&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;streamingConnectionIdleTimeout&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;syncFrequency&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;volumeStatsAggPeriod&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;0s&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 파일을 통으로 확인해보아도 되지만 grep명령어를 사용하면 더욱 편히 찾을 수도 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo grep &lt;/span&gt;static /var/lib/kubelet/config.yaml
staticPodPath: /etc/kubernetes/manifests
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;특징-2&quot;&gt;특징 2&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;만약 해동 폴더내에 kind: Pod인 yaml 파일이있다면 kubelet이 자동으로 이를 생성하며 static pod의 이름에는 자동으로 해당 노드의 이름이 suffix로 붙습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;잘 생성되나 확인해 봅시다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /etc/kubernetes/manifests
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vi static.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단한 pod을 해당 볼더에 생성해줍니다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#static.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-pod&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;마스터&lt;/strong&gt; 노드로 이동하여 확인해봅시다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get pods
NAME                 READY   STATUS    RESTARTS   AGE
myapp-pod-worker-1   1/1     Running   0          42m
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;static pod를 생성한 노드의 이름인 worker-1 가 Pod이름의 suffix로 붙어있는것을 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;특징-3&quot;&gt;특징 3&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;마스터노드에서 kubectl delete 명령어를 사용하더라도 워커노드의 kubelet이 다시 살려냅니다. static pod는 해당 워커노드의 kubelet이 관리하기 떄문입니다.
따라서 해당 pod의 image를 변경하고싶다면 manifest 폴더안의 해당 yaml파일의 이미지를 수정해야하고, 지우려면 해당 yaml파일을 삭제하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그럼 정말로 다시 시작되는지 마스터노드에서 &lt;strong&gt;myapp-pod-worker-1&lt;/strong&gt;을 삭제해 봅시다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete pod myapp-pod-worker-1
pod &lt;span class=&quot;s2&quot;&gt;&quot;myapp-pod-worker-1&quot;&lt;/span&gt; deleted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;지운다음에 바로 확인해보면&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get pods
NAME                 READY   STATUS    RESTARTS   AGE
myapp-pod-worker-1   0/1     Pending   0          1s

kubectl get pods
NAME                 READY   STATUS    RESTARTS   AGE
myapp-pod-worker-1   1/1     Running   0   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;pending상태에 있다가 running으로 바뀌는 것을 확인할 수 있습니다.
따라서 static pod을 지우고싶으면 해당 노드로 가서 해당 yaml파일을 삭제하는 방법뿐입니다.&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Docker" /><category term="Kubernetes" /><category term="Replicasets" /><category term="Deployment" /><category term="static" /><category term="pod" /><summary type="html">Static pods이란 제일 처음에 kubernetes의 구조에서 공부했을때 마스터노드에 kube-apiserver가 있고, 각 워커노드에는 kubelet 이 존재하며 마스터노드의 kube-apiserver의 명령에따라 pod을 지우거나 삭제하거나 했었죠. 이번 시간에는 마스터 노드의 kube-scheduler의 영향을 받지 않는 Static pod 에 대해서 알아보겠습니다. 각 워커노드에 존재하는 kubelet 또한 pod이 죽거나 에러가 발생했을떄 아래의 방법으로 다시 살릴 수 있습니다. 우선 static pod을 생성할 노드를 선택하여 ssh 접속해줍니다. 저는 worker-1에 접속하도록 하겠습니다 $ kubectl get nodes -o wide NAME STATUS ROLES AGE VERSION instance-1 Ready &amp;lt;none&amp;gt; 3d3h v1.21.1 master Ready control-plane,master 3d3h v1.21.1 worker-1 Ready &amp;lt;none&amp;gt; 3d3h v1.21.1 worker-2 Ready &amp;lt;none&amp;gt; 3d3h v1.21.1 #worker 에 접속하기 $ ssh -i ~/.ssh/rsa-gcp-worker-1 shjeong920522@10.178.0.5 특징 1 kubelet 은 기본적으로 /etc/kubernetes/manifests 파일안의 pod.yaml 을 바라보는데, 이는 kubelet.service 의 config.yaml파일안에 staticPodPath에 정의되어있습니다. 직접 확인해봅시다 우선 아래 커맨드를 입력하여 config.yaml파일의 위치를 알아냅니다 # 모든서비스 확장 | kubelet 정보중에서 | --config 포함하는줄 가져오기 $ ps -ef | grep kubelet | grep &quot;\--config&quot; root 18270 1 1 May28 ? 01:31:14 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --network-plugin=cni --pod-infra-container-image=k8s.gcr.io/pause:3.4.1 해당 파일을 확인해 봅시다 $ sudo vi config=/var/lib/kubelet/config.yaml apiVersion: kubelet.config.k8s.io/v1beta1 authentication: anonymous: enabled: false webhook: cacheTTL: 0s enabled: true x509: clientCAFile: /etc/kubernetes/pki/ca.crt authorization: mode: Webhook webhook: cacheAuthorizedTTL: 0s cacheUnauthorizedTTL: 0s cgroupDriver: systemd clusterDNS: - 10.96.0.10 clusterDomain: cluster.local cpuManagerReconcilePeriod: 0s evictionPressureTransitionPeriod: 0s fileCheckFrequency: 0s healthzBindAddress: 127.0.0.1 healthzPort: 10248 httpCheckFrequency: 0s imageMinimumGCAge: 0s kind: KubeletConfiguration logging: {} nodeStatusReportFrequency: 0s nodeStatusUpdateFrequency: 0s resolvConf: /run/systemd/resolve/resolv.conf rotateCertificates: true runtimeRequestTimeout: 0s shutdownGracePeriod: 0s shutdownGracePeriodCriticalPods: 0s staticPodPath: /etc/kubernetes/manifests &amp;lt;------------------------------ staticPodPath 가 설정되어 있는것을 확인할 수 있습니다. streamingConnectionIdleTimeout: 0s syncFrequency: 0s volumeStatsAggPeriod: 0s 위와 같이 파일을 통으로 확인해보아도 되지만 grep명령어를 사용하면 더욱 편히 찾을 수도 있습니다. $ sudo grep static /var/lib/kubelet/config.yaml staticPodPath: /etc/kubernetes/manifests 특징 2 만약 해동 폴더내에 kind: Pod인 yaml 파일이있다면 kubelet이 자동으로 이를 생성하며 static pod의 이름에는 자동으로 해당 노드의 이름이 suffix로 붙습니다. 잘 생성되나 확인해 봅시다. $ cd /etc/kubernetes/manifests $ sudo vi static.yaml 간단한 pod을 해당 볼더에 생성해줍니다. #static.yaml apiVersion: v1 kind: Pod metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx 마스터 노드로 이동하여 확인해봅시다. $ kubectl get pods NAME READY STATUS RESTARTS AGE myapp-pod-worker-1 1/1 Running 0 42m static pod를 생성한 노드의 이름인 worker-1 가 Pod이름의 suffix로 붙어있는것을 확인할 수 있습니다. 특징 3 마스터노드에서 kubectl delete 명령어를 사용하더라도 워커노드의 kubelet이 다시 살려냅니다. static pod는 해당 워커노드의 kubelet이 관리하기 떄문입니다. 따라서 해당 pod의 image를 변경하고싶다면 manifest 폴더안의 해당 yaml파일의 이미지를 수정해야하고, 지우려면 해당 yaml파일을 삭제하면 됩니다. 그럼 정말로 다시 시작되는지 마스터노드에서 myapp-pod-worker-1을 삭제해 봅시다 $ kubectl delete pod myapp-pod-worker-1 pod &quot;myapp-pod-worker-1&quot; deleted 지운다음에 바로 확인해보면 $ kubectl get pods NAME READY STATUS RESTARTS AGE myapp-pod-worker-1 0/1 Pending 0 1s kubectl get pods NAME READY STATUS RESTARTS AGE myapp-pod-worker-1 1/1 Running 0 pending상태에 있다가 running으로 바뀌는 것을 확인할 수 있습니다. 따라서 static pod을 지우고싶으면 해당 노드로 가서 해당 yaml파일을 삭제하는 방법뿐입니다.</summary></entry><entry><title type="html">[ #4 ] pod 스케쥴링-1</title><link href="https://shjeong92.github.io/2021/05/30/Learning-Kubernetes-04.html" rel="alternate" type="text/html" title="[ #4 ] pod 스케쥴링-1" /><published>2021-05-30T00:00:00+09:00</published><updated>2021-05-30T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/05/30/Learning-Kubernetes-04</id><content type="html" xml:base="https://shjeong92.github.io/2021/05/30/Learning-Kubernetes-04.html">&lt;h2 id=&quot;taint--toleration&quot;&gt;Taint &amp;amp; Toleration&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;taint: 노드마다 설정가능&lt;/li&gt;
  &lt;li&gt;toleration: taint를 무시할 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주로 노드를 지정된 역할만 하게할때 사용합니다.
예를들어 gpu잇는 노드에는 다른 pod들은 올라가지않고 gpu쓰는 pod들만 올라가게 하는등의 상황에 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
taint에는 사용할 수 있는 3가지 옵션이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;NoSchedule : toleration이 없으면 pod이 스케쥴되지 않음, 기존 실행되던 pod에는 적용 안됨&lt;/li&gt;
  &lt;li&gt;PreferNoSchedule : toleration이 없으면 pod을 스케줄링안하려고 하지만 필수는 아님, 클러스터내에 자원이 부족하거나 하면 taint가 걸려있는 노드에서도 pod이 스케줄링될 수 있음&lt;/li&gt;
  &lt;li&gt;NoExecute : toleration이 없으면 pod이 스케줄되지 않으며 기존에 실행되던 pod도 toleration이 없으면 종료시킴.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;taint 형식은 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl taint node &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;nodename&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;key&lt;span class=&quot;o&quot;&gt;}={&lt;/span&gt;value&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;:&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;option&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;하나의 노드에 taint 적용하기&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl taint node worker-1 &lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;value:NoSchedule
node/worker-1 tainted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;describe로 잘 적용 되었는지 확인해 봅시다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl describe node worker-1 | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; taint
Taints:             &lt;span class=&quot;nv&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;value:NoSchedule
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;잘 적용이 되었군요.&lt;/p&gt;

&lt;p&gt;taint의 옵션이 &lt;code&gt;NoSchedule&lt;/code&gt; 이므로 pod에 toleration 필드에 같은 key, value가 없다면 생성되지 않겠죠?
확인해봅시다.&lt;/p&gt;

&lt;h3 id=&quot;rocket테스트해보기&quot;&gt;:rocket:테스트해보기&lt;/h3&gt;
&lt;p&gt;Deployment로 pod을 띄어보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;환경&lt;/strong&gt;:&lt;br /&gt;
실습에 사용한 클러스터는 마스터노드1개 워커노드3개로 구성되었으며,
&lt;br /&gt;
이름은 다음과 같고, 워커노드들의 cpu와 ram스팩은 모두 같게 설정하였습니다. &lt;br /&gt;
taint는 worker-1 노드에 설정하였습니다.
master&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;worker-1&lt;/li&gt;
  &lt;li&gt;worker-2&lt;/li&gt;
  &lt;li&gt;instance-1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우선 pod을 세개 생성하는 test-taint.yaml이라는 deployment를 만들어줍니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl create deployment test-taint &lt;span class=&quot;nt&quot;&gt;--image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;nginx &lt;span class=&quot;nt&quot;&gt;--replicas&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3 &lt;span class=&quot;nt&quot;&gt;--dry-run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;client &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; yaml &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; test-taint.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;yaml파일을 열어보면 이렇습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-taint&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-taint&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-taint&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;strategy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;null&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-taint&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만들어진 yaml파일을 apply 해봅시다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; test-taint.yaml
deployment.apps/test-taint created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;pod을 확인해보면 taint를 설정한 node에는 pod이 배정되지 않은것을 확인 할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get pods &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; wide
NAME                          READY   STATUS    RESTARTS   AGE    IP           NODE         NOMINATED NODE   READINESS GATES
test-taint-6bd4977499-2thmv   1/1     Running   0          106s   10.244.3.7   instance-1   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
test-taint-6bd4977499-4sccs   1/1     Running   0          106s   10.244.1.6   worker-2     &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
test-taint-6bd4977499-h4rt8   1/1     Running   0          106s   10.244.3.8   instance-1   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 이 deployment를 삭제하고 toleration을 적용시킨후 다시 deployment를 apply 해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete deployment test-taint
deployment.apps &lt;span class=&quot;s2&quot;&gt;&quot;test-taint&quot;&lt;/span&gt; deleted

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;vim test-taint.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;spec.template.spec 밑에 toleration옵션을 추가해줍니다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;null&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-taint&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-taint&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-taint&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;strategy&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;null&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;test-taint&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;tolerations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;key&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Equal&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;value&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;effect&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;NoSchedule&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;resources&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;pi&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;수정된 yaml파일 다시 배포하기:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; test-taint.yaml
deployment.apps/test-taint created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;pod 리스트를 다시 확인해보면 각 1개의노드에 1개의 pod이 생성된걸 확인할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get pods -o wide
NAME                          READY   STATUS    RESTARTS   AGE   IP           NODE         NOMINATED NODE   READINESS GATES
test-taint-77b85b88c6-8hq5l   1/1     Running   0          43s   10.244.3.9   instance-1   &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
test-taint-77b85b88c6-957bv   1/1     Running   0          43s   10.244.1.7   worker-2     &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
test-taint-77b85b88c6-f6xn2   1/1     Running   0          43s   10.244.2.8   worker-1     &amp;lt;none&amp;gt;           &amp;lt;none&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Docker" /><category term="Kubernetes" /><category term="Replicasets" /><category term="Deployment" /><category term="Google" /><category term="cloud" /><summary type="html">Taint &amp;amp; Toleration taint: 노드마다 설정가능 toleration: taint를 무시할 수 있음 주로 노드를 지정된 역할만 하게할때 사용합니다. 예를들어 gpu잇는 노드에는 다른 pod들은 올라가지않고 gpu쓰는 pod들만 올라가게 하는등의 상황에 사용할 수 있습니다. taint에는 사용할 수 있는 3가지 옵션이 있습니다. NoSchedule : toleration이 없으면 pod이 스케쥴되지 않음, 기존 실행되던 pod에는 적용 안됨 PreferNoSchedule : toleration이 없으면 pod을 스케줄링안하려고 하지만 필수는 아님, 클러스터내에 자원이 부족하거나 하면 taint가 걸려있는 노드에서도 pod이 스케줄링될 수 있음 NoExecute : toleration이 없으면 pod이 스케줄되지 않으며 기존에 실행되던 pod도 toleration이 없으면 종료시킴. taint 형식은 다음과 같습니다. $ kubectl taint node {nodename} {key}={value}:{option} 하나의 노드에 taint 적용하기 $ kubectl taint node worker-1 key=value:NoSchedule node/worker-1 tainted describe로 잘 적용 되었는지 확인해 봅시다. $ kubectl describe node worker-1 | grep -i taint Taints: key=value:NoSchedule 잘 적용이 되었군요. taint의 옵션이 NoSchedule 이므로 pod에 toleration 필드에 같은 key, value가 없다면 생성되지 않겠죠? 확인해봅시다. :rocket:테스트해보기 Deployment로 pod을 띄어보겠습니다. 환경: 실습에 사용한 클러스터는 마스터노드1개 워커노드3개로 구성되었으며, 이름은 다음과 같고, 워커노드들의 cpu와 ram스팩은 모두 같게 설정하였습니다. taint는 worker-1 노드에 설정하였습니다. master worker-1 worker-2 instance-1 우선 pod을 세개 생성하는 test-taint.yaml이라는 deployment를 만들어줍니다 $ kubectl create deployment test-taint --image=nginx --replicas=3 --dry-run=client -o yaml &amp;gt; test-taint.yaml yaml파일을 열어보면 이렇습니다. kind: Deployment metadata: creationTimestamp: null labels: app: test-taint name: test-taint spec: replicas: 3 selector: matchLabels: app: test-taint strategy: {} template: metadata: creationTimestamp: null labels: app: test-taint spec: containers: - image: nginx name: nginx resources: {} status: {} 만들어진 yaml파일을 apply 해봅시다. $ kubectl apply -f test-taint.yaml deployment.apps/test-taint created pod을 확인해보면 taint를 설정한 node에는 pod이 배정되지 않은것을 확인 할 수 있습니다. $ kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES test-taint-6bd4977499-2thmv 1/1 Running 0 106s 10.244.3.7 instance-1 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; test-taint-6bd4977499-4sccs 1/1 Running 0 106s 10.244.1.6 worker-2 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; test-taint-6bd4977499-h4rt8 1/1 Running 0 106s 10.244.3.8 instance-1 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; 이제 이 deployment를 삭제하고 toleration을 적용시킨후 다시 deployment를 apply 해보겠습니다. $ kubectl delete deployment test-taint deployment.apps &quot;test-taint&quot; deleted $ vim test-taint.yaml spec.template.spec 밑에 toleration옵션을 추가해줍니다. apiVersion: apps/v1 kind: Deployment metadata: creationTimestamp: null labels: app: test-taint name: test-taint spec: replicas: 3 selector: matchLabels: app: test-taint strategy: {} template: metadata: creationTimestamp: null labels: app: test-taint spec: tolerations: - key: key operator: Equal value: value effect: NoSchedule containers: - image: nginx name: nginx resources: {} status: {} 수정된 yaml파일 다시 배포하기: $ kubectl apply -f test-taint.yaml deployment.apps/test-taint created pod 리스트를 다시 확인해보면 각 1개의노드에 1개의 pod이 생성된걸 확인할 수 있습니다. $ kubectl get pods -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES test-taint-77b85b88c6-8hq5l 1/1 Running 0 43s 10.244.3.9 instance-1 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; test-taint-77b85b88c6-957bv 1/1 Running 0 43s 10.244.1.7 worker-2 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt; test-taint-77b85b88c6-f6xn2 1/1 Running 0 43s 10.244.2.8 worker-1 &amp;lt;none&amp;gt; &amp;lt;none&amp;gt;</summary></entry><entry><title type="html">[ #3 ] Replicasets &amp;amp; Deployment</title><link href="https://shjeong92.github.io/2021/05/28/Learning-Kubernetes-03.html" rel="alternate" type="text/html" title="[ #3 ] Replicasets &amp;amp; Deployment" /><published>2021-05-28T00:00:00+09:00</published><updated>2021-05-28T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/05/28/Learning-Kubernetes-03</id><content type="html" xml:base="https://shjeong92.github.io/2021/05/28/Learning-Kubernetes-03.html">&lt;hr /&gt;

&lt;h2 id=&quot;replicaset&quot;&gt;Replicaset&lt;/h2&gt;

&lt;p&gt;먼저 Deployment의 개념중에서 가장 중요한것은 ReplicaSet입니다. Replication Controller의 새로운 버전으로 Label Selector를 통해 노드 상의 여러 Pod의 생성/복제/삭제 등의 라이프 싸이클을 관리합니다.&lt;/p&gt;

&lt;h3 id=&quot;작동-방식&quot;&gt;작동 방식&lt;/h3&gt;
&lt;p&gt;레플리카셋을 정의하는 필드는 획득 가능한 파드를 식별하는 방법이 명시된 셀렉터, 유지해야 하는 파드 개수를 명시하는 레플리카의 개수, 그리고 레플리카 수 유지를 위해 생성하는 신규 파드에 대한 데이터를 명시하는 파드 템플릿을 포함한다. 그러면 레플리카셋은 필드에 지정된 설정을 충족하기 위해 필요한 만큼 파드를 만들고 삭제합니다. 레플리카셋이 새로운 파드를 생성해야 할 경우, 명시된 파드 템플릿을 사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#replicaset.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ReplicaSet&lt;/span&gt; 
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-replicaset&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#replicate할 pod명시하기&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-pod&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#pod을 몇개 유지할것인지?      &lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#ReplicaSet은 이미 생성되있는 같은 종류의 pod들까지 신경써가면서 pod을 생성합니다.&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Replicaset은 selector가 있는데 만약 이에 match되는 label을 가진 pod이 있다면 그것도 갯수에 포함시킵니다.&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#pod.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-pod&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;우선 labels.type 이 동일한 pod 하나를 생성해줍니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; pod-definition.yml 
pod/myapp-pod created
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get pods
NAME        READY   STATUS              RESTARTS   AGE
myapp-pod   0/1     ContainerCreating   0          8s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;레이블이 같으니 replicaset.yaml을 apply하면 두개가 생성 되야합니다 한번 확인해봅시다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; replicaset-definition.yml 
replicaset.apps/myapp-replicaset created
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
myapp-pod                1/1     Running   0          23s
myapp-replicaset-f9f87   1/1     Running   0          13s
myapp-replicaset-szrtw   1/1     Running   0          13s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;딱 2개가 생성된것을 확인할 수 있습니다.
&lt;br /&gt;
만약 pod.yaml을 통해 생성된 pod을 지우면 어떻게될까요?&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete pod myapp-pod
pod &lt;span class=&quot;s2&quot;&gt;&quot;myapp-pod&quot;&lt;/span&gt; deleted

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get pods
NAME                     READY   STATUS    RESTARTS   AGE
myapp-replicaset-f9f87   1/1     Running   0          2m46s
myapp-replicaset-spvjx   1/1     Running   0          9s
myapp-replicaset-szrtw   1/1     Running   0          2m46s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ReplicaSet에 replicas를 3으로 세팅해놔서 동일한 label의 팟이 사라지자 자동으로 명시한 pod을 생선한 것을 확인할 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;deployment&quot;&gt;Deployment&lt;/h2&gt;

&lt;p&gt;Deployment는 Replication controller와 Replica Set의 좀더 상위 추상화 개념입니다. kubernetes docs에서는 ReplicaSet 이나 Replication Controller를 바로 사용하는 것보다, 좀 더 추상화된 Deployment를 사용하는것이 권장하고 있습니다.&lt;/p&gt;

&lt;p&gt;yaml파일을 살펴도보면 차이점은 별로 없습니다.&lt;/p&gt;

&lt;p&gt;위의 replicaset.yaml파일에서 한줄만 수정하면 deployment 를 위한 yaml파일을 만들 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment   &amp;lt;----------- 수정된부분&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-replicaset&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;

&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#replicate할 pod명시하기&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-pod&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#pod을 몇개 유지할것인지?      &lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#ReplicaSet은 이미 생성되있는 같은 종류의 pod들까지 신경써가면서 pod을 생성합니다.&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;deployment 또한 replicaset과 같이 이미 동일한 라벨의 pod이 생성되어있으면 또다른 3개의 pod을 만들지 않습니다.&lt;/p&gt;

&lt;p&gt;위의 Replicaset.yaml을 통해 만들어진 동일한 label의 pod이 존재하기때문에 새로운 pod을 만들지 않습니다. 또한
이미 동일한 replicaset이 있기에 다른 replicaset을 만들지 않습니다.&lt;/p&gt;

&lt;p&gt;기존의 Replicaset object를 지우면 어떻게 될까요?&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; replicaset-definition.yml 
replicaset.apps &lt;span class=&quot;s2&quot;&gt;&quot;myapp-replicaset&quot;&lt;/span&gt; deleted

&lt;span class=&quot;c&quot;&gt;# 삭제직후 replicaset을 바로 확인해보면 Deployment.yaml에의해 새로운 replicaset이 생성된것을 확인할 수 있고&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get replicaset
NAME                          DESIRED   CURRENT   READY   AGE
myapp-replicaset-7df67f74c5   3         3         3       3s

&lt;span class=&quot;c&quot;&gt;# 이전 replicaset에 의해 생성 된 pod들이 삭제되면서, 새로운 replicaset에의해 pod이 재 생성되는것을 볼 수 있습니다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get pods
NAME                                READY   STATUS              RESTARTS   AGE
myapp-replicaset-7df67f74c5-c992z   1/1     Running             0          5s
myapp-replicaset-7df67f74c5-cwk22   0/1     ContainerCreating   0          5s
myapp-replicaset-7df67f74c5-zzx7h   1/1     Running             0          5s
myapp-replicaset-jnqgg              0/1     Terminating         0          73s
myapp-replicaset-qghpt              0/1     Terminating         0          73s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Docker" /><category term="Kubernetes" /><category term="Replicasets" /><category term="Deployment" /><category term="Google" /><category term="cloud" /><summary type="html">Replicaset 먼저 Deployment의 개념중에서 가장 중요한것은 ReplicaSet입니다. Replication Controller의 새로운 버전으로 Label Selector를 통해 노드 상의 여러 Pod의 생성/복제/삭제 등의 라이프 싸이클을 관리합니다. 작동 방식 레플리카셋을 정의하는 필드는 획득 가능한 파드를 식별하는 방법이 명시된 셀렉터, 유지해야 하는 파드 개수를 명시하는 레플리카의 개수, 그리고 레플리카 수 유지를 위해 생성하는 신규 파드에 대한 데이터를 명시하는 파드 템플릿을 포함한다. 그러면 레플리카셋은 필드에 지정된 설정을 충족하기 위해 필요한 만큼 파드를 만들고 삭제합니다. 레플리카셋이 새로운 파드를 생성해야 할 경우, 명시된 파드 템플릿을 사용합니다. #replicaset.yaml apiVersion: apps/v1 kind: ReplicaSet metadata: name: myapp-replicaset labels: app: myapp type: front-end spec: #replicate할 pod명시하기 template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx #pod을 몇개 유지할것인지? replicas: 3 #ReplicaSet은 이미 생성되있는 같은 종류의 pod들까지 신경써가면서 pod을 생성합니다. selector: matchLabels: type: front-end Replicaset은 selector가 있는데 만약 이에 match되는 label을 가진 pod이 있다면 그것도 갯수에 포함시킵니다. #pod.yaml apiVersion: v1 kind: Pod metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx 우선 labels.type 이 동일한 pod 하나를 생성해줍니다. $ kubectl apply -f pod-definition.yml pod/myapp-pod created $ kubectl get pods NAME READY STATUS RESTARTS AGE myapp-pod 0/1 ContainerCreating 0 8s 레이블이 같으니 replicaset.yaml을 apply하면 두개가 생성 되야합니다 한번 확인해봅시다. $ kubectl apply -f replicaset-definition.yml replicaset.apps/myapp-replicaset created $ kubectl get pods NAME READY STATUS RESTARTS AGE myapp-pod 1/1 Running 0 23s myapp-replicaset-f9f87 1/1 Running 0 13s myapp-replicaset-szrtw 1/1 Running 0 13s 딱 2개가 생성된것을 확인할 수 있습니다. 만약 pod.yaml을 통해 생성된 pod을 지우면 어떻게될까요? $ kubectl delete pod myapp-pod pod &quot;myapp-pod&quot; deleted $ kubectl get pods NAME READY STATUS RESTARTS AGE myapp-replicaset-f9f87 1/1 Running 0 2m46s myapp-replicaset-spvjx 1/1 Running 0 9s myapp-replicaset-szrtw 1/1 Running 0 2m46s ReplicaSet에 replicas를 3으로 세팅해놔서 동일한 label의 팟이 사라지자 자동으로 명시한 pod을 생선한 것을 확인할 수 있습니다. Deployment Deployment는 Replication controller와 Replica Set의 좀더 상위 추상화 개념입니다. kubernetes docs에서는 ReplicaSet 이나 Replication Controller를 바로 사용하는 것보다, 좀 더 추상화된 Deployment를 사용하는것이 권장하고 있습니다. yaml파일을 살펴도보면 차이점은 별로 없습니다. 위의 replicaset.yaml파일에서 한줄만 수정하면 deployment 를 위한 yaml파일을 만들 수 있습니다. apiVersion: apps/v1 kind: Deployment &amp;lt;----------- 수정된부분 metadata: name: myapp-replicaset labels: app: myapp type: front-end spec: #replicate할 pod명시하기 template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx #pod을 몇개 유지할것인지? replicas: 3 #ReplicaSet은 이미 생성되있는 같은 종류의 pod들까지 신경써가면서 pod을 생성합니다. selector: matchLabels: type: front-end deployment 또한 replicaset과 같이 이미 동일한 라벨의 pod이 생성되어있으면 또다른 3개의 pod을 만들지 않습니다. 위의 Replicaset.yaml을 통해 만들어진 동일한 label의 pod이 존재하기때문에 새로운 pod을 만들지 않습니다. 또한 이미 동일한 replicaset이 있기에 다른 replicaset을 만들지 않습니다. 기존의 Replicaset object를 지우면 어떻게 될까요? $ kubectl delete -f replicaset-definition.yml replicaset.apps &quot;myapp-replicaset&quot; deleted # 삭제직후 replicaset을 바로 확인해보면 Deployment.yaml에의해 새로운 replicaset이 생성된것을 확인할 수 있고 $ kubectl get replicaset NAME DESIRED CURRENT READY AGE myapp-replicaset-7df67f74c5 3 3 3 3s # 이전 replicaset에 의해 생성 된 pod들이 삭제되면서, 새로운 replicaset에의해 pod이 재 생성되는것을 볼 수 있습니다. $ kubectl get pods NAME READY STATUS RESTARTS AGE myapp-replicaset-7df67f74c5-c992z 1/1 Running 0 5s myapp-replicaset-7df67f74c5-cwk22 0/1 ContainerCreating 0 5s myapp-replicaset-7df67f74c5-zzx7h 1/1 Running 0 5s myapp-replicaset-jnqgg 0/1 Terminating 0 73s myapp-replicaset-qghpt 0/1 Terminating 0 73s</summary></entry></feed>