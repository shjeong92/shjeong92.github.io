<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://shjeong92.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://shjeong92.github.io/" rel="alternate" type="text/html" hreflang="ko" /><updated>2021-07-03T22:46:00+09:00</updated><id>https://shjeong92.github.io/feed.xml</id><title type="html">Hyuk’s devlog</title><subtitle>Your Site Description
</subtitle><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><entry><title type="html">브라우저에 URL을 입력했을 때 일어나는 일들</title><link href="https://shjeong92.github.io/2021/07/03/When-you-typed-url.html" rel="alternate" type="text/html" title="브라우저에 URL을 입력했을 때 일어나는 일들" /><published>2021-07-03T00:00:00+09:00</published><updated>2021-07-03T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/07/03/When-you-typed-url</id><content type="html" xml:base="https://shjeong92.github.io/2021/07/03/When-you-typed-url.html">&lt;p&gt;이번 포스트 에서는 브라우저에 &lt;em&gt;www.naver.com&lt;/em&gt;을 입력해보고 어떠한 일이 일어나는지 과정을 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-브라우저의-url-파싱&quot;&gt;1. 브라우저의 URL 파싱&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/124287483-0671f200-db8b-11eb-9498-e17442d62bb7.png&quot; alt=&quot;URL&quot; /&gt;&lt;/p&gt;

&lt;p&gt;URL을 입력받은 부라우저는 먼저 해당 URL의 구조를 해석합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;어떤 프로토콜을 사용할지&lt;/li&gt;
  &lt;li&gt;어느 도메인으로 보낼지&lt;/li&gt;
  &lt;li&gt;어떤 포트로 보낼지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;해석하게 되는것입니다.&lt;/p&gt;

&lt;p&gt;명시적으로 포트를 선언하지 않아도 브라우저에서는 설정된 기본값을 이용하여 요청하게되는데요, HTTP 라면 80번 포트를, HTTPS의 경우 443번 포트를 기본 값으로 요청하는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;2-hsts-목록-조회&quot;&gt;2. HSTS 목록 조회&lt;/h3&gt;

&lt;p&gt;HSTS(HTTP Strict transport security), HTTP를 허용하지 않고 HTTPS를 사용하는 연결만 허용하는 기능입니다. 만약 HTTP로 요청이 왔다면 HTTP 응답 헤더에 “Strict Transport Security”라는 필드를 포함하여 응답하고 이를 확인한 브라우저는 해당 서버에 요청할 때 HTTPS만을 통해 통신하게 됩니다. 그리고 자신의 HSTS캐시에 해당 URL을 저장하는데 이를 HSTS 목록이라고 부릅니다.&lt;/p&gt;

&lt;p&gt;이를 통해 브라우저에서는 이 HSTS 목록 조회를 통해 해당 요청을 HTTPS로 보낼지 판단합니다. HSTS목록에 해당 URL이 존재한다면 명시적으로 HTTP를 통해 요청한다 해도 브라우저가 이를 HTTPS로 요청합니다.&lt;/p&gt;

&lt;h3 id=&quot;3-url을-ip주소로-변환&quot;&gt;3. URL을 IP주소로 변환&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;www.google.com&lt;/strong&gt; 이라는 주소로는 컴퓨터끼리 통신할 수 없습니다. 이를 인터넷 상에서 컴퓨터가 읽을 수 있는 IP주소로 변환해야 서로 통신이 가능하게 됩니다. 우선 브라우저에서는 자신의 로컬 hosts 파일과 브라우저 캐시에 해당 URL이 존재하는지 확인합니다. 존재하지 않는다면 도메인 주소를 IP주소로 변환해주는 DNS(Domain Name System) 서버에 요청하여 해당 URL을 IP주소로 변환합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DNS 서버로 요청하는 과정&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/124294979-4b018b80-db93-11eb-9b92-8b44d6763a8b.gif&quot; alt=&quot;dns&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PC는 미리 설정되어 있는 Local DNS에게 IP 주소를 물어봅니다.&lt;/li&gt;
  &lt;li&gt;만약 Local DNS에 호스트 네임에 대한 정보가 없을 경우 각 Local DNS에 설정된 Root DNS에 질의를 시작합니다.
    &lt;ul&gt;
      &lt;li&gt;Root DNS는 전세계에 13대가 구축되어 있으며, 우리나라에는 Root DNS 가 없지만, 3대의 미러 서버가 설정되어 있다고 합니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Root DNS에도 호스트에 대한 정보가 없으면, 다른 DNS 서버에게 질의할 수 있도록 요청합니다.&lt;/li&gt;
  &lt;li&gt;Local DNS는 .com을 관리하는 DNS에게 호스트 네임에 대한 질의를 요청하고 요청한 결과가 없을 경우 다시 질의할 다른 DNS 서버의 주소를 알려줍니다.&lt;/li&gt;
  &lt;li&gt;Local DNS는 google.com을 관리하는 DNS에게 호스트 네임에 대한 질의를 요청하고 결과가 있을 경우 IP주소에 대한 결과를 반환합니다.&lt;/li&gt;
  &lt;li&gt;Local DNS는 &lt;strong&gt;‘www.naver.com’&lt;/strong&gt;에 대한 IP 주소를 캐싱하고, 클라이언트에게 전달합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Recursive Query&lt;/strong&gt; : Local DNS 서버가 여러 DNS 서버를 차례대로 &lt;strong&gt;Root DNS 서버&lt;/strong&gt; -&amp;gt; &lt;strong&gt;com DNS 서버&lt;/strong&gt;(Top level Domain) -&amp;gt; &lt;strong&gt;naver.com DNS 서버&lt;/strong&gt;(Secondary Level Domain) 질의해서 답을 찾아가는 과정&lt;/p&gt;

&lt;h3 id=&quot;4-arp-프로세스&quot;&gt;4. ARP 프로세스&lt;/h3&gt;

&lt;p&gt;ARP (주소 결정 프로토콜, Address Resolution Protocol) 브로드캐스트를 보내기 위해서는 네트워크 스택 라이브러리가 검색할 목적지 IP의 주소를 알아야 합니다. 또, ARP 브로드캐스트를 보내는 데 사용하는 인터페이스의 MAC 주소 역시 알아야 합니다.&lt;/p&gt;

&lt;h4 id=&quot;항목이-arp-캐시에-있을때&quot;&gt;항목이 ARP 캐시에 있을때&lt;/h4&gt;
&lt;p&gt;가장 먼저, ARP 캐시가 목적지 IP의 ARP 항목을 가지고 있는지 점검합니다. 만약 캐시에 있다면 라이브러리 함수는 다음의 형태로 결과를 리턴합니다: 목적지 IP = MAC.&lt;/p&gt;

&lt;h4 id=&quot;항목이-arp-캐시에-없을때&quot;&gt;항목이 ARP 캐시에 없을때&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;라우트 테이블을 검색해서 목적지 IP 주소가 로컬 라우트 테이블의 서브넷에 존재하는지 봅니다. 존재한다면, 라이브러리가 그 서브넷에 속하는 인터페이스를 활용합니다. 없다면, 라이브러리는 우리 기본 게이트웨이의 서브넷에 속하는 인터페이스를 활용합니다.&lt;/li&gt;
  &lt;li&gt;선택된 네트워크 인터페이스의 MAC 주소가 검색이 됩니다.&lt;/li&gt;
  &lt;li&gt;네트워크 라이브러리는 Data Link Layer(OSI Layer 2) 에 ARP요청을 보냅니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARP Request&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sender MAC: interface:mac:address:here
Sender IP: interface.ip.goes.here
Target MAC: FF:FF:FF:FF:FF:FF (Broadcast)
Target IP: target.ip.goes.here
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARP Reply&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Sender MAC: target:mac:address:here
Sender IP: target.ip.goes.here
Target MAC: interface:mac:address:here
Target IP: interface.ip.goes.here
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 네트워크 라이브러리는 우리 DNS 서버나 DNS 프로세스를 재개할 수 있는 기본 게이트웨이 중 하나의 IP 주소를 갖고 있습니다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;53번 포트는 DNS 서버에 UDP 요청을 보내기 위해 열려 있습니다 (만약 응답 크기가 너무 크다면, TCP가 대신 사용되구요).&lt;/li&gt;
  &lt;li&gt;로컬/ISP의 DNS 서버가 해당 정보를 갖고 있지 않다면, 재귀적인 탐색이 수행되고 SOA(Service-oriented architecture)가 도달해서 결과값이 되돌아올 때까지 DNS 서버 리스트를 타고 올라갑니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;5-대상과-tcp-통신을-통해-socket열기&quot;&gt;5. 대상과 TCP 통신을 통해 Socket열기&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/124304948-607cb280-db9f-11eb-93c4-008c1425cda2.png&quot; alt=&quot;3wayhswithtls&quot; /&gt;&lt;/p&gt;

&lt;p&gt;HTTPS 프로토콜을 사용하므로
3-way handshake를 통하여 소켓을열고&lt;/p&gt;

&lt;p&gt;TLS handshake 과정이 추가됩니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;TCP socket 생성&lt;/li&gt;
  &lt;li&gt;TCP 연결을 통해 클라이언트는 실행 중인 TLS protocol의 버전, 사용가능한 암호 세트, 사용할 수 있는 TLS 옵션 목록 등을 평문으로 보냅니다.&lt;/li&gt;
  &lt;li&gt;84ms : 서버는 통신할 때 사용 할 TLS의 버전을 선택하고, 클라이언트가 제공한 목록에서 암호 조합을 결정하고 인증서를 첨부해서 클라이언트에 보냅니다. 선택적으로 서버는 다른 TLS 확장에 대한 클라이언트 인증서 및 매개 변수에 대해 요청을 보낼 수도 있습니다.&lt;/li&gt;
  &lt;li&gt;양측이 공통된 버전과 암호를 협상 할 수 있고, 클라이언트가 서버에서 제공한 인증서에 만족하면, 클라이언트는 RSA 또는 Diffie-hellman 키 교환을 시작합니다. 이 교환은 이어지는 세션에서 사용할 대칭키를 설정합니다.&lt;/li&gt;
  &lt;li&gt;서버는 클라이언트가 전송한 키 교환 매개변수를 처리하고 MAC address을 확인하여 메시지 무결성을 검사하고 암호화 된 Finished message를 클라이언트에 전송합니다.&lt;/li&gt;
  &lt;li&gt;클라이언트를 협상 된 대칭키를 사용해 message 암호를 해독하고 MAC address를 확인해서 모두 정상이면 터널이 설정되고 통신을 시작합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;TLS&lt;/strong&gt;에 대해서는 &lt;a href=&quot;https://shjeong92.github.io/2021/06/09/Learning-Kubernetes-11.html&quot;&gt;이곳&lt;/a&gt;에 자세히 정리해 놓았습니다.&lt;/p&gt;

&lt;h3 id=&quot;6-http-프로토콜&quot;&gt;6. HTTP 프로토콜&lt;/h3&gt;

&lt;p&gt;구글이 만든 웹 브라우저라면, 페이지를 가져오기 위해 HTTP 요청을 보내는 대신, 서버에게 HTTP에서 SPDY로 “업그레이드”할 것을 협상해봅니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SPDY란&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;구글은 더 빠른 Web을 실현하기 위해 Latency 관점에서 HTTP를 고속화한 SPDY(스피디) 라 불리는 새로운 프로토콜을 구현했습니다.
SPDY는 HTTP를 대치하는 프로토콜이 아니고 HTTP를 통한 전송을 재 정의하는 형태로 구현 되어있습니다.
SPDY는 실제로 HTTP/1.1에 비해 상당한 성능 향상과 효율성을 보여줬고 이는 HTTP/2 초안의 참고 규격이 되었다고 합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;만약 클라이언트가 SPDY를 지원하지 않고 HTTP만 쓴다면, 서버에 다으과 같은 요청을  보냅니다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET / HTTP/1.1
Host: google.com
Connection: close
[other headers]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;[other headers]&lt;/strong&gt; 부분은 HTTP 사양에 따라 콜론으로 구분되고 각각 새 줄로 나뉘는 일련의 키-값 쌍을 나타냅니다. (이 부분은 사용된 브라우저가 HTTP 스펙을 벗어나는 어떠한 버그도 없을 때를 가정해요. 웹 브라우저가 HTTP/1.1 을 쓴다는 것도 마찬가지인데, 그렇지 않을 경우엔 Host 헤더가 요청에 포함되지 않고 GET 요청에 명시된 버전이 HTTP/1.0 혹은 HTTP/0.9 일 수도 있습니다. )&lt;/p&gt;

&lt;p&gt;HTTP/1.1은 송신자측에서 응답을 받은 직후에 연결이 끊어질 것이라는 신호를 보내기 위해 “close”라는 연결 옵션을 정의합니다. 아래의 예처럼 말이죠.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Connection: close
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;영구 접속을 허용하지 않는 HTTP/1.1 어플리케이션은 반드시 “close” 연결 옵션을 모든 메시지에 포함해야 합니다.&lt;/p&gt;

&lt;p&gt;요청과 헤더를 보낸 후에, 웹 브라우저는 하나의 빈 줄을 서버에 보내 요청 내용이 모두 보내졌음을 알립니다.&lt;/p&gt;

&lt;p&gt;서버는 요청의 상태를 나타내는 코드와 다음과 같은 형태로 응답합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;200 OK
[response headers]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이다음에 www.naver.com의 HTML컨텐츠를 payload에 실어서 보냅니다.
그 이후 서버는 연결을 종료할 수도있고, 클라이언트가 보낸 헤더가 요청한 경우 추가 요청을 위해 연결을 유지 할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;만약 웹 브라우저가 보낸 HTTP header에 웹 브라우저가 캐시한 파일의 버전이 마지막 검색이후 수정되지 않았으면(HTTP header의 ETag 값으로 확인) 서버에선 다음과 같이 응답합니다&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;304 Not Modified
[response headers]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;이 응답에서는 payload 가 없고 웹브라우저는 캐시에서 HTML을 검색합니다.&lt;/li&gt;
  &lt;li&gt;HTML을 파싱한 후 웹 브라우저와 서버는 GET / HTTP/1.1요청이 아닌 HTML페이지에서 참조하는 모든 자원(Image, CSS, favicon.ico 등)에 대해 이 프로세스를 반복합니다.&lt;/li&gt;
  &lt;li&gt;만약 HTML이 다른 Domain의 resource를 참조하는 경우 웹 브라우저는 다른 도메인을 확인하는 단계(&lt;strong&gt;3번 단계&lt;/strong&gt;)로 돌아가고 해당 도메인에 대해 모든 단계를 수행하고, Host 요청의 header는 해당 서버의 이름으로 설정됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;7-http-서버의-응답&quot;&gt;7. HTTP 서버의 응답&lt;/h3&gt;

&lt;p&gt;HTTPD (HTTP 데몬) 서버는 서버측에서 요청/응답을 처리하는 친구입니다. 대표적으로 자주 쓰이는 nginx 가 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTTPD (HTTP 데몬)&lt;/li&gt;
  &lt;li&gt;서버는 요청을 다음과 같은 파라미터들로 분리합니다.
    &lt;ul&gt;
      &lt;li&gt;HTTP method(GET, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, HEAD 중 하나).
  주소창에 URL을 직접 입력한 경우에는 GET 이겠죠&lt;/li&gt;
      &lt;li&gt;도메인, (naver.com).&lt;/li&gt;
      &lt;li&gt;요청된 경로/페이지 - (www.naver.com은 홈페이지입니다, 즉 특정 경로와 페이지가 없기에 기본경로인 ‘/’가 들어갑니다)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서버는 naver.com에 해당하는 가상 호스트가 서버에 설정되어 있는지 확인합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;서버는 naver.com이 GET 요청을 받아들일 수 있는지 봅니다.&lt;/li&gt;
  &lt;li&gt;서버는 해당 클라이언트에게 이 메소드가 허용되는지 봅니다 (IP, 인증, 기타 등등을 통하여).&lt;/li&gt;
  &lt;li&gt;만약에 서버에 rewrite 설정이 되어있다면 해당하는 경로로 다시 요청을 하게됩니다. (www로 시작하지 않는것을 www로 가게하거나 아래와 같이 http로 들어온 모든요청을 https로 rewrite 하기도 하죠)&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  server {
      listen 80;
      server_name    my.domain.com;
      rewrite ^(.*) https://$host$1 permanent;
  }

  server {
      listen 443;
      server_name    my.domain.com;
      # .....
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;서버는 요청에 해당하는 콘텐츠를 가져오고, 기본경로인 “/” 이므로 이 경우 index파일을 해석합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;서버는 가져온 파일을 핸들러를 통해 분석하여 결과를 클라이언트로 보냅니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;8-브라우저-안에서-일어나는-일들&quot;&gt;8. 브라우저 안에서 일어나는 일들&lt;/h3&gt;

&lt;p&gt;서버가 브라우저에 (HTML, CSS, JS, 이미지, …)을 제공하면 브라우저는 아래 프로세서를 수행합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;파싱 - HTML, CSS, JS&lt;/li&gt;
  &lt;li&gt;렌더링: DOM 트리 생성 -&amp;gt; 트리 렌더링 -&amp;gt; 렌더링 된 트리 배치 -&amp;gt; 렌더링 된 트리 색칠&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/124343524-07e10000-dc07-11eb-8c50-0e692fd76465.png&quot; alt=&quot;rendering&quot; /&gt;&lt;/p&gt;

&lt;p&gt;웹 브라우저의 기능은 서버에서 요청하고 브라우저 창에 표시하여 선택한 웹 리소스를 표시하는 것입니다. 리소스는 일반적으로 HTML문서이지만 PDF, 이미지 또는 다른 유형의 콘텐츠일 수도 있습니다. 자원의 위치는 URI(Uniform Resource Identifier)를 사용하여 사용자가 지정합니다.&lt;/p&gt;

&lt;p&gt;브라우저가 HTML파일을 해석하고 표시하는 방법은 HTML 및 CSS 사양에 지정되어 있습나다. 이 사양은 웹 표준 단체인 W3C(World Wide Web Consortium)에서 관리합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;브라우저의 일반적인 User Interface 요소&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;URI를 입력하기 위한 주소표시줄&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;뒤로 및 앞으로 버튼&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;북마크 버튼&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;새로고침 및 중지 버튼&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;홈페이지 이동 버튼&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;브라우저의 구성요소들&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;유저 인터페이스: 유저 인터페이스는 주소창, 뒤로/앞으로 버튼, 즐겨찾기 메뉴 등등을 포함합니다. 당신이 요청한 페이지를 보는 창을 제외한 브라우저의 모든 부분이죠.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;브라우저 엔진: 브라우저 엔진은 UI와 렌더링 엔진 사이에 일어나는 일을 통제합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;렌더링 엔진: 렌더링 엔진은 요청된 내용을 보여주는 부분을 책임집니다. 예를 들어 만약 요청된 내용이 HTML이면, 렌더링 엔진은 HTML과 CSS를 분석하고, 처리된 내용을 화면에 띄워줍니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;네트워킹: 네트워킹은 HTTP와 같은 네트워크 요청을, 플랫폼별로 다른 구현체를 활용해 플랫폼-독립적인 인터페이스 뒤에서 처리하죠.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UI 백엔드: UI 백엔드는 콤보박스나 창 같은 기본적인 위젯을 그리는 데 쓰입니다. 이 백엔드는 플랫폼에 구애받지 않는 포괄적인 인터페이스를 노출시킵니다. 내부적으로는 운영 체제의 유저 인터페이스 메소드들을 활용하면서요.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JavaScript 엔진: JavaScript 엔진은 JavaScript 코드를 분석하고 실행하는 데 활용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;데이터 저장소: 데이터 저장소는 유지가 되는 계층입니다. 브라우저가 쿠키같은 갖가지 종류의 데이터를 저장해둬야 할 수도 있거든요. 브라우저는 또 localStorage와 sessionStorage, IndexedDB, WebSQL, 파일시스템과 같은 저장 메커니즘을 지원합니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;html-파싱&quot;&gt;HTML 파싱&lt;/h3&gt;

&lt;p&gt;렌더링 엔진은 네트워킹 계층에서 요청한 문서의 내용을 받아오기 시작합니다. 문서는 보통 8KB 단위로 전송됩니다.&lt;/p&gt;

&lt;p&gt;HTML 파서의 주된 역할은 HTML 마크업을 파스 트리로 분석해내는 겁니다.&lt;/p&gt;

&lt;p&gt;이렇게 나온 트리 (“파스 트리 parse tree”) 는 DOM 요소와 속성 노드의 트리입니다. DOM은 Document Object Mode의 줄임말이고요. 이 친구는 HTML 문서와 HTML 요소를 JavaScript 같은 외부 요소와 이어주는 인터페이스의 객체 표현 방식입니다. 이 트리의 루트는 “Document” 객체입니다. 스크립트를 통한 모든 조작보다 앞서, DOM은 마크업과 거의 일대일인 관계를 갖습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;파싱 알고리즘&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTML은 일반적인 탑-다운이나 바텀-업 방식의 파서로는 분석할 수 없습니다.&lt;/p&gt;

&lt;p&gt;그 이유는 아래오 같습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;관대한 언어적 특성.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;브라우저는 흔히 알려진, 잘못된 HTML들을 지원하기 위해 전통적으로 에러를 용인해왔다는 사실.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;파싱 과정은 재진입 가능하다는 것입니다. 다른 언어에서, 소스는 파싱 과정에서 변하지 않지만, HTML에서는, 동적 코드 (예를 들어 document.write() 호출을 담고 있는 스크립트 요소) 가 추가적인 토큰을 추가할 수도 있어서, 파싱 과정이 실제로 입력값을 바꿉니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반적인 파싱 기술을 쓸 수 없으니, 브라우저는 임의의 파서를 활용해 HTML을 파싱합니다. 파싱 알고리즘은 아래와 같이 &lt;strong&gt;토큰화와 트리생성&lt;/strong&gt;의 단계로 이루워 져있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/124343711-b174c100-dc08-11eb-819f-98ddc4f021c2.png&quot; alt=&quot;parser&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자세한 정보는 &lt;a href=&quot;https://www.w3.org/TR/2011/WD-html5-20110405/parsing.html#parsing&quot;&gt;이곳&lt;/a&gt;에서 확인가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;파싱이 끝난후의 동작&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;브라우저가 페이지에 링크돼있는 외부 자원 (CSS, 이미지, JavaScript 파일, 기타 등등) 을 가져오기 시작합니다.&lt;/p&gt;

&lt;p&gt;이 단계에서 브라우저는 해당 문서가 상호작용 중이라는 표시를 해두고 “deferred” 모드에 있는 스크립트를 파싱하기 시작합니다: 반드시 문서를 분석한 후에 실행되어야 하는 것들이죠. 문서의 상태는 “complete” 으로 설정되고 “load” 이벤트가 발생됩니다.&lt;/p&gt;

&lt;p&gt;HTML 페이지에 “Invalid Syntax”에러는 존재하지 않습니다. 브라우저가 어떠한 내용이든 고치고 넘어갑니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CSS 분석&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 태그 내용과, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;style&lt;/code&gt; 속성값으로 되어있는 CSS 파일들을 &lt;a href=&quot;https://www.w3.org/TR/CSS2/grammar.html&quot;&gt;“CSS lexical and syntax grammar”&lt;/a&gt; 를 활용해 파싱합니다.
각각의 CSS 파일은 Stylesheet object 로 파싱되는데, 여기서 각 객체는 selector 및 CSS 문법에 해당하는 객체들과 함께 CSS 규칙들을 담고 있습니다.
CSS 파서는 특정한 파서 생성기가 사용됐을 경우에 탑-다운이나 바텀-업도 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;페이지 렌더링&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;DOM 노드를 탐색하고 각 노드에 대한 CSS 값을 계산하여 “Frame tree” 또는 “Render tree”를 만듭니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;자식 노드의 width와 수평 margin, border, padding 을 합해서 Frame tree의 아래쪽에 있는 각 노드의 기본 너비를 계산합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 노드의 사용 가능한 너비를 자식 노드에 할당하여 각 노드의 실제 width 값 계산합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;텍스트 배치를 적용하고 하위 노드의 height와 margin, border, padding을 합해 각 노드의 높이를 상향식으로 계산합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위에서 계산 된 정보를 사용해서 각 노드의 좌표를 계산합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;float, absolutely, relatively 와 같은 속성이 사용되었을 경우 더 복잡한 단계가 수행 됩니다.&lt;/p&gt;

    &lt;p&gt;자세한건  &lt;a href=&quot;http://dev.w3.org/csswg/css2/&quot;&gt;http://dev.w3.org/csswg/css2/&lt;/a&gt; 와 &lt;a href=&quot;http://www.w3.org/Style/CSS/&quot;&gt;http://www.w3.org/Style/CSS/&lt;/a&gt;current-work 참조하세요&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;페이지의 어느 부분을 그룹으로 애니메이션화 할 수 있는지 설명하는 레이어를 만듭니다. frame/render object는 layer에 할당합니다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;텍스처는 페이지의 각 레이어에 할당합니다&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;각 frame/render object를 통해서 각 레이어 별로 그리기 명령을 실행합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위의 모든 단계를 웹페이지가 렌더링 된 마지막 시간에 계산 된 값을 재사용 할 수 있으므로 점진적 변경은 작업이 덜 필요합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;페이지 레이어는 합성 프로세스로 보내져 browser chrome, iframe, addon panels과 같은 시각적인 레이어와 결합됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;최종 레이어 위치가 계산되고 Direct3D / OpenGL을 통해 합성 명령이 실행된다. GPU 명령 버퍼는 비동기 렌더링을 위해 GPU로 출력되고 frame은 window server로 전송됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;GPU 렌더링&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;렌더링 프로세스 동안 graphical computing layers는 CPU 또는 GPU를 사용할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;graphical rendering 계산에 GPU를 사용하는 경우 그래픽 소프트웨어 레이어에서 작업을 여러조각으로 분할하여 렌더링 프로세스에 필요한 부동 소수점 계산을 위해 GPU 대용량 병렬 처리를 사용 할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;렌더링이 완료된 후 브라우저는 Javascript 실행을 통해 DOM과 CSSOM이 변경 될 수 있는데 레이아웃이 수정 되는 경우 페이지 렌더링 및 페인팅을 다시 수행합니다.&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="네트워크" /><category term="브라우저" /><summary type="html">이번 포스트 에서는 브라우저에 www.naver.com을 입력해보고 어떠한 일이 일어나는지 과정을 알아보겠습니다. 1. 브라우저의 URL 파싱 URL을 입력받은 부라우저는 먼저 해당 URL의 구조를 해석합니다. 어떤 프로토콜을 사용할지 어느 도메인으로 보낼지 어떤 포트로 보낼지 해석하게 되는것입니다. 명시적으로 포트를 선언하지 않아도 브라우저에서는 설정된 기본값을 이용하여 요청하게되는데요, HTTP 라면 80번 포트를, HTTPS의 경우 443번 포트를 기본 값으로 요청하는 것입니다. 2. HSTS 목록 조회 HSTS(HTTP Strict transport security), HTTP를 허용하지 않고 HTTPS를 사용하는 연결만 허용하는 기능입니다. 만약 HTTP로 요청이 왔다면 HTTP 응답 헤더에 “Strict Transport Security”라는 필드를 포함하여 응답하고 이를 확인한 브라우저는 해당 서버에 요청할 때 HTTPS만을 통해 통신하게 됩니다. 그리고 자신의 HSTS캐시에 해당 URL을 저장하는데 이를 HSTS 목록이라고 부릅니다. 이를 통해 브라우저에서는 이 HSTS 목록 조회를 통해 해당 요청을 HTTPS로 보낼지 판단합니다. HSTS목록에 해당 URL이 존재한다면 명시적으로 HTTP를 통해 요청한다 해도 브라우저가 이를 HTTPS로 요청합니다. 3. URL을 IP주소로 변환 www.google.com 이라는 주소로는 컴퓨터끼리 통신할 수 없습니다. 이를 인터넷 상에서 컴퓨터가 읽을 수 있는 IP주소로 변환해야 서로 통신이 가능하게 됩니다. 우선 브라우저에서는 자신의 로컬 hosts 파일과 브라우저 캐시에 해당 URL이 존재하는지 확인합니다. 존재하지 않는다면 도메인 주소를 IP주소로 변환해주는 DNS(Domain Name System) 서버에 요청하여 해당 URL을 IP주소로 변환합니다. DNS 서버로 요청하는 과정 PC는 미리 설정되어 있는 Local DNS에게 IP 주소를 물어봅니다. 만약 Local DNS에 호스트 네임에 대한 정보가 없을 경우 각 Local DNS에 설정된 Root DNS에 질의를 시작합니다. Root DNS는 전세계에 13대가 구축되어 있으며, 우리나라에는 Root DNS 가 없지만, 3대의 미러 서버가 설정되어 있다고 합니다. Root DNS에도 호스트에 대한 정보가 없으면, 다른 DNS 서버에게 질의할 수 있도록 요청합니다. Local DNS는 .com을 관리하는 DNS에게 호스트 네임에 대한 질의를 요청하고 요청한 결과가 없을 경우 다시 질의할 다른 DNS 서버의 주소를 알려줍니다. Local DNS는 google.com을 관리하는 DNS에게 호스트 네임에 대한 질의를 요청하고 결과가 있을 경우 IP주소에 대한 결과를 반환합니다. Local DNS는 ‘www.naver.com’에 대한 IP 주소를 캐싱하고, 클라이언트에게 전달합니다. Recursive Query : Local DNS 서버가 여러 DNS 서버를 차례대로 Root DNS 서버 -&amp;gt; com DNS 서버(Top level Domain) -&amp;gt; naver.com DNS 서버(Secondary Level Domain) 질의해서 답을 찾아가는 과정 4. ARP 프로세스 ARP (주소 결정 프로토콜, Address Resolution Protocol) 브로드캐스트를 보내기 위해서는 네트워크 스택 라이브러리가 검색할 목적지 IP의 주소를 알아야 합니다. 또, ARP 브로드캐스트를 보내는 데 사용하는 인터페이스의 MAC 주소 역시 알아야 합니다. 항목이 ARP 캐시에 있을때 가장 먼저, ARP 캐시가 목적지 IP의 ARP 항목을 가지고 있는지 점검합니다. 만약 캐시에 있다면 라이브러리 함수는 다음의 형태로 결과를 리턴합니다: 목적지 IP = MAC. 항목이 ARP 캐시에 없을때 라우트 테이블을 검색해서 목적지 IP 주소가 로컬 라우트 테이블의 서브넷에 존재하는지 봅니다. 존재한다면, 라이브러리가 그 서브넷에 속하는 인터페이스를 활용합니다. 없다면, 라이브러리는 우리 기본 게이트웨이의 서브넷에 속하는 인터페이스를 활용합니다. 선택된 네트워크 인터페이스의 MAC 주소가 검색이 됩니다. 네트워크 라이브러리는 Data Link Layer(OSI Layer 2) 에 ARP요청을 보냅니다. ARP Request Sender MAC: interface:mac:address:here Sender IP: interface.ip.goes.here Target MAC: FF:FF:FF:FF:FF:FF (Broadcast) Target IP: target.ip.goes.here ARP Reply Sender MAC: target:mac:address:here Sender IP: target.ip.goes.here Target MAC: interface:mac:address:here Target IP: interface.ip.goes.here 이제 네트워크 라이브러리는 우리 DNS 서버나 DNS 프로세스를 재개할 수 있는 기본 게이트웨이 중 하나의 IP 주소를 갖고 있습니다 53번 포트는 DNS 서버에 UDP 요청을 보내기 위해 열려 있습니다 (만약 응답 크기가 너무 크다면, TCP가 대신 사용되구요). 로컬/ISP의 DNS 서버가 해당 정보를 갖고 있지 않다면, 재귀적인 탐색이 수행되고 SOA(Service-oriented architecture)가 도달해서 결과값이 되돌아올 때까지 DNS 서버 리스트를 타고 올라갑니다 5. 대상과 TCP 통신을 통해 Socket열기 HTTPS 프로토콜을 사용하므로 3-way handshake를 통하여 소켓을열고 TLS handshake 과정이 추가됩니다. TCP socket 생성 TCP 연결을 통해 클라이언트는 실행 중인 TLS protocol의 버전, 사용가능한 암호 세트, 사용할 수 있는 TLS 옵션 목록 등을 평문으로 보냅니다. 84ms : 서버는 통신할 때 사용 할 TLS의 버전을 선택하고, 클라이언트가 제공한 목록에서 암호 조합을 결정하고 인증서를 첨부해서 클라이언트에 보냅니다. 선택적으로 서버는 다른 TLS 확장에 대한 클라이언트 인증서 및 매개 변수에 대해 요청을 보낼 수도 있습니다. 양측이 공통된 버전과 암호를 협상 할 수 있고, 클라이언트가 서버에서 제공한 인증서에 만족하면, 클라이언트는 RSA 또는 Diffie-hellman 키 교환을 시작합니다. 이 교환은 이어지는 세션에서 사용할 대칭키를 설정합니다. 서버는 클라이언트가 전송한 키 교환 매개변수를 처리하고 MAC address을 확인하여 메시지 무결성을 검사하고 암호화 된 Finished message를 클라이언트에 전송합니다. 클라이언트를 협상 된 대칭키를 사용해 message 암호를 해독하고 MAC address를 확인해서 모두 정상이면 터널이 설정되고 통신을 시작합니다. TLS에 대해서는 이곳에 자세히 정리해 놓았습니다. 6. HTTP 프로토콜 구글이 만든 웹 브라우저라면, 페이지를 가져오기 위해 HTTP 요청을 보내는 대신, 서버에게 HTTP에서 SPDY로 “업그레이드”할 것을 협상해봅니다. SPDY란 구글은 더 빠른 Web을 실현하기 위해 Latency 관점에서 HTTP를 고속화한 SPDY(스피디) 라 불리는 새로운 프로토콜을 구현했습니다. SPDY는 HTTP를 대치하는 프로토콜이 아니고 HTTP를 통한 전송을 재 정의하는 형태로 구현 되어있습니다. SPDY는 실제로 HTTP/1.1에 비해 상당한 성능 향상과 효율성을 보여줬고 이는 HTTP/2 초안의 참고 규격이 되었다고 합니다. 만약 클라이언트가 SPDY를 지원하지 않고 HTTP만 쓴다면, 서버에 다으과 같은 요청을 보냅니다 GET / HTTP/1.1 Host: google.com Connection: close [other headers] [other headers] 부분은 HTTP 사양에 따라 콜론으로 구분되고 각각 새 줄로 나뉘는 일련의 키-값 쌍을 나타냅니다. (이 부분은 사용된 브라우저가 HTTP 스펙을 벗어나는 어떠한 버그도 없을 때를 가정해요. 웹 브라우저가 HTTP/1.1 을 쓴다는 것도 마찬가지인데, 그렇지 않을 경우엔 Host 헤더가 요청에 포함되지 않고 GET 요청에 명시된 버전이 HTTP/1.0 혹은 HTTP/0.9 일 수도 있습니다. ) HTTP/1.1은 송신자측에서 응답을 받은 직후에 연결이 끊어질 것이라는 신호를 보내기 위해 “close”라는 연결 옵션을 정의합니다. 아래의 예처럼 말이죠. Connection: close 영구 접속을 허용하지 않는 HTTP/1.1 어플리케이션은 반드시 “close” 연결 옵션을 모든 메시지에 포함해야 합니다. 요청과 헤더를 보낸 후에, 웹 브라우저는 하나의 빈 줄을 서버에 보내 요청 내용이 모두 보내졌음을 알립니다. 서버는 요청의 상태를 나타내는 코드와 다음과 같은 형태로 응답합니다. 200 OK [response headers] 이다음에 www.naver.com의 HTML컨텐츠를 payload에 실어서 보냅니다. 그 이후 서버는 연결을 종료할 수도있고, 클라이언트가 보낸 헤더가 요청한 경우 추가 요청을 위해 연결을 유지 할 수도 있습니다. 만약 웹 브라우저가 보낸 HTTP header에 웹 브라우저가 캐시한 파일의 버전이 마지막 검색이후 수정되지 않았으면(HTTP header의 ETag 값으로 확인) 서버에선 다음과 같이 응답합니다 304 Not Modified [response headers] 이 응답에서는 payload 가 없고 웹브라우저는 캐시에서 HTML을 검색합니다. HTML을 파싱한 후 웹 브라우저와 서버는 GET / HTTP/1.1요청이 아닌 HTML페이지에서 참조하는 모든 자원(Image, CSS, favicon.ico 등)에 대해 이 프로세스를 반복합니다. 만약 HTML이 다른 Domain의 resource를 참조하는 경우 웹 브라우저는 다른 도메인을 확인하는 단계(3번 단계)로 돌아가고 해당 도메인에 대해 모든 단계를 수행하고, Host 요청의 header는 해당 서버의 이름으로 설정됩니다. 7. HTTP 서버의 응답 HTTPD (HTTP 데몬) 서버는 서버측에서 요청/응답을 처리하는 친구입니다. 대표적으로 자주 쓰이는 nginx 가 있습니다. HTTPD (HTTP 데몬) 서버는 요청을 다음과 같은 파라미터들로 분리합니다. HTTP method(GET, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, HEAD 중 하나). 주소창에 URL을 직접 입력한 경우에는 GET 이겠죠 도메인, (naver.com). 요청된 경로/페이지 - (www.naver.com은 홈페이지입니다, 즉 특정 경로와 페이지가 없기에 기본경로인 ‘/’가 들어갑니다) 서버는 naver.com에 해당하는 가상 호스트가 서버에 설정되어 있는지 확인합니다. 서버는 naver.com이 GET 요청을 받아들일 수 있는지 봅니다. 서버는 해당 클라이언트에게 이 메소드가 허용되는지 봅니다 (IP, 인증, 기타 등등을 통하여). 만약에 서버에 rewrite 설정이 되어있다면 해당하는 경로로 다시 요청을 하게됩니다. (www로 시작하지 않는것을 www로 가게하거나 아래와 같이 http로 들어온 모든요청을 https로 rewrite 하기도 하죠) server { listen 80; server_name my.domain.com; rewrite ^(.*) https://$host$1 permanent; } server { listen 443; server_name my.domain.com; # ..... } 서버는 요청에 해당하는 콘텐츠를 가져오고, 기본경로인 “/” 이므로 이 경우 index파일을 해석합니다. 서버는 가져온 파일을 핸들러를 통해 분석하여 결과를 클라이언트로 보냅니다. 8. 브라우저 안에서 일어나는 일들 서버가 브라우저에 (HTML, CSS, JS, 이미지, …)을 제공하면 브라우저는 아래 프로세서를 수행합니다. 파싱 - HTML, CSS, JS 렌더링: DOM 트리 생성 -&amp;gt; 트리 렌더링 -&amp;gt; 렌더링 된 트리 배치 -&amp;gt; 렌더링 된 트리 색칠 웹 브라우저의 기능은 서버에서 요청하고 브라우저 창에 표시하여 선택한 웹 리소스를 표시하는 것입니다. 리소스는 일반적으로 HTML문서이지만 PDF, 이미지 또는 다른 유형의 콘텐츠일 수도 있습니다. 자원의 위치는 URI(Uniform Resource Identifier)를 사용하여 사용자가 지정합니다. 브라우저가 HTML파일을 해석하고 표시하는 방법은 HTML 및 CSS 사양에 지정되어 있습나다. 이 사양은 웹 표준 단체인 W3C(World Wide Web Consortium)에서 관리합니다. 브라우저의 일반적인 User Interface 요소 URI를 입력하기 위한 주소표시줄 뒤로 및 앞으로 버튼 북마크 버튼 새로고침 및 중지 버튼 홈페이지 이동 버튼 브라우저의 구성요소들 유저 인터페이스: 유저 인터페이스는 주소창, 뒤로/앞으로 버튼, 즐겨찾기 메뉴 등등을 포함합니다. 당신이 요청한 페이지를 보는 창을 제외한 브라우저의 모든 부분이죠. 브라우저 엔진: 브라우저 엔진은 UI와 렌더링 엔진 사이에 일어나는 일을 통제합니다. 렌더링 엔진: 렌더링 엔진은 요청된 내용을 보여주는 부분을 책임집니다. 예를 들어 만약 요청된 내용이 HTML이면, 렌더링 엔진은 HTML과 CSS를 분석하고, 처리된 내용을 화면에 띄워줍니다. 네트워킹: 네트워킹은 HTTP와 같은 네트워크 요청을, 플랫폼별로 다른 구현체를 활용해 플랫폼-독립적인 인터페이스 뒤에서 처리하죠. UI 백엔드: UI 백엔드는 콤보박스나 창 같은 기본적인 위젯을 그리는 데 쓰입니다. 이 백엔드는 플랫폼에 구애받지 않는 포괄적인 인터페이스를 노출시킵니다. 내부적으로는 운영 체제의 유저 인터페이스 메소드들을 활용하면서요. JavaScript 엔진: JavaScript 엔진은 JavaScript 코드를 분석하고 실행하는 데 활용됩니다. 데이터 저장소: 데이터 저장소는 유지가 되는 계층입니다. 브라우저가 쿠키같은 갖가지 종류의 데이터를 저장해둬야 할 수도 있거든요. 브라우저는 또 localStorage와 sessionStorage, IndexedDB, WebSQL, 파일시스템과 같은 저장 메커니즘을 지원합니다. HTML 파싱 렌더링 엔진은 네트워킹 계층에서 요청한 문서의 내용을 받아오기 시작합니다. 문서는 보통 8KB 단위로 전송됩니다. HTML 파서의 주된 역할은 HTML 마크업을 파스 트리로 분석해내는 겁니다. 이렇게 나온 트리 (“파스 트리 parse tree”) 는 DOM 요소와 속성 노드의 트리입니다. DOM은 Document Object Mode의 줄임말이고요. 이 친구는 HTML 문서와 HTML 요소를 JavaScript 같은 외부 요소와 이어주는 인터페이스의 객체 표현 방식입니다. 이 트리의 루트는 “Document” 객체입니다. 스크립트를 통한 모든 조작보다 앞서, DOM은 마크업과 거의 일대일인 관계를 갖습니다. 파싱 알고리즘 HTML은 일반적인 탑-다운이나 바텀-업 방식의 파서로는 분석할 수 없습니다. 그 이유는 아래오 같습니다. 관대한 언어적 특성. 브라우저는 흔히 알려진, 잘못된 HTML들을 지원하기 위해 전통적으로 에러를 용인해왔다는 사실. 파싱 과정은 재진입 가능하다는 것입니다. 다른 언어에서, 소스는 파싱 과정에서 변하지 않지만, HTML에서는, 동적 코드 (예를 들어 document.write() 호출을 담고 있는 스크립트 요소) 가 추가적인 토큰을 추가할 수도 있어서, 파싱 과정이 실제로 입력값을 바꿉니다. 일반적인 파싱 기술을 쓸 수 없으니, 브라우저는 임의의 파서를 활용해 HTML을 파싱합니다. 파싱 알고리즘은 아래와 같이 토큰화와 트리생성의 단계로 이루워 져있습니다. 자세한 정보는 이곳에서 확인가능합니다. 파싱이 끝난후의 동작 브라우저가 페이지에 링크돼있는 외부 자원 (CSS, 이미지, JavaScript 파일, 기타 등등) 을 가져오기 시작합니다. 이 단계에서 브라우저는 해당 문서가 상호작용 중이라는 표시를 해두고 “deferred” 모드에 있는 스크립트를 파싱하기 시작합니다: 반드시 문서를 분석한 후에 실행되어야 하는 것들이죠. 문서의 상태는 “complete” 으로 설정되고 “load” 이벤트가 발생됩니다. HTML 페이지에 “Invalid Syntax”에러는 존재하지 않습니다. 브라우저가 어떠한 내용이든 고치고 넘어갑니다. CSS 분석 &amp;lt;style&amp;gt; 태그 내용과, style 속성값으로 되어있는 CSS 파일들을 “CSS lexical and syntax grammar” 를 활용해 파싱합니다. 각각의 CSS 파일은 Stylesheet object 로 파싱되는데, 여기서 각 객체는 selector 및 CSS 문법에 해당하는 객체들과 함께 CSS 규칙들을 담고 있습니다. CSS 파서는 특정한 파서 생성기가 사용됐을 경우에 탑-다운이나 바텀-업도 가능합니다. 페이지 렌더링 DOM 노드를 탐색하고 각 노드에 대한 CSS 값을 계산하여 “Frame tree” 또는 “Render tree”를 만듭니다. 자식 노드의 width와 수평 margin, border, padding 을 합해서 Frame tree의 아래쪽에 있는 각 노드의 기본 너비를 계산합니다. 각 노드의 사용 가능한 너비를 자식 노드에 할당하여 각 노드의 실제 width 값 계산합니다. 텍스트 배치를 적용하고 하위 노드의 height와 margin, border, padding을 합해 각 노드의 높이를 상향식으로 계산합니다. 위에서 계산 된 정보를 사용해서 각 노드의 좌표를 계산합니다. float, absolutely, relatively 와 같은 속성이 사용되었을 경우 더 복잡한 단계가 수행 됩니다. 자세한건 http://dev.w3.org/csswg/css2/ 와 http://www.w3.org/Style/CSS/current-work 참조하세요 페이지의 어느 부분을 그룹으로 애니메이션화 할 수 있는지 설명하는 레이어를 만듭니다. frame/render object는 layer에 할당합니다 텍스처는 페이지의 각 레이어에 할당합니다 각 frame/render object를 통해서 각 레이어 별로 그리기 명령을 실행합니다. 위의 모든 단계를 웹페이지가 렌더링 된 마지막 시간에 계산 된 값을 재사용 할 수 있으므로 점진적 변경은 작업이 덜 필요합니다. 페이지 레이어는 합성 프로세스로 보내져 browser chrome, iframe, addon panels과 같은 시각적인 레이어와 결합됩니다. 최종 레이어 위치가 계산되고 Direct3D / OpenGL을 통해 합성 명령이 실행된다. GPU 명령 버퍼는 비동기 렌더링을 위해 GPU로 출력되고 frame은 window server로 전송됩니다. GPU 렌더링 렌더링 프로세스 동안 graphical computing layers는 CPU 또는 GPU를 사용할 수 있습니다. graphical rendering 계산에 GPU를 사용하는 경우 그래픽 소프트웨어 레이어에서 작업을 여러조각으로 분할하여 렌더링 프로세스에 필요한 부동 소수점 계산을 위해 GPU 대용량 병렬 처리를 사용 할 수 있습니다. 렌더링이 완료된 후 브라우저는 Javascript 실행을 통해 DOM과 CSSOM이 변경 될 수 있는데 레이아웃이 수정 되는 경우 페이지 렌더링 및 페인팅을 다시 수행합니다.</summary></entry><entry><title type="html">[ #2 ] 스키마의 사용</title><link href="https://shjeong92.github.io/2021/07/03/Database-02.html" rel="alternate" type="text/html" title="[ #2 ] 스키마의 사용" /><published>2021-07-03T00:00:00+09:00</published><updated>2021-07-03T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/07/03/Database-02</id><content type="html" xml:base="https://shjeong92.github.io/2021/07/03/Database-02.html">&lt;h3 id=&quot;1-데이터베이스스키마-생성&quot;&gt;1. 데이터베이스(스키마) 생성&lt;/h3&gt;

&lt;h4 id=&quot;문법&quot;&gt;문법&lt;/h4&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE DATABASE &amp;lt;DB이름&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;예제&quot;&gt;예제&lt;/h4&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; CREATE DATABASE opentutorials&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
Query OK, 1 row affected &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.01 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-데이터베이스스키마-삭제&quot;&gt;2. 데이터베이스(스키마) 삭제&lt;/h3&gt;

&lt;h4 id=&quot;문법-1&quot;&gt;문법&lt;/h4&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP DATABASE &amp;lt;DB이름&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;예제-1&quot;&gt;예제&lt;/h4&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; DROP DATABASE opentutorials&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
Query OK, 0 rows affected &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.01 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-데이터베이스스키마-리스트-확인하기&quot;&gt;3. 데이터베이스(스키마) 리스트 확인하기&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; SHOW DATABASES&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
+--------------------+
| Database           |
+--------------------+
| information&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;schema |
| mysql              |
| opentutorials      |
| performance&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;schema |
| sys                |
+--------------------+
5 rows &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0.00 sec&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아까 생성한 opentutorials를 확인할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;4-데이터베이스스키마-사용하기&quot;&gt;4. 데이터베이스(스키마) 사용하기&lt;/h3&gt;

&lt;h4 id=&quot;문법-2&quot;&gt;문법&lt;/h4&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;USE &amp;lt;DB이름&amp;gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;예제-2&quot;&gt;예제&lt;/h4&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; USE opentutorials&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
Database changed
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 해주면 opentutorials에 있는 tables에 대하여 명령어를 실행할 수 있습니다.&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Database" /><category term="MySQL" /><category term="Schema" /><summary type="html">1. 데이터베이스(스키마) 생성 문법 CREATE DATABASE &amp;lt;DB이름&amp;gt; 예제 mysql&amp;gt; CREATE DATABASE opentutorials; Query OK, 1 row affected (0.01 sec) 2. 데이터베이스(스키마) 삭제 문법 DROP DATABASE &amp;lt;DB이름&amp;gt; 예제 mysql&amp;gt; DROP DATABASE opentutorials; Query OK, 0 rows affected (0.01 sec) 3. 데이터베이스(스키마) 리스트 확인하기 mysql&amp;gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | opentutorials | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) 아까 생성한 opentutorials를 확인할 수 있습니다. 4. 데이터베이스(스키마) 사용하기 문법 USE &amp;lt;DB이름&amp;gt;; 예제 mysql&amp;gt; USE opentutorials; Database changed 이렇게 해주면 opentutorials에 있는 tables에 대하여 명령어를 실행할 수 있습니다.</summary></entry><entry><title type="html">[ #1 ] MySQL의 구조</title><link href="https://shjeong92.github.io/2021/07/03/Database-01.html" rel="alternate" type="text/html" title="[ #1 ] MySQL의 구조" /><published>2021-07-03T00:00:00+09:00</published><updated>2021-07-03T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/07/03/Database-01</id><content type="html" xml:base="https://shjeong92.github.io/2021/07/03/Database-01.html">&lt;p&gt;이때까지는 데이터베이스를 단순히 사용만 해왔었는데요, 알고 제대로 써야겠다고 생각하여 기초부터 공부해려고 합니다.&lt;/p&gt;

&lt;p&gt;본 포스팅은 유튜브 &lt;a href=&quot;https://www.youtube.com/channel/UCvc8kv-i5fvFTJBFAk6n1SA&quot;&gt;생활코딩&lt;/a&gt;님의 데이터베이스 강좌를 보고 정리한 내용입니다.&lt;/p&gt;

&lt;h3 id=&quot;1-mysql의-구조&quot;&gt;1. MySQL의 구조&lt;/h3&gt;
&lt;p&gt;관계형 데이터베이스는 엑셀과 같은 스프레드시트에 데이터를 저장합니다 즉 표에 정보가 저장된다는 말인데요.&lt;/p&gt;

&lt;p&gt;표(Table)가 많아진다면?&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;정리될 필요성이 생김(파일에서 디렉토리가 필요한 상황이 생기는것과 같음)
MySql에서는 서로 연관된 표들을 그루핑해서 연관되어있지 않은 표들과 구분짓는 폴더가있는데 이를 database라 칭합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Schema(database)는 표들을 그루핑할때 사용되는 일종의 폴더와 같습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Schema 는 서로 연관된 데이터들을 그루핑 해준다는 것을 기억해줍시다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;반면에 PostgreSQL에서는 이를 Mysql에서의 database는 Schema라고 불리우며 PostgreSQL 에서 database는 schema의 상위 개념입니다. Postgres에서의 database는 Mysql 에서는 database server과 같습니다. 헷갈릴 수 있으니 유의합시다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그림으로 보면 아래와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/124347638-a594f900-dc20-11eb-863a-00c4aa3ea5e3.png&quot; alt=&quot;mysql구조&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-db-사용의-장점&quot;&gt;2. DB 사용의 장점&lt;/h3&gt;
&lt;p&gt;데이터베이스는 자체적인 안전 체계가 있기에 데이터를 안전하게 보관할 수 있습니다&lt;/p&gt;

&lt;p&gt;권한 기능이 있어, MySQL에 여러사람들을 등록할 수 있고 특정 롤을 지정해줄 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;3-mysql-서버-접속&quot;&gt;3. MySQL 서버 접속&lt;/h3&gt;
&lt;p&gt;brew를 통해서 처음 mysql을 설치하면 root에 password가 설정되어있지 않은데 이를 설정해봅시다&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;먼저 MySQL은 멈춰있어야 합니다. 아래 커맨드를 입력해 종료해 줍시다.
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew services stop mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;그다음 mysql을 안전모드로 실행합니다.
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;mysqld_safe &lt;span class=&quot;nt&quot;&gt;--skip-grant-tables&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;터미널을 하나 더 열고 password를 초기화해줍니다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root
UPDATE mysql.user SET authentication_string=null 
WHERE User=&apos;root&apos;;
FLUSH PRIVILEGES;
exit;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;마지막으로 새로운 비밀번호를 설정해주면 끝입니다.
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -u root
ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH caching_sha2_password BY &apos;yourpasswd&apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;비밀번호와 함께 서버접속 하기
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;mysql &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;
Enter password: &amp;lt;yourpassword&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Database" /><category term="MySQL" /><summary type="html">이때까지는 데이터베이스를 단순히 사용만 해왔었는데요, 알고 제대로 써야겠다고 생각하여 기초부터 공부해려고 합니다. 본 포스팅은 유튜브 생활코딩님의 데이터베이스 강좌를 보고 정리한 내용입니다. 1. MySQL의 구조 관계형 데이터베이스는 엑셀과 같은 스프레드시트에 데이터를 저장합니다 즉 표에 정보가 저장된다는 말인데요. 표(Table)가 많아진다면? 정리될 필요성이 생김(파일에서 디렉토리가 필요한 상황이 생기는것과 같음) MySql에서는 서로 연관된 표들을 그루핑해서 연관되어있지 않은 표들과 구분짓는 폴더가있는데 이를 database라 칭합니다. Schema(database)는 표들을 그루핑할때 사용되는 일종의 폴더와 같습니다. Schema 는 서로 연관된 데이터들을 그루핑 해준다는 것을 기억해줍시다. 반면에 PostgreSQL에서는 이를 Mysql에서의 database는 Schema라고 불리우며 PostgreSQL 에서 database는 schema의 상위 개념입니다. Postgres에서의 database는 Mysql 에서는 database server과 같습니다. 헷갈릴 수 있으니 유의합시다. 그림으로 보면 아래와 같습니다. 2. DB 사용의 장점 데이터베이스는 자체적인 안전 체계가 있기에 데이터를 안전하게 보관할 수 있습니다 권한 기능이 있어, MySQL에 여러사람들을 등록할 수 있고 특정 롤을 지정해줄 수 있습니다. 3. MySQL 서버 접속 brew를 통해서 처음 mysql을 설치하면 root에 password가 설정되어있지 않은데 이를 설정해봅시다 먼저 MySQL은 멈춰있어야 합니다. 아래 커맨드를 입력해 종료해 줍시다. $ brew services stop mysql 그다음 mysql을 안전모드로 실행합니다. $ sudo mysqld_safe --skip-grant-tables 터미널을 하나 더 열고 password를 초기화해줍니다. mysql -u root UPDATE mysql.user SET authentication_string=null WHERE User=&apos;root&apos;; FLUSH PRIVILEGES; exit; 마지막으로 새로운 비밀번호를 설정해주면 끝입니다. mysql -u root ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH caching_sha2_password BY &apos;yourpasswd&apos;; 비밀번호와 함께 서버접속 하기 $ mysql -u root -p Enter password: &amp;lt;yourpassword&amp;gt;</summary></entry><entry><title type="html">[ #3 ] SQL과 테이블의 구조</title><link href="https://shjeong92.github.io/2021/07/03/Database-03.html" rel="alternate" type="text/html" title="[ #3 ] SQL과 테이블의 구조" /><published>2021-07-03T00:00:00+09:00</published><updated>2021-07-03T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/07/03/Database-03</id><content type="html" xml:base="https://shjeong92.github.io/2021/07/03/Database-03.html">&lt;h3 id=&quot;sql이란&quot;&gt;SQL이란&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;S&lt;/strong&gt;tructured&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q&lt;/strong&gt;uery&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;L&lt;/strong&gt;anguage&lt;/p&gt;

&lt;p&gt;의 약자이며 아래와 같은 특징을 가집니다.&lt;/p&gt;

&lt;h4 id=&quot;특징&quot;&gt;특징&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;SQL은 어떤 컴퓨터 언어보다 쉽습니다.&lt;/li&gt;
  &lt;li&gt;관계형 데이터베이스라는 카테고리에 속하는 제품들이 공통적으로 데이터베이스서버를 제어할 때 쓰이는 표준화된 언어이기에 매우 중요합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;-&amp;gt; 가성비가 뛰어난 언어&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;table의-구조&quot;&gt;Table의 구조&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/124349489-37edca80-dc2a-11eb-8d12-e06ccb15b158.png&quot; alt=&quot;table&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;row&lt;/strong&gt;: 데이터 그자체&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;column&lt;/strong&gt;: 데이터의 구조&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;mysql-data-타입&quot;&gt;MySQL Data 타입&lt;/h3&gt;

&lt;p&gt;MySQL에서 쓸 수 있는 데이터 타입은 아래의 표와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;&lt;center&gt;형태&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;데이터형&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;범위&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;크기&lt;/center&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;숫자형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TINYINT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-128 ~ 128,  0 ~ 255&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SMALLINT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-32768 ~ 32767 , 0 ~ 65535&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;2 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MEDIUMINT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-8388608 ~ 8388607, 0 ~ 16777215&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;INT, INTEGER&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-2147483648 ~ 2147483647, 0 ~ 4294967295&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BIGINT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-9223372036854775808 ~ 9223372036854775807 ,&lt;br /&gt; 0 ~ 18446744073709551615&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FLOAT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;-3.402823466E+38 ~ -1.175494351E-38 ,&lt;br /&gt; 1.175494351E-38 ~ 3.402823466E+38&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DOUBLE [PRECISION], REAL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1.7976931348623157E+308 ~ -2.2250738585072014E-308 ,&lt;br /&gt; 0 ~ 2.2250738585072014E-308&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DECIMAL(M,D), NUMERIC(M,D)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;데이터 베이스 설정 및 시스템에 따라 다름&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;가변적 크기&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;날짜형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DATE&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;‘1000-01-01’ ~ ‘9999-12-31’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TIME&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;‘-838:59:59’ ~ ‘838:59:59’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;3 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;DATETIME&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;‘1000-01-01 00:00:00’ &lt;br /&gt;~ ‘9999-12-31 23:59:59’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;8 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TIMESTAMP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;‘1970-01-01 00:00:01’ &lt;br /&gt;~ ‘2038-01-19 03:14:07’&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;4 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;YEAR&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1901 ~ 2155&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;문자(열)형&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;CHAR(M)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1~ 255 개의 문자&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;M &amp;lt;= 255&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ByteBINARY(M)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 ~ 255 개의 문자&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;M Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;VARCHAR(M),&lt;br /&gt;VARBINARY(M)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 ~ 255 개의 문자&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;M Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;TINYBLOB, TINYTEXT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;최대 2^8&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;입력된 길이 만큼&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;BLOB, TEXT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;최대 2^16입&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;력된 길이 만큼&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;MEDIUMBLOB, MEDIUMTEXT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;최대 2^24&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;입력된 길이 만큼&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;LONGBLOB, LONGTEXT&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;최대 2^32&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;입력된 길이 만큼&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ENUM&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;최대 65525 개&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 ~ 2 Byte&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;^^&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;SET&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;최대 64 개의 셋&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;1 ~ 8 Byte&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;무조건 큰 범위의 큰 값을 사용하게되면 편하긴 하겠지만, 그만큼 저장공간을 차지하며, 느려질 수도 있기에 적절히 알맞은 타입을 선택해야합니다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;여러가지-제약조건&quot;&gt;여러가지 제약조건&lt;/h3&gt;
&lt;p&gt;테이블을 작성할때에 컬럼별로 다양한 제약조건을 작성할 수 있는데 아래와 같은 제약 조건들이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;NOT NULL&lt;/strong&gt; : 해당컬럼은 비어있을 수 없습니다.
    &lt;ul&gt;
      &lt;li&gt;EX) VALUE1 VARCHAR2(10) NOT NULL&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;NULL&lt;/strong&gt; : 해당 컬럼은 비어있어도 상관 없습니다.
    &lt;ul&gt;
      &lt;li&gt;EX) VALUE1 VARCHAR2(10) NULL
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;AUTO_INCREMENT&lt;/strong&gt; : 값이 생성될때마다 값을 자동으로 1씩 증가시켜 줍니다.
    &lt;ul&gt;
      &lt;li&gt;EX) id INT(11) INCREMENT
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;UNIQUE&lt;/strong&gt; : NULL은 허용하지만 중복은 불가능합니다.
    &lt;ul&gt;
      &lt;li&gt;EX) VALUE2 VARCHAR2(10) UNIQUE
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;PRIMARY KEY&lt;/strong&gt; : NULL, 중복 둘다 불가능합니다.
    &lt;ul&gt;
      &lt;li&gt;EX) VALUE3 VARCHAR2(10) PRIMARY KEY&lt;/li&gt;
      &lt;li&gt;EX) PRIMARY KEY id (이미 생성된 컬럼에한해서)
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;FOREIGN KEY&lt;/strong&gt; : NULL가능, 다른 테이블의 PRIMARY KEY여야 하고 해당 테이블의 컬럼에 삽입되지 않은 값은 사용 불가능합니다.
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;CHECK&lt;/strong&gt; : 특정 범위 혹은 특정 값만 들어올 수 있게 합니다.
    &lt;ul&gt;
      &lt;li&gt;EX) VALUE5 VARCHAR2(10) CHECK(VALUE5 BETWEEN 1 AND 10)&lt;/li&gt;
      &lt;li&gt;EX) VALUE6 VARCHAR2(10) CHECK(VALUE6 IN (‘A’, ‘B’)) 
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;DEFAULT&lt;/strong&gt; : NULL 값이 들어올 시 지전된 값을 삽입합니다.
    &lt;ul&gt;
      &lt;li&gt;EX) VALUE7 VARCHAR2(10) DEFAULT ‘홍길동’&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;table-생성해보기&quot;&gt;Table 생성해보기&lt;/h3&gt;

&lt;p&gt;아래와 같이 스프레드 시트에있는 테이블을
mysql에서 만들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/124349491-3a502480-dc2a-11eb-8ad3-9b70c53ced83.png&quot; alt=&quot;dataonssheet&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-s highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;CREATE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TABLE&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOT&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOT&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TEXT&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;created&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DATETIME&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NOT&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;author&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;profile&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PRIMARY&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KEY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Database" /><category term="MySQL" /><summary type="html">SQL이란 Structured Query Language 의 약자이며 아래와 같은 특징을 가집니다. 특징 SQL은 어떤 컴퓨터 언어보다 쉽습니다. 관계형 데이터베이스라는 카테고리에 속하는 제품들이 공통적으로 데이터베이스서버를 제어할 때 쓰이는 표준화된 언어이기에 매우 중요합니다. -&amp;gt; 가성비가 뛰어난 언어 Table의 구조 row: 데이터 그자체 column: 데이터의 구조 MySQL Data 타입 MySQL에서 쓸 수 있는 데이터 타입은 아래의 표와 같습니다. 형태 데이터형 범위 크기 숫자형 TINYINT -128 ~ 128, 0 ~ 255 1 Byte ^^ SMALLINT -32768 ~ 32767 , 0 ~ 65535 2 Byte ^^ MEDIUMINT -8388608 ~ 8388607, 0 ~ 16777215 3 Byte ^^ INT, INTEGER -2147483648 ~ 2147483647, 0 ~ 4294967295 4 Byte ^^ BIGINT -9223372036854775808 ~ 9223372036854775807 , 0 ~ 18446744073709551615 8 Byte ^^ FLOAT -3.402823466E+38 ~ -1.175494351E-38 , 1.175494351E-38 ~ 3.402823466E+38 4 Byte ^^ DOUBLE [PRECISION], REAL 1.7976931348623157E+308 ~ -2.2250738585072014E-308 , 0 ~ 2.2250738585072014E-308 8 Byte ^^ DECIMAL(M,D), NUMERIC(M,D) 데이터 베이스 설정 및 시스템에 따라 다름 가변적 크기 날짜형 DATE ‘1000-01-01’ ~ ‘9999-12-31’ 3 Byte ^^ TIME ‘-838:59:59’ ~ ‘838:59:59’ 3 Byte ^^ DATETIME ‘1000-01-01 00:00:00’ ~ ‘9999-12-31 23:59:59’ 8 Byte ^^ TIMESTAMP ‘1970-01-01 00:00:01’ ~ ‘2038-01-19 03:14:07’ 4 Byte ^^ YEAR 1901 ~ 2155 1 Byte 문자(열)형 CHAR(M) 1~ 255 개의 문자 M &amp;lt;= 255 ^^ ByteBINARY(M) 1 ~ 255 개의 문자 M Byte ^^ VARCHAR(M),VARBINARY(M) 1 ~ 255 개의 문자 M Byte ^^ TINYBLOB, TINYTEXT 최대 2^8 입력된 길이 만큼 ^^ BLOB, TEXT 최대 2^16입 력된 길이 만큼 ^^ MEDIUMBLOB, MEDIUMTEXT 최대 2^24 입력된 길이 만큼 ^^ LONGBLOB, LONGTEXT 최대 2^32 입력된 길이 만큼 ^^ ENUM 최대 65525 개 1 ~ 2 Byte ^^ SET 최대 64 개의 셋 1 ~ 8 Byte 무조건 큰 범위의 큰 값을 사용하게되면 편하긴 하겠지만, 그만큼 저장공간을 차지하며, 느려질 수도 있기에 적절히 알맞은 타입을 선택해야합니다. 여러가지 제약조건 테이블을 작성할때에 컬럼별로 다양한 제약조건을 작성할 수 있는데 아래와 같은 제약 조건들이 있습니다. NOT NULL : 해당컬럼은 비어있을 수 없습니다. EX) VALUE1 VARCHAR2(10) NOT NULL NULL : 해당 컬럼은 비어있어도 상관 없습니다. EX) VALUE1 VARCHAR2(10) NULL AUTO_INCREMENT : 값이 생성될때마다 값을 자동으로 1씩 증가시켜 줍니다. EX) id INT(11) INCREMENT UNIQUE : NULL은 허용하지만 중복은 불가능합니다. EX) VALUE2 VARCHAR2(10) UNIQUE PRIMARY KEY : NULL, 중복 둘다 불가능합니다. EX) VALUE3 VARCHAR2(10) PRIMARY KEY EX) PRIMARY KEY id (이미 생성된 컬럼에한해서) FOREIGN KEY : NULL가능, 다른 테이블의 PRIMARY KEY여야 하고 해당 테이블의 컬럼에 삽입되지 않은 값은 사용 불가능합니다. CHECK : 특정 범위 혹은 특정 값만 들어올 수 있게 합니다. EX) VALUE5 VARCHAR2(10) CHECK(VALUE5 BETWEEN 1 AND 10) EX) VALUE6 VARCHAR2(10) CHECK(VALUE6 IN (‘A’, ‘B’)) DEFAULT : NULL 값이 들어올 시 지전된 값을 삽입합니다. EX) VALUE7 VARCHAR2(10) DEFAULT ‘홍길동’ Table 생성해보기 아래와 같이 스프레드 시트에있는 테이블을 mysql에서 만들어 보겠습니다. CREATE TABLE topic( id INT(11) NOT NULL AUTO_INCREMENT, title VARCHAR(100) NOT NULL, description TEXT NULL, created DATETIME NOT NULL, author VARCHAR(15) NULL, profile VARCHAR(200) NULL, PRIMARY KEY(id) );</summary></entry><entry><title type="html">첫 면접</title><link href="https://shjeong92.github.io/2021/07/01/Interview-01.html" rel="alternate" type="text/html" title="첫 면접" /><published>2021-07-01T00:00:00+09:00</published><updated>2021-07-01T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/07/01/Interview-01</id><content type="html" xml:base="https://shjeong92.github.io/2021/07/01/Interview-01.html">&lt;p&gt;오랜만의 포스팅 입니다.&lt;/p&gt;

&lt;p&gt;저는 이때까지 서류를 붙어본적이 없습니다.&lt;/p&gt;

&lt;p&gt;4월에는 프로그래머스 데브매칭에서 코딩테스트를 치고, 다섯 군데 지원된 서류는 모두 탈락이었습니다.&lt;/p&gt;

&lt;p&gt;서류가 많이 부족했었던 것이겠죠. 남들이 다 가지고 있는 프로젝트 경험, 클라우드 경험, 개발 관련 블로그가 없어서이었던 같았기에 이에 관련된 것을 준비하였는데, 그 과정에서 개발 블로그 작성은 정말 도움이 많이 되었던 것 같습니다.&lt;/p&gt;

&lt;p&gt;우선, 공부한 내용을 다시 복기하면서 그 내용을 더 오래 기억할 수 있었고, 설령 까먹더라도 다시 블로그에 들어오면 빠르게 리마인드가 되었기 때문입니다.&lt;/p&gt;

&lt;p&gt;저는 리액트와 장고를 이용하여 2개의 토이프로젝트 및 CKA 자격증 취득 이후에 다시 백엔드 직군으로 입사지원서를 넣었고, 처음으로 서류들이 합격하는 신기한 일이 생겼습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;그리고 오늘은 &lt;strong&gt;첫 면접&lt;/strong&gt;을 보았습니다.&lt;/p&gt;

&lt;p&gt;면접관님께서는 회사에 대해 간단히 소개해 주셨고, 저에게 간단한 자기소개를 부탁하셨습니다.&lt;/p&gt;

&lt;p&gt;어찌나 떨리던지 심장이 터지는 줄 알았습니다.&lt;/p&gt;

&lt;p&gt;그리고 전혀 간단하지 않고 장황한 자기소개를 하였습니다..&lt;/p&gt;

&lt;p&gt;여러 가지 질문들을 받았는데 순서는 뒤죽박죽이지만 나열해 보자면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;restful api 란&lt;/li&gt;
  &lt;li&gt;restful api 에서 관련된 자원을 명시하는 이유&lt;/li&gt;
  &lt;li&gt;restful 이외의 프로토콜&lt;/li&gt;
  &lt;li&gt;Covid19 관련 프로젝트 진행중 어려운점은 없었는지&lt;/li&gt;
  &lt;li&gt;쿠버네티스를 어떻게 이해하고 있는지&lt;/li&gt;
  &lt;li&gt;Loadbalancing 알고리즘에는 어떠한 것들이 있는지&lt;/li&gt;
  &lt;li&gt;특정 웹사이트를 들어가면 접속하면 일어나는 일&lt;/li&gt;
  &lt;li&gt;ssh란 무엇인지, 무엇을 할때 쓰이는지&lt;/li&gt;
  &lt;li&gt;osi 7계층에대해서 설명할 수 있는지&lt;/li&gt;
  &lt;li&gt;DNS&lt;/li&gt;
  &lt;li&gt;쉘은 무엇인지&lt;/li&gt;
  &lt;li&gt;도스와 윈도우의 차이점은 무엇인지&lt;/li&gt;
  &lt;li&gt;포트는 무엇인지&lt;/li&gt;
  &lt;li&gt;etcd 는 무엇인지&lt;/li&gt;
  &lt;li&gt;key value쌍을 이용한 다른 DB는 무엇이있는지, 어떠한 차이점이있고 언제 쓰이는지&lt;/li&gt;
  &lt;li&gt;DB index란&lt;/li&gt;
  &lt;li&gt;데이터베이스의 구조&lt;/li&gt;
  &lt;li&gt;네트워크 관련 질문&lt;/li&gt;
  &lt;li&gt;리눅스 네임스페이스&lt;/li&gt;
  &lt;li&gt;도커 네트워크관련&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;이번-면접에서-느낀점&quot;&gt;이번 면접에서 느낀점&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;암기하지말고 진짜 이해를 해야합니다.&lt;/li&gt;
  &lt;li&gt;CS지식 공부 너무너무너무 중요합니다.&lt;/li&gt;
  &lt;li&gt;도커,쿠버네티스 이러한 기술을 사용하기 이전에 그에 바탕이되는 기본 개념을 알아야 합니다.&lt;/li&gt;
  &lt;li&gt;면접 복장은 무조건 정해준대로 입는게 좋습니다.&lt;/li&gt;
  &lt;li&gt;공부는 끝이 없습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;공부할것&quot;&gt;공부할것!&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;운영체제&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;네트워크&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;데이터베이스&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="backend" /><category term="면접" /><category term="질문" /><summary type="html">오랜만의 포스팅 입니다. 저는 이때까지 서류를 붙어본적이 없습니다. 4월에는 프로그래머스 데브매칭에서 코딩테스트를 치고, 다섯 군데 지원된 서류는 모두 탈락이었습니다. 서류가 많이 부족했었던 것이겠죠. 남들이 다 가지고 있는 프로젝트 경험, 클라우드 경험, 개발 관련 블로그가 없어서이었던 같았기에 이에 관련된 것을 준비하였는데, 그 과정에서 개발 블로그 작성은 정말 도움이 많이 되었던 것 같습니다. 우선, 공부한 내용을 다시 복기하면서 그 내용을 더 오래 기억할 수 있었고, 설령 까먹더라도 다시 블로그에 들어오면 빠르게 리마인드가 되었기 때문입니다. 저는 리액트와 장고를 이용하여 2개의 토이프로젝트 및 CKA 자격증 취득 이후에 다시 백엔드 직군으로 입사지원서를 넣었고, 처음으로 서류들이 합격하는 신기한 일이 생겼습니다. 그리고 오늘은 첫 면접을 보았습니다. 면접관님께서는 회사에 대해 간단히 소개해 주셨고, 저에게 간단한 자기소개를 부탁하셨습니다. 어찌나 떨리던지 심장이 터지는 줄 알았습니다. 그리고 전혀 간단하지 않고 장황한 자기소개를 하였습니다.. 여러 가지 질문들을 받았는데 순서는 뒤죽박죽이지만 나열해 보자면, restful api 란 restful api 에서 관련된 자원을 명시하는 이유 restful 이외의 프로토콜 Covid19 관련 프로젝트 진행중 어려운점은 없었는지 쿠버네티스를 어떻게 이해하고 있는지 Loadbalancing 알고리즘에는 어떠한 것들이 있는지 특정 웹사이트를 들어가면 접속하면 일어나는 일 ssh란 무엇인지, 무엇을 할때 쓰이는지 osi 7계층에대해서 설명할 수 있는지 DNS 쉘은 무엇인지 도스와 윈도우의 차이점은 무엇인지 포트는 무엇인지 etcd 는 무엇인지 key value쌍을 이용한 다른 DB는 무엇이있는지, 어떠한 차이점이있고 언제 쓰이는지 DB index란 데이터베이스의 구조 네트워크 관련 질문 리눅스 네임스페이스 도커 네트워크관련 이번 면접에서 느낀점 암기하지말고 진짜 이해를 해야합니다. CS지식 공부 너무너무너무 중요합니다. 도커,쿠버네티스 이러한 기술을 사용하기 이전에 그에 바탕이되는 기본 개념을 알아야 합니다. 면접 복장은 무조건 정해준대로 입는게 좋습니다. 공부는 끝이 없습니다. 공부할것! 운영체제 네트워크 데이터베이스</summary></entry><entry><title type="html">[ #12 ] 클러스터 보안 - 3</title><link href="https://shjeong92.github.io/2021/06/10/Learning-Kubernetes-12.html" rel="alternate" type="text/html" title="[ #12 ] 클러스터 보안 - 3" /><published>2021-06-10T00:00:00+09:00</published><updated>2021-06-10T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/10/Learning-Kubernetes-12</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/10/Learning-Kubernetes-12.html">&lt;h2 id=&quot;1-tls가-제공하는-이점들&quot;&gt;1. TLS가 제공하는 이점들&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;기밀성-암호화&quot;&gt;기밀성 (암호화)&lt;/h3&gt;
    &lt;p&gt;이전 포스팅에서 공부했던 암호화에 해당하는 항목입니다.&lt;/p&gt;

    &lt;p&gt;서버와 주고 받는 데이터가 스니핑👀 되는 것을 방지합니다.&lt;/p&gt;

    &lt;p&gt;패킷이 오가는 것을 훔쳐 볼 순 있어도 안전하게 암호화 된 패킷이라 복호화 할 수 없기 떄문에&lt;/p&gt;

    &lt;p&gt;데이터는 훔쳐볼 수 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;데이터-무결성&quot;&gt;데이터 무결성&lt;/h3&gt;
    &lt;p&gt;통신 도중 데이터가 제 3자에 의해 악의로 변경될 일이 없습니다.&lt;/p&gt;

    &lt;p&gt;1번 기밀성과 같은 선상에서 보시면 됩니다.&lt;/p&gt;

    &lt;p&gt;서로의 대칭키를 RSA 알고리즘을 통해 안전하게 공유한 후에 암호화하여 통신하기 때문에&lt;/p&gt;

    &lt;p&gt;제 3자가 대칭키를 알아내지 않는 한 중간에서 암호화된 데이터를 임의로 수정하지 못하겠죠.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;서버-인증&quot;&gt;서버 인증&lt;/h3&gt;
    &lt;p&gt;1, 2번은 지난 포스팅에 공부했던 암호화 알고리즘을 통해 가능하다고 보여져요.&lt;/p&gt;

    &lt;p&gt;근데  만약 위의 암호화 방식으로만 서버와 클라이언트가 통신을 한다고 가정해 봅시다.&lt;/p&gt;

    &lt;p&gt;서버와 나는 암호화를 통해 통신하기 때문에 아무도 데이터를 훔쳐볼 수도 건들 수도 없겠지!&lt;/p&gt;

    &lt;p&gt;여기까지도 좋습니다 근데 만약 서버가 신뢰할 수 없는 서버라면 얘기가 달라지겠지요?&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;요즘 웹 브라우저에 성가신 팝업이 표시되는 경우&lt;/p&gt;

    &lt;p&gt;웹을 탐색하는 도중에 무료 경품을 제공한다거나 기기에 문제가 있다고 경고하는 팝업이나 알림이 표시되는 경험은 한번씩 해 보셨을거라고 생각합니다.&lt;/p&gt;

    &lt;p&gt;이러한 유형의 팝업은 대개 사기성 광고이며, 사용자를 속여 사기꾼에게 개인 정보나 돈을 제공하도록 하기 위해 만들어졌습니다.&lt;/p&gt;

    &lt;p&gt;이런 서버에 아무리 암호화된 데이터를 보낸다 한들 서버가 사기꾼놈의 서버라면 정말 큰 문제지요.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;이처럼, 서버와 클라이언트 간 통신을 할 때는&lt;/p&gt;

    &lt;p&gt;서버가 신뢰할 수 있는 서버라는 것을 확인하는 작업이 필요합니다.&lt;/p&gt;

    &lt;p&gt;이럴 때 사용하는 것이 바로 &lt;strong&gt;‘인증서’&lt;/strong&gt; 입니다!!!&lt;/p&gt;

    &lt;p&gt;이번에 공부할 포스팅에서 왜 인증서라는 것에 대해 공부하는지 이제 아시겠죠?&lt;/p&gt;

    &lt;p&gt;자 그럼 이제 시작해 봅시다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-인증서란-&quot;&gt;2. 인증서란 ?&lt;/h2&gt;

&lt;p&gt;인증서라는 것이 무엇일까요? 이름부터 이미 감이 오지 않나요?&lt;/p&gt;

&lt;p&gt;바로 위에서 서버가 &lt;strong&gt;신뢰할 수 있는 진짜 서버 임을 확인하기 위해 필요한 것&lt;/strong&gt;이 바로  &lt;strong&gt;인증서&lt;/strong&gt; 입니다!&lt;/p&gt;

&lt;p&gt;인증서에는 다음과 같은 정보들을 포함하고 있습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;서비스 정보(인증서를 발급한 CA, 서비스의 도메인 등)&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;서버 측 공개키(공개키, 공개키 암호화 방법)&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;지문, 디지털 서명 등&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여러분이 지금 보고계신 이 블로그도 인증서를 가지고 있답니다.&lt;/p&gt;

&lt;p&gt;주소창의 가장 왼쪽에 🔒 보이시나요?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
  &lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121352044-651ac600-c967-11eb-8060-8ae61c7b66db.png&quot; /&gt;
  &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;자물쇠가 잠겨있다는 건 이전 포스팅에서 공부했던 HTTPS 통신이라는 뜻입니다 보안되어 있다는 말이지요&lt;/p&gt;

&lt;p&gt;제 블로그는 GitHub Pages를 통해 만들어졌는데요 개인 도메인도 무료로 HTTPS를 지원하지요.&lt;/p&gt;

&lt;p&gt;그럼 깃헙의 인증서를 한번 들여다 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121352050-677d2000-c967-11eb-9a37-7c9525bdc5fe.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121352053-6815b680-c967-11eb-9393-6580c47f3634.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121352060-68ae4d00-c967-11eb-9fb3-fe167317905d.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞서 말했듯 서버의 공개키, 서명, 지문, 발급자 정보 등이 포함되어 있는것을 확인할수 있습니다!&lt;/p&gt;

&lt;p&gt;이것들이 인증서에서 어떤 역할을 하는지는 차차 알아봅시다.&lt;/p&gt;

&lt;p&gt;그러기 전에 먼저,&lt;/p&gt;

&lt;p&gt;이 인증서는 어디서 어떻게 생성할까요?&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-ca-certificate-authority&quot;&gt;3. CA (Certificate Authority)&lt;/h2&gt;

&lt;p&gt;CA는 인증서를 발급해주는 기관으로, Root Certificate라고 부르기도 합니다.&lt;/p&gt;

&lt;p&gt;CA는 아무 기업이나 할 수 있는 게 아니라 신뢰성이 엄격하게 공인된 기업들만 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;TLS 통신을 하려면 이 CA를 통해서 인증서를 발급받아야 합니다.&lt;/p&gt;

&lt;p&gt;먼저, 미리 알아둘 것은 &lt;strong&gt;CA는 자체적으로 공개키와 비밀키를 가지고 있습니다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;CA의 비밀키는 절대 누설 되어선 안 되며, 이것이 노출되는 바람에 &lt;strong&gt;&lt;em&gt;디지노타&lt;/em&gt;&lt;/strong&gt; 라는 회사가 파산된 사례도 있습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;4-ca에서-인증서-발급받기&quot;&gt;4. CA에서 인증서 발급받기&lt;/h2&gt;

&lt;p&gt;자 이제 CA로부터 인증서를 발급받는 방법을 알아 봅시다.&lt;/p&gt;

&lt;p&gt;먼저 그림으로 전체적인 메커니즘을 보고 넘어 갑시다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121363254-bdef5c00-c971-11eb-8c83-08197bec1eca.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자 실제 인증서를 통해 확인해 봅시다.&lt;/p&gt;

&lt;p&gt;먼저, 발급 받고자 하는 기관은 자신의 사이트 정보(도메인 등)과 공개키를 CA에게 제출합니다.&lt;/p&gt;

&lt;p&gt;그러면 CA는 검증을 걸친 후 발급 받고자 하는 서버의 공개 키를 해시(SHA-256 등) 합니다.&lt;/p&gt;

&lt;p&gt;이렇게 해시한 값을  &lt;strong&gt;Finger Print(지문)&lt;/strong&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;이제 이 지문을 CA의 비밀키로 암호화 하고,&lt;/p&gt;

&lt;p&gt;인증서의 발급자 서명으로 등록합니다.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121364644-efb4f280-c972-11eb-8025-142d5566ecdc.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이렇게 서명된 것을 &lt;strong&gt;디지털 서명 (Digital Signing)&lt;/strong&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;이제 CA는 서버에게 이 디지털 서명, 발급자 정보 등등이 등록되어 있는 인증서를 발급해 줍니다.&lt;/p&gt;

&lt;p&gt;이러한 방식처럼,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;상위 인증 기관이 하위 인증서가 포함하고 있는 공개키 (인증서)를 상위 기관의 비밀키로 암호화&lt;/strong&gt; 하여&lt;/p&gt;

&lt;p&gt;상호 보증하게 되는 것을 &lt;strong&gt;인증서 체인(Certificate Chain)&lt;/strong&gt; 이라고 합니다.&lt;/p&gt;

&lt;p&gt;내가 발급받는 CA 기관이 Root CA가 아니라면, 이 CA 기관마저 또 상위 CA에게 인증서를 발급받은 것입니다.&lt;/p&gt;

&lt;p&gt;보통 3단계에 걸쳐서 인증서 체인이 일어나는데,&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121366057-20495c00-c974-11eb-9bc2-29d1cbb745d8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121368826-4ff96380-c976-11eb-9d30-d1b7192b8c85.png&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Github.com의 인증서는 그 상위 인증서인
 Digicert SHA2 CA(Intermediate CA)의 비밀키로 암호화 된 것이며,&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Digicert SHA2 CA인증서는 그 상위 인증서인
  Digicert High Assurance EV Root CA 의 인증기관의 비밀키로 암호화 된 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Digicert High Assurance EV Root는 상위 인증기관이 없는 Root CA이기 때문에 Self-Signed    되어 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Self-SIgned (스스로 보증)  이란,&lt;/p&gt;

&lt;p&gt;자신의 인증서를 해시한 후, CA가 아닌 자신의 비밀키로 암호화 하여 서명으로 등록&lt;/p&gt;

&lt;p&gt;하는 것을 말합니다&lt;/p&gt;

&lt;p&gt;이게 바로 인증서 체인입니다.&lt;/p&gt;

&lt;h2 id=&quot;5-ssltls-인증서의-작동원리&quot;&gt;5. SSL(TLS) 인증서의 작동원리&lt;/h2&gt;

&lt;p&gt;CA에서 발급받은 인증서를 통해 서버의 신뢰성을 인증한다고 했었습니다.&lt;/p&gt;

&lt;p&gt;근데 클라이언트는 이 인증서가 CA에서 발급받은 것인지, 중간에 누가 조작한 것인지를 어떻게 확인할까요?&lt;/p&gt;

&lt;p&gt;먼저 알아 두어야할 것은, &lt;strong&gt;클라이언트들은 CA 리스트들을 이미 가지고 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;OS를 설치할 때 PC에 포함되어있고 브라우저가 이를 읽어옵니다&lt;/p&gt;

&lt;p&gt;크롬의경우 Setting -&amp;gt; Privacy and security -&amp;gt; Manage certificates 를 클릭하면&lt;/p&gt;

&lt;p&gt;설치되어있는 CA 리스트르 보여줍니다.&lt;/p&gt;

&lt;p&gt;직접 확인해 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;먼저 우측상단의 땡땡이 클릭후 Settings클릭!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121470999-f3d82300-c9f9-11eb-8d8f-02d21716a4ae.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Privacy and security 클릭후 securit클릭!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121471000-f3d82300-c9f9-11eb-8819-8ae4315e6a60.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Manage certificates클릭!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121471003-f470b980-c9f9-11eb-9e2d-575dd6190569.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;엄청 많은 인증서가 보이시지요 ㅎㅎ 그중에는 깃헙인증서의 상위 인증기관인 Digicert의 인증서도 보이는군요&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121470986-efac0580-c9f9-11eb-8570-c56e67f76953.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;맥의경우 Keychain Access앱을 클릭하면 똑같은 위치로 이동할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--md&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121470998-f33f8c80-c9f9-11eb-976a-7cc0985209a8.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;자 이제 정말 어떻게 인증하는지 알아보자구요.&lt;/p&gt;

&lt;h3 id=&quot;a-인증서-신청하기&quot;&gt;a. 인증서 신청하기&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121473525-c7260a80-c9fd-11eb-91ab-f94d0fd781eb.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;서버A는 자신이 믿을 수 있는 서버임을 인증하기 위해 CA에서 인증서를 발급받으려 합니다.&lt;/p&gt;

&lt;p&gt;그러기 위해선 자신의 사이트 정보와 사이트의 공개키를 CA에 제출합니다.&lt;/p&gt;

&lt;p&gt;그러면 CA는 검증을 걸친 후 다음과 같은 과정을 거칩니다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;제출받은 서버의 공개키를 해시하여 Finger Print를 생성하고&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Finger Print를 CA의 비밀키로 암호화(Digital signing)&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고 서버에게 이런 정보들이 들어 있는 &lt;strong&gt;인증서를 발급&lt;/strong&gt;해 줍니다.&lt;/p&gt;

&lt;p&gt;서버는 이제 자신이 진짜 서버임을 인증해줄 인증서를 갖고 있는 것입니다.&lt;/p&gt;

&lt;h3 id=&quot;b-클라이언트의-인증된-서버-확인방법&quot;&gt;b. 클라이언트의 인증된 서버 확인방법&lt;/h3&gt;

&lt;p&gt;아무개씨가 서버에 접속 하려고 합니다. 근데 신뢰할 수 있는 서버에 접속을 해야겠지요&lt;/p&gt;

&lt;p&gt;이전 포스트에서 배운 TLS 통신을 통해 서버는 &lt;strong&gt;CA에서 발급받은 인증서를 아무개씨에게 넘깁니다&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;근데 그 과정에서 &lt;em&gt;해커&lt;/em&gt; 가 인증서를 자신의 인증서를 바꿔치거나 인증서의 공개키를 자신의 공개키로 바꿨다면&lt;/p&gt;

&lt;p&gt;이 인증서가 무결성은 어떻게 확인할까요?&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;앞전에 말했었지요, &lt;strong&gt;클라이언트는 이미 모든 CA리스트의 공개키를 가지고 있다는 것을요&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;우선 아무개씨 OS가 갖고있는 CA리스트(인증받은 Root CA들)에 있는 놈인지 확인합니다.&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;image image--hf&quot; src=&quot;https://user-images.githubusercontent.com/75003424/121476495-b5defd00-ca01-11eb-8678-fd65dd5b395c.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약에 이 리스트에 없다면 바로 신뢰할 수 없는 사이트가 되겠습니다.&lt;/p&gt;

&lt;p&gt;만약 리스트에 있는경우에는 해당 &lt;strong&gt;CA 기관의 공개키로 서버 인증서의 서명(Digital Signing)을 복호화&lt;/strong&gt; 합니다.&lt;/p&gt;

&lt;p&gt;(CA는 자신의 비밀키로 인증서를 암호화를 하였으니, 공개키로 복호화가 가능합니다.)
디지털 서명을 복호화 하면, 인증서 내용을 해시한 값이 나오겠죠?&lt;/p&gt;

&lt;p&gt;많이 햇갈릴 수 있지만 CA의 검증 과정을 되짚어 보면 이해하기 한결 쉬우실 겁니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CA의 검증과정에서 서버의 공개키를 해쉬값으로 만든 FingerPrint값이 있었구요.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CA의 비공개키로 그 FingerPrint값을 암호화 하여서 Digital Signing을 만들었습니다&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-&amp;gt; 그말은 즉슨 &lt;strong&gt;CA의 공개키로 복호화한 Digital Signing값은 FingerPrint이며!&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;-&amp;gt; &lt;strong&gt;해당 서버의 공개키를 해쉬화 한 값&lt;/strong&gt;과 일치해야 해야만 한다는 말이지요!&lt;/p&gt;

    &lt;p&gt;일치하지 않는다면 인증서가 위조되었다는 말과도 같습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;c-암호화-통신하기&quot;&gt;c. 암호화 통신하기&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;서버의 인증서의 공개키를 해쉬한 값과&lt;/strong&gt;,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;OS에 존재하는 인증서의 공개키로 해당 서버 인증서의Digital signing&lt;/strong&gt;을 복호화한 값이 일치 했다면 믿을만한 서버이기에 통신을 하면되겠죠?&lt;/p&gt;

&lt;p&gt;우리는 이미 서버의 공개키를 알고있지요?&lt;/p&gt;

&lt;p&gt;통신에 사용할 대칭키를 서버의 공개키로 암호화하여 서버에 보냅니다.&lt;/p&gt;

&lt;p&gt;서버는 자신의 비공개키로 이를 복호화하여 이제 더욱 저렴한비용의 대칭키 방식으로 클라이언트와 통신을 할 수가 있겠습니다.&lt;/p&gt;

&lt;hr /&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="RootCA" /><category term="HTTPS" /><category term="static" /><category term="SSL" /><category term="TLS" /><category term="쿠버네티스" /><category term="보안" /><category term="Security" /><category term="대칭키" /><category term="비대칭키" /><category term="certificate" /><category term="인증서" /><summary type="html">1. TLS가 제공하는 이점들 기밀성 (암호화) 이전 포스팅에서 공부했던 암호화에 해당하는 항목입니다. 서버와 주고 받는 데이터가 스니핑👀 되는 것을 방지합니다. 패킷이 오가는 것을 훔쳐 볼 순 있어도 안전하게 암호화 된 패킷이라 복호화 할 수 없기 떄문에 데이터는 훔쳐볼 수 없습니다. 데이터 무결성 통신 도중 데이터가 제 3자에 의해 악의로 변경될 일이 없습니다. 1번 기밀성과 같은 선상에서 보시면 됩니다. 서로의 대칭키를 RSA 알고리즘을 통해 안전하게 공유한 후에 암호화하여 통신하기 때문에 제 3자가 대칭키를 알아내지 않는 한 중간에서 암호화된 데이터를 임의로 수정하지 못하겠죠. 서버 인증 1, 2번은 지난 포스팅에 공부했던 암호화 알고리즘을 통해 가능하다고 보여져요. 근데 만약 위의 암호화 방식으로만 서버와 클라이언트가 통신을 한다고 가정해 봅시다. 서버와 나는 암호화를 통해 통신하기 때문에 아무도 데이터를 훔쳐볼 수도 건들 수도 없겠지! 여기까지도 좋습니다 근데 만약 서버가 신뢰할 수 없는 서버라면 얘기가 달라지겠지요? 요즘 웹 브라우저에 성가신 팝업이 표시되는 경우 웹을 탐색하는 도중에 무료 경품을 제공한다거나 기기에 문제가 있다고 경고하는 팝업이나 알림이 표시되는 경험은 한번씩 해 보셨을거라고 생각합니다. 이러한 유형의 팝업은 대개 사기성 광고이며, 사용자를 속여 사기꾼에게 개인 정보나 돈을 제공하도록 하기 위해 만들어졌습니다. 이런 서버에 아무리 암호화된 데이터를 보낸다 한들 서버가 사기꾼놈의 서버라면 정말 큰 문제지요. 이처럼, 서버와 클라이언트 간 통신을 할 때는 서버가 신뢰할 수 있는 서버라는 것을 확인하는 작업이 필요합니다. 이럴 때 사용하는 것이 바로 ‘인증서’ 입니다!!! 이번에 공부할 포스팅에서 왜 인증서라는 것에 대해 공부하는지 이제 아시겠죠? 자 그럼 이제 시작해 봅시다. 2. 인증서란 ? 인증서라는 것이 무엇일까요? 이름부터 이미 감이 오지 않나요? 바로 위에서 서버가 신뢰할 수 있는 진짜 서버 임을 확인하기 위해 필요한 것이 바로 인증서 입니다! 인증서에는 다음과 같은 정보들을 포함하고 있습니다. 서비스 정보(인증서를 발급한 CA, 서비스의 도메인 등) 서버 측 공개키(공개키, 공개키 암호화 방법) 지문, 디지털 서명 등 여러분이 지금 보고계신 이 블로그도 인증서를 가지고 있답니다. 주소창의 가장 왼쪽에 🔒 보이시나요? 자물쇠가 잠겨있다는 건 이전 포스팅에서 공부했던 HTTPS 통신이라는 뜻입니다 보안되어 있다는 말이지요 제 블로그는 GitHub Pages를 통해 만들어졌는데요 개인 도메인도 무료로 HTTPS를 지원하지요. 그럼 깃헙의 인증서를 한번 들여다 봅시다. 앞서 말했듯 서버의 공개키, 서명, 지문, 발급자 정보 등이 포함되어 있는것을 확인할수 있습니다! 이것들이 인증서에서 어떤 역할을 하는지는 차차 알아봅시다. 그러기 전에 먼저, 이 인증서는 어디서 어떻게 생성할까요? 3. CA (Certificate Authority) CA는 인증서를 발급해주는 기관으로, Root Certificate라고 부르기도 합니다. CA는 아무 기업이나 할 수 있는 게 아니라 신뢰성이 엄격하게 공인된 기업들만 할 수 있습니다. TLS 통신을 하려면 이 CA를 통해서 인증서를 발급받아야 합니다. 먼저, 미리 알아둘 것은 CA는 자체적으로 공개키와 비밀키를 가지고 있습니다. CA의 비밀키는 절대 누설 되어선 안 되며, 이것이 노출되는 바람에 디지노타 라는 회사가 파산된 사례도 있습니다. 4. CA에서 인증서 발급받기 자 이제 CA로부터 인증서를 발급받는 방법을 알아 봅시다. 먼저 그림으로 전체적인 메커니즘을 보고 넘어 갑시다. 자 실제 인증서를 통해 확인해 봅시다. 먼저, 발급 받고자 하는 기관은 자신의 사이트 정보(도메인 등)과 공개키를 CA에게 제출합니다. 그러면 CA는 검증을 걸친 후 발급 받고자 하는 서버의 공개 키를 해시(SHA-256 등) 합니다. 이렇게 해시한 값을 Finger Print(지문) 이라고 합니다. 이제 이 지문을 CA의 비밀키로 암호화 하고, 인증서의 발급자 서명으로 등록합니다. 이렇게 서명된 것을 디지털 서명 (Digital Signing) 이라고 합니다. 이제 CA는 서버에게 이 디지털 서명, 발급자 정보 등등이 등록되어 있는 인증서를 발급해 줍니다. 이러한 방식처럼, 상위 인증 기관이 하위 인증서가 포함하고 있는 공개키 (인증서)를 상위 기관의 비밀키로 암호화 하여 상호 보증하게 되는 것을 인증서 체인(Certificate Chain) 이라고 합니다. 내가 발급받는 CA 기관이 Root CA가 아니라면, 이 CA 기관마저 또 상위 CA에게 인증서를 발급받은 것입니다. 보통 3단계에 걸쳐서 인증서 체인이 일어나는데, Github.com의 인증서는 그 상위 인증서인 Digicert SHA2 CA(Intermediate CA)의 비밀키로 암호화 된 것이며, Digicert SHA2 CA인증서는 그 상위 인증서인 Digicert High Assurance EV Root CA 의 인증기관의 비밀키로 암호화 된 것입니다. Digicert High Assurance EV Root는 상위 인증기관이 없는 Root CA이기 때문에 Self-Signed 되어 있습니다. Self-SIgned (스스로 보증) 이란, 자신의 인증서를 해시한 후, CA가 아닌 자신의 비밀키로 암호화 하여 서명으로 등록 하는 것을 말합니다 이게 바로 인증서 체인입니다. 5. SSL(TLS) 인증서의 작동원리 CA에서 발급받은 인증서를 통해 서버의 신뢰성을 인증한다고 했었습니다. 근데 클라이언트는 이 인증서가 CA에서 발급받은 것인지, 중간에 누가 조작한 것인지를 어떻게 확인할까요? 먼저 알아 두어야할 것은, 클라이언트들은 CA 리스트들을 이미 가지고 있습니다. OS를 설치할 때 PC에 포함되어있고 브라우저가 이를 읽어옵니다 크롬의경우 Setting -&amp;gt; Privacy and security -&amp;gt; Manage certificates 를 클릭하면 설치되어있는 CA 리스트르 보여줍니다. 직접 확인해 봅시다. 먼저 우측상단의 땡땡이 클릭후 Settings클릭! Privacy and security 클릭후 securit클릭! Manage certificates클릭! 엄청 많은 인증서가 보이시지요 ㅎㅎ 그중에는 깃헙인증서의 상위 인증기관인 Digicert의 인증서도 보이는군요 맥의경우 Keychain Access앱을 클릭하면 똑같은 위치로 이동할 수 있습니다. 자 이제 정말 어떻게 인증하는지 알아보자구요. a. 인증서 신청하기 서버A는 자신이 믿을 수 있는 서버임을 인증하기 위해 CA에서 인증서를 발급받으려 합니다. 그러기 위해선 자신의 사이트 정보와 사이트의 공개키를 CA에 제출합니다. 그러면 CA는 검증을 걸친 후 다음과 같은 과정을 거칩니다 제출받은 서버의 공개키를 해시하여 Finger Print를 생성하고 Finger Print를 CA의 비밀키로 암호화(Digital signing) 그리고 서버에게 이런 정보들이 들어 있는 인증서를 발급해 줍니다. 서버는 이제 자신이 진짜 서버임을 인증해줄 인증서를 갖고 있는 것입니다. b. 클라이언트의 인증된 서버 확인방법 아무개씨가 서버에 접속 하려고 합니다. 근데 신뢰할 수 있는 서버에 접속을 해야겠지요 이전 포스트에서 배운 TLS 통신을 통해 서버는 CA에서 발급받은 인증서를 아무개씨에게 넘깁니다 근데 그 과정에서 해커 가 인증서를 자신의 인증서를 바꿔치거나 인증서의 공개키를 자신의 공개키로 바꿨다면 이 인증서가 무결성은 어떻게 확인할까요? 앞전에 말했었지요, 클라이언트는 이미 모든 CA리스트의 공개키를 가지고 있다는 것을요 우선 아무개씨 OS가 갖고있는 CA리스트(인증받은 Root CA들)에 있는 놈인지 확인합니다. 만약에 이 리스트에 없다면 바로 신뢰할 수 없는 사이트가 되겠습니다. 만약 리스트에 있는경우에는 해당 CA 기관의 공개키로 서버 인증서의 서명(Digital Signing)을 복호화 합니다. (CA는 자신의 비밀키로 인증서를 암호화를 하였으니, 공개키로 복호화가 가능합니다.) 디지털 서명을 복호화 하면, 인증서 내용을 해시한 값이 나오겠죠? 많이 햇갈릴 수 있지만 CA의 검증 과정을 되짚어 보면 이해하기 한결 쉬우실 겁니다. CA의 검증과정에서 서버의 공개키를 해쉬값으로 만든 FingerPrint값이 있었구요. CA의 비공개키로 그 FingerPrint값을 암호화 하여서 Digital Signing을 만들었습니다 -&amp;gt; 그말은 즉슨 CA의 공개키로 복호화한 Digital Signing값은 FingerPrint이며! -&amp;gt; 해당 서버의 공개키를 해쉬화 한 값과 일치해야 해야만 한다는 말이지요! 일치하지 않는다면 인증서가 위조되었다는 말과도 같습니다. c. 암호화 통신하기 서버의 인증서의 공개키를 해쉬한 값과, OS에 존재하는 인증서의 공개키로 해당 서버 인증서의Digital signing을 복호화한 값이 일치 했다면 믿을만한 서버이기에 통신을 하면되겠죠? 우리는 이미 서버의 공개키를 알고있지요? 통신에 사용할 대칭키를 서버의 공개키로 암호화하여 서버에 보냅니다. 서버는 자신의 비공개키로 이를 복호화하여 이제 더욱 저렴한비용의 대칭키 방식으로 클라이언트와 통신을 할 수가 있겠습니다.</summary></entry><entry><title type="html">[ #11 ] 클러스터 보안 - 2</title><link href="https://shjeong92.github.io/2021/06/09/Learning-Kubernetes-11.html" rel="alternate" type="text/html" title="[ #11 ] 클러스터 보안 - 2" /><published>2021-06-09T00:00:00+09:00</published><updated>2021-06-09T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/09/Learning-Kubernetes-11</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/09/Learning-Kubernetes-11.html">&lt;h2 id=&quot;1-tls--ssl--https-란&quot;&gt;1. TLS / SSL / HTTPS 란?&lt;/h2&gt;

&lt;h3 id=&quot;sslsecure-socket-layer&quot;&gt;&lt;strong&gt;SSL(Secure Socket Layer)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;SSL은 웹사이트와 브라우저(혹은, 두 서버) 사이에 전송된 데이터를 암호화하여 인터넷 연결 보안을 유지하는 표준 기술입니다.&lt;/p&gt;

&lt;p&gt;이는 해커가 개인 정보 및 금융 정보를 포함한 전송되는 모든 정보를 열람하거나 훔치는 것을 방지합니다.&lt;/p&gt;

&lt;p&gt;쉽게 말하자면, &lt;strong&gt;네트워크 통신을 할 때 보안을 제공하기 위해 설계된 암호 규약&lt;/strong&gt;이며, TCP/IP 네트워크를 사용하는 통신에 적용됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SSL의 구조&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121298850-7ea01b80-c92f-11eb-8f4c-2f01adc53c1f.jpeg&quot; alt=&quot;ssl-arch&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tlstransport-layer-socket&quot;&gt;TLS(Transport Layer Socket)&lt;/h3&gt;

&lt;p&gt;이름은 SSL 과 다르지만 사실 둘은 같다고 합니다. TLS1.0은 SSL 3.0을 그대로 계승한 것이라고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;http--https&quot;&gt;HTTP / HTTPS&lt;/h3&gt;

&lt;h4 id=&quot;--http&quot;&gt;- HTTP&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP 는 다음과 같이 암호화 되지 않은 평문으로 데이터를 전송합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121309439-24a65280-c93d-11eb-8bb3-c1d429e260e2.png&quot; alt=&quot;http&quot; /&gt;&lt;/p&gt;

&lt;p&gt;따라서 누군가 패킷을 훔쳐보는 스니핑(Sniffing) 공격에 취약하지요.&lt;/p&gt;

&lt;p&gt;HTTP 통신에선 해커가 Wire Shark를 통해 패킷을 확인하면 내 비밀번호가 그대로 서버로 전송되는 것을 볼 수 있는것이죠&lt;/p&gt;

&lt;h4 id=&quot;--https&quot;&gt;- HTTPS&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;HTTPS 는 다음과 같이 암호화 된 데이터를 전송합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121309445-27a14300-c93d-11eb-8c69-f6f5cc6a9e6f.png&quot; alt=&quot;https&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이때 사용하는 보안 인증(암호화 + 서버인증 등)이 TLS(SSL)입니다.&lt;/p&gt;

&lt;p&gt;즉, HTTPS는 TLS 프로토콜 위에서 돌아가는 HTTP 프로토콜입니다.&lt;/p&gt;

&lt;p&gt;간단하게 말해서 통신할 떄에 데이터를 ‘암호화’ 하는 보안이 필요하다,&lt;/p&gt;

&lt;p&gt;HTTP 통신에서 보안을 추가한 것이 HTTPS이며&lt;/p&gt;

&lt;p&gt;이때 보안은 TLS를 통해 한다 정도로 알고 넘어가면 되겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2-암호화&quot;&gt;2. 암호화&lt;/h2&gt;

&lt;p&gt;이제 TCP/IP 통신을 할 땐 데이터를 암호화 하는 보안이 필요하고,&lt;/p&gt;

&lt;p&gt;그 보안 인증에 TLS가 있다는 것도 알았으니 &lt;strong&gt;TLS가 어떻게 데이터를 암호화 하는지&lt;/strong&gt; 알아봅시다.&lt;/p&gt;

&lt;p&gt;먼저, TLS는 보안과 성능상 이슈로 두 가지의 암호화 방법을 혼용해서 사용합니다.&lt;/p&gt;

&lt;p&gt;따라서 다음 두 가지 암호화 방법을 이해해야 합니다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;대칭키 암호화(Symmetric key algorithm)&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;비대칭키 암호화(Asymmetric key algorithm)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;암호화를 하기 위해선 일종의 키(key)가 필요합니다.&lt;/p&gt;

&lt;p&gt;키는 뭐 문자가 될 수도 있고 숫자가 될 수도 있고 마음대로 정할 수 있지요.&lt;/p&gt;

&lt;p&gt;암호화는 그냥 하는 것이 아니라 이 &lt;strong&gt;[키]&lt;/strong&gt; + &lt;strong&gt;[데이터]&lt;/strong&gt;를 이용하여 &lt;strong&gt;[암호화된 데이터]&lt;/strong&gt;를 만들어 내는 것입니다&lt;/p&gt;

&lt;p&gt;따라서 키가 단 한 글자라도 다르다면 암호화의 내용도 전혀 달라집니다!&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;대칭키-암호화&quot;&gt;대칭키 암호화&lt;/h3&gt;
    &lt;p&gt;&lt;strong&gt;대칭키 암호화는, 암호화를 하는 키와 암호를 해독하는 키가 같은 방식입니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;이때 암호화와 복호화에 동시에 사용되는 이 키를  &lt;strong&gt;대칭키&lt;/strong&gt;  라고 합니다.&lt;/p&gt;

    &lt;p&gt;예를들면 아래 그림과 같습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121342391-89bd7080-c95c-11eb-815b-492fd82d5c63.png&quot; alt=&quot;symmetric&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;자, 여기서 이제 대칭키 암호화의 단점이 드러납니다.&lt;/p&gt;

    &lt;p&gt;대칭키는 상대방도 나도 서로 공유를 해야하기 때문에,&lt;/p&gt;

    &lt;p&gt;대칭키를 전달하는 과정에서 누가 훔쳐볼 위험이 있습니다.&lt;/p&gt;

    &lt;p&gt;만약 대칭키가 해킹당한다면 그럼 당연히 복호화가 가능하니, 데이터도 누출되게 되겠죠 :b&lt;/p&gt;

    &lt;p&gt;이처럼 대칭키 암호화 방식에선, &lt;strong&gt;대칭키를 상대에게 전달하는 방식에서 해킹당할 리스크가&lt;/strong&gt; 있습니다.&lt;/p&gt;

    &lt;p&gt;이러한 대칭키 암호화의 근본적인 문제를 해결하고자 나온것이 다음에 소개하는 &lt;strong&gt;비대칭키 암호화 방식&lt;/strong&gt;입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h3 id=&quot;비대칭키-암호화&quot;&gt;비대칭키 암호화&lt;/h3&gt;
    &lt;p&gt;&lt;strong&gt;하나의 키를 갖는 대칭키 암호화 방식과 달리,  비대칭키 암호화 방식 은 한 쌍의 키를 갖게 됩니다.&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;한마디로 비대칭키 암호화 방식에선 키가 2개 입니다.&lt;/p&gt;

    &lt;p&gt;이 두개의 키로 각각 암호화, 복호화를 할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;만일 A, B라는 두 개의 키가 있다면 A키로 암호화한 데이터는 B키로만 복호화를 할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;또한 B키로 암호화한 데이터는 A키로만 복호화를 할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;A키로 암호화한 데이터를 A키로 복호화 할 순 없으며, B키도 마찬가지 입니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;통상적으로 비대칭키 방식에서 가지는 두개의 키에서&lt;/p&gt;

    &lt;p&gt;하나는  &lt;strong&gt;공개 키(Public Key)&lt;/strong&gt; ,  하나는  &lt;strong&gt;개인키(비밀키, Private Key)&lt;/strong&gt; 라고 부릅니다.&lt;/p&gt;

    &lt;p&gt;이렇기 때문에 공개키는 암호화를, 개인키는 복호화를 한다고 알려져 있는데 그렇지 않답니다.&lt;/p&gt;

    &lt;p&gt;이를 그림으로 설명하자면 다음과 같습니다&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121317973-c631a200-c945-11eb-90c2-4779f59efea7.png&quot; alt=&quot;enc&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;
이렇듯 한 쌍의 키로 암호화, 복호화를 하는 방식을  &lt;strong&gt;RSA 알고리즘&lt;/strong&gt;  이라 합니다!
&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;조금더 이해하기쉽게 그림으로 표현해보자면 아래와 같습니다.&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121333638-f122f280-c953-11eb-8ce0-3f6b8763e3c8.png&quot; alt=&quot;rsa&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;상대방의 공개키를 바탕으로 암호화해서 보내면 해당 공개키의 쌍인 비밀키를 가진 상대방 만이 암호를 해독할 수가 있겠죠?&lt;/p&gt;

    &lt;p&gt;해커가 공개키를 얻는다고해도 암호를 해독할 수 없기때문에 더욱 안전한 암호화 방식입니다.&lt;/p&gt;

    &lt;p&gt;언뜻 보면 &lt;strong&gt;비대칭키(RSA)&lt;/strong&gt; 방식의 방법이 이렇게 완벽해 보이는데&lt;/p&gt;

    &lt;p&gt;왜 TLS는 대칭키 방식과 비대칭키 방식을 같이 사용 할까요?&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;
그 이유는 RSA 알고리즘을 이용한 암호화 방식은 복잡한 수학적 원리로 이루어져 있어,&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;CPU 리소스를 크게 소모한다는 단점&lt;/strong&gt;이 있기 때문입니다.&lt;/p&gt;

    &lt;p&gt;이때문에, RSA 비대칭키 방식으로만 통신을 하기에 성능상 어려움이 있습니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3-tls의-암호화-방식&quot;&gt;3. TLS의 암호화 방식&lt;/h2&gt;

&lt;p&gt;지금까지 대칭키 방식과 비대칭키 방식의 원리를 알아보았습니다.&lt;/p&gt;

&lt;p&gt;위에서 설명드린 두 방식의 단점 때문에, TLS에서는 이 두 가지 방식을 보완하여 사용합니다.&lt;/p&gt;

&lt;p&gt;대칭키 방식에서의 가장 큰 문제점은 대칭키를 전달할 때 해킹당할 리스크였죠?&lt;/p&gt;

&lt;p&gt;이를 RSA 비대칭키 방식으로 보안한 것입니다.&lt;/p&gt;

&lt;p&gt;실제 통신을 할 때는 CPU 리소스 소모가 적은 대칭키 방식으로 데이터를 주고 받습니다.&lt;/p&gt;

&lt;p&gt;이하기쉽게 그림으로 설명드리도록 하겠습니다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/75003424/121340354-7b6e5500-c95a-11eb-9450-97a64678b9cc.png&quot; alt=&quot;tls&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU 리소스를 크게 소모한다는 RSA&lt;/strong&gt;방식은 한번만 사용하여 대칭키를 알아내는용도로만 쓰이고&lt;/p&gt;

&lt;p&gt;나머지 통신은 값이 싼 대칭키 방식을 사용하는 것입니다.&lt;/p&gt;

&lt;p&gt;그림으로 보니 더 쉽게 이해가 되시지요?&lt;/p&gt;

&lt;p&gt;이렇게  TLS, SSL, 대칭키, 비대칭키(공개키, 개인키)에 대해선 모두 알아보았구요&lt;/p&gt;

&lt;p&gt;이번 포스팅은 길어지니 여기서 마치고,&lt;/p&gt;

&lt;p&gt;이 다음 포스팅에선 인증서, 디지털 서명, CA 등등에 대해 다뤄보겠습니다~&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Kubernetes" /><category term="HTTPS" /><category term="static" /><category term="SSL" /><category term="TLS" /><category term="쿠버네티스" /><category term="보안" /><category term="Security" /><category term="대칭키" /><category term="비대칭키" /><summary type="html">1. TLS / SSL / HTTPS 란? SSL(Secure Socket Layer) SSL은 웹사이트와 브라우저(혹은, 두 서버) 사이에 전송된 데이터를 암호화하여 인터넷 연결 보안을 유지하는 표준 기술입니다. 이는 해커가 개인 정보 및 금융 정보를 포함한 전송되는 모든 정보를 열람하거나 훔치는 것을 방지합니다. 쉽게 말하자면, 네트워크 통신을 할 때 보안을 제공하기 위해 설계된 암호 규약이며, TCP/IP 네트워크를 사용하는 통신에 적용됩니다. SSL의 구조 TLS(Transport Layer Socket) 이름은 SSL 과 다르지만 사실 둘은 같다고 합니다. TLS1.0은 SSL 3.0을 그대로 계승한 것이라고 합니다. HTTP / HTTPS - HTTP HTTP 는 다음과 같이 암호화 되지 않은 평문으로 데이터를 전송합니다 따라서 누군가 패킷을 훔쳐보는 스니핑(Sniffing) 공격에 취약하지요. HTTP 통신에선 해커가 Wire Shark를 통해 패킷을 확인하면 내 비밀번호가 그대로 서버로 전송되는 것을 볼 수 있는것이죠 - HTTPS HTTPS 는 다음과 같이 암호화 된 데이터를 전송합니다 이때 사용하는 보안 인증(암호화 + 서버인증 등)이 TLS(SSL)입니다. 즉, HTTPS는 TLS 프로토콜 위에서 돌아가는 HTTP 프로토콜입니다. 간단하게 말해서 통신할 떄에 데이터를 ‘암호화’ 하는 보안이 필요하다, HTTP 통신에서 보안을 추가한 것이 HTTPS이며 이때 보안은 TLS를 통해 한다 정도로 알고 넘어가면 되겠습니다. 2. 암호화 이제 TCP/IP 통신을 할 땐 데이터를 암호화 하는 보안이 필요하고, 그 보안 인증에 TLS가 있다는 것도 알았으니 TLS가 어떻게 데이터를 암호화 하는지 알아봅시다. 먼저, TLS는 보안과 성능상 이슈로 두 가지의 암호화 방법을 혼용해서 사용합니다. 따라서 다음 두 가지 암호화 방법을 이해해야 합니다 대칭키 암호화(Symmetric key algorithm) 비대칭키 암호화(Asymmetric key algorithm) 암호화를 하기 위해선 일종의 키(key)가 필요합니다. 키는 뭐 문자가 될 수도 있고 숫자가 될 수도 있고 마음대로 정할 수 있지요. 암호화는 그냥 하는 것이 아니라 이 [키] + [데이터]를 이용하여 [암호화된 데이터]를 만들어 내는 것입니다 따라서 키가 단 한 글자라도 다르다면 암호화의 내용도 전혀 달라집니다! 대칭키 암호화 대칭키 암호화는, 암호화를 하는 키와 암호를 해독하는 키가 같은 방식입니다. 이때 암호화와 복호화에 동시에 사용되는 이 키를 대칭키 라고 합니다. 예를들면 아래 그림과 같습니다. 자, 여기서 이제 대칭키 암호화의 단점이 드러납니다. 대칭키는 상대방도 나도 서로 공유를 해야하기 때문에, 대칭키를 전달하는 과정에서 누가 훔쳐볼 위험이 있습니다. 만약 대칭키가 해킹당한다면 그럼 당연히 복호화가 가능하니, 데이터도 누출되게 되겠죠 :b 이처럼 대칭키 암호화 방식에선, 대칭키를 상대에게 전달하는 방식에서 해킹당할 리스크가 있습니다. 이러한 대칭키 암호화의 근본적인 문제를 해결하고자 나온것이 다음에 소개하는 비대칭키 암호화 방식입니다. 비대칭키 암호화 하나의 키를 갖는 대칭키 암호화 방식과 달리, 비대칭키 암호화 방식 은 한 쌍의 키를 갖게 됩니다. 한마디로 비대칭키 암호화 방식에선 키가 2개 입니다. 이 두개의 키로 각각 암호화, 복호화를 할 수 있습니다. 만일 A, B라는 두 개의 키가 있다면 A키로 암호화한 데이터는 B키로만 복호화를 할 수 있습니다. 또한 B키로 암호화한 데이터는 A키로만 복호화를 할 수 있습니다. A키로 암호화한 데이터를 A키로 복호화 할 순 없으며, B키도 마찬가지 입니다. 통상적으로 비대칭키 방식에서 가지는 두개의 키에서 하나는 공개 키(Public Key) , 하나는 개인키(비밀키, Private Key) 라고 부릅니다. 이렇기 때문에 공개키는 암호화를, 개인키는 복호화를 한다고 알려져 있는데 그렇지 않답니다. 이를 그림으로 설명하자면 다음과 같습니다 이렇듯 한 쌍의 키로 암호화, 복호화를 하는 방식을 RSA 알고리즘 이라 합니다! 조금더 이해하기쉽게 그림으로 표현해보자면 아래와 같습니다. 상대방의 공개키를 바탕으로 암호화해서 보내면 해당 공개키의 쌍인 비밀키를 가진 상대방 만이 암호를 해독할 수가 있겠죠? 해커가 공개키를 얻는다고해도 암호를 해독할 수 없기때문에 더욱 안전한 암호화 방식입니다. 언뜻 보면 비대칭키(RSA) 방식의 방법이 이렇게 완벽해 보이는데 왜 TLS는 대칭키 방식과 비대칭키 방식을 같이 사용 할까요? 그 이유는 RSA 알고리즘을 이용한 암호화 방식은 복잡한 수학적 원리로 이루어져 있어, CPU 리소스를 크게 소모한다는 단점이 있기 때문입니다. 이때문에, RSA 비대칭키 방식으로만 통신을 하기에 성능상 어려움이 있습니다. 3. TLS의 암호화 방식 지금까지 대칭키 방식과 비대칭키 방식의 원리를 알아보았습니다. 위에서 설명드린 두 방식의 단점 때문에, TLS에서는 이 두 가지 방식을 보완하여 사용합니다. 대칭키 방식에서의 가장 큰 문제점은 대칭키를 전달할 때 해킹당할 리스크였죠? 이를 RSA 비대칭키 방식으로 보안한 것입니다. 실제 통신을 할 때는 CPU 리소스 소모가 적은 대칭키 방식으로 데이터를 주고 받습니다. 이하기쉽게 그림으로 설명드리도록 하겠습니다! CPU 리소스를 크게 소모한다는 RSA방식은 한번만 사용하여 대칭키를 알아내는용도로만 쓰이고 나머지 통신은 값이 싼 대칭키 방식을 사용하는 것입니다. 그림으로 보니 더 쉽게 이해가 되시지요? 이렇게 TLS, SSL, 대칭키, 비대칭키(공개키, 개인키)에 대해선 모두 알아보았구요 이번 포스팅은 길어지니 여기서 마치고, 이 다음 포스팅에선 인증서, 디지털 서명, CA 등등에 대해 다뤄보겠습니다~</summary></entry><entry><title type="html">[ #10 ] 클러스터 보안 - 1</title><link href="https://shjeong92.github.io/2021/06/07/Learning-Kubernetes-10.html" rel="alternate" type="text/html" title="[ #10 ] 클러스터 보안 - 1" /><published>2021-06-07T00:00:00+09:00</published><updated>2021-06-07T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/07/Learning-Kubernetes-10</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/07/Learning-Kubernetes-10.html">&lt;p&gt;기본적인 인증 수단에는 &lt;strong&gt;Static Password File&lt;/strong&gt;을 통한 방법과, &lt;strong&gt;Static Token File&lt;/strong&gt;을 이용한 방법이 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;1---static-password-file&quot;&gt;1 - Static Password File&lt;/h2&gt;

&lt;p&gt;아래의 유저정보가 담긴 csv파일을 통하여 인증 할 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#user-details.csv
password123,username1,userId1
password133,username2,userId2
password113,username3,userId3 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;kubeadm으로 클러스터를 구성하였으면 
그러기 위해선 staticpodpath위치에 kube-apiserver.yaml 이 존재하는데, 아래와같이 실행 옵션을 추가해주면 됩니다&lt;/p&gt;
&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;...중략&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;- command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-apiserver&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--advertise-address=10.178.0.2&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--allow-privileged=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--authorization-mode=Node,RBAC&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--client-ca-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--enable-admission-plugins=NodeRestriction&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--enable-bootstrap-token-auth=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-servers=https://127.0.0.1:2379&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--insecure-port=0&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--basic-auth-file=user-details.csv        &amp;lt;-----추가된 실행옵션&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또한 이 파일은 선택적으로 4번째 컬럼에 그룹명을 넣을 수도 있습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#user-details.csv 
password123,username1,userId1,group1
password133,username2,userId2,group2
password113,username3,userId3,group2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;2---static-token-file&quot;&gt;2 - Static Token File&lt;/h2&gt;

&lt;p&gt;두번째 기본 인증 방법으로 Password 대신에 Token을 사용하는 방법인데요&lt;/p&gt;

&lt;p&gt;첫번째 컬럼에 비밀번호 대신에 토큰이 들어가는 차이가 있고,&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user-token-details.csv
AjkfgljADSKFfjkwelkasdfKdfgkdlfga,username1,userId1,group1(optional)
RAakjkfskfgElkasdfjkERlfkglgDFFLg,username2,userId2,group2(optional)
lfkjgkqlwemdfgEaklFKSGkejsfdkgkas,username1,userId2,group2(optional)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행 옵션이 다른 차이점이 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;...중략&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;- command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-apiserver&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--advertise-address=10.178.0.2&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--allow-privileged=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--authorization-mode=Node,RBAC&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--client-ca-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--enable-admission-plugins=NodeRestriction&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--enable-bootstrap-token-auth=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--etcd-servers=https://127.0.0.1:2379&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--insecure-port=0&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--token-auth-file=user-details.csv        &amp;lt;-----추가된 실행옵션&lt;/span&gt;
&lt;span class=&quot;nn&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 두가지 방법은 추천되는 인증 방식이 아니라고합니다.
다음 포스트에서는 실제로 쓰이는 방식에 대해 다뤄보겠습니다.&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Kubernetes" /><category term="maintenance" /><category term="static" /><category term="pod" /><category term="strategy" /><category term="쿠버네티스" /><category term="update" /><summary type="html">기본적인 인증 수단에는 Static Password File을 통한 방법과, Static Token File을 이용한 방법이 있습니다. 1 - Static Password File 아래의 유저정보가 담긴 csv파일을 통하여 인증 할 수 있습니다. #user-details.csv password123,username1,userId1 password133,username2,userId2 password113,username3,userId3 kubeadm으로 클러스터를 구성하였으면 그러기 위해선 staticpodpath위치에 kube-apiserver.yaml 이 존재하는데, 아래와같이 실행 옵션을 추가해주면 됩니다 ...중략 - command: - kube-apiserver - --advertise-address=10.178.0.2 - --allow-privileged=true - --authorization-mode=Node,RBAC - --client-ca-file=/etc/kubernetes/pki/ca.crt - --enable-admission-plugins=NodeRestriction - --enable-bootstrap-token-auth=true - --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt - --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt - --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key - --etcd-servers=https://127.0.0.1:2379 - --insecure-port=0 - --basic-auth-file=user-details.csv &amp;lt;-----추가된 실행옵션 ... 또한 이 파일은 선택적으로 4번째 컬럼에 그룹명을 넣을 수도 있습니다. #user-details.csv password123,username1,userId1,group1 password133,username2,userId2,group2 password113,username3,userId3,group2 2 - Static Token File 두번째 기본 인증 방법으로 Password 대신에 Token을 사용하는 방법인데요 첫번째 컬럼에 비밀번호 대신에 토큰이 들어가는 차이가 있고, user-token-details.csv AjkfgljADSKFfjkwelkasdfKdfgkdlfga,username1,userId1,group1(optional) RAakjkfskfgElkasdfjkERlfkglgDFFLg,username2,userId2,group2(optional) lfkjgkqlwemdfgEaklFKSGkejsfdkgkas,username1,userId2,group2(optional) 실행 옵션이 다른 차이점이 있습니다. ...중략 - command: - kube-apiserver - --advertise-address=10.178.0.2 - --allow-privileged=true - --authorization-mode=Node,RBAC - --client-ca-file=/etc/kubernetes/pki/ca.crt - --enable-admission-plugins=NodeRestriction - --enable-bootstrap-token-auth=true - --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt - --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt - --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key - --etcd-servers=https://127.0.0.1:2379 - --insecure-port=0 - --token-auth-file=user-details.csv &amp;lt;-----추가된 실행옵션 ... 위 두가지 방법은 추천되는 인증 방식이 아니라고합니다. 다음 포스트에서는 실제로 쓰이는 방식에 대해 다뤄보겠습니다.</summary></entry><entry><title type="html">[ #9 ] 클러스터 백업 &amp;amp; 복구</title><link href="https://shjeong92.github.io/2021/06/04/Learning-Kubernetes-09.html" rel="alternate" type="text/html" title="[ #9 ] 클러스터 백업 &amp;amp; 복구" /><published>2021-06-04T00:00:00+09:00</published><updated>2021-06-04T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/04/Learning-Kubernetes-09</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/04/Learning-Kubernetes-09.html">&lt;p&gt;이번 포스트에서는 ETCD database를 이용한 클러스터 백업 및 복구 방법에 대해서 다뤄보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;etcd란&quot;&gt;etcd란&lt;/h2&gt;

&lt;p&gt;etcd는 모든 클러스터 데이터에 대한 Kubernetes의 백업 저장소로 사용되는 일관되고 가용성이 높은 키 값 저장소입니다&lt;/p&gt;

&lt;p&gt;그리고 ETCD는 각 마스터노드에 존재하고, key=value의 데이터는 마스터 노드의 /var/lib/etcd 에 저장됩니다.&lt;/p&gt;

&lt;p&gt;ETCD는 built in 스냅샷 solution을 가지고 있는데요 이를통해 현재 실행중인 모든 리소스의 정보를 백업하고, 복구할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;step1---etcd가-설치되어-있지-않을경우-설치합니다&quot;&gt;STEP1 - etcd가 설치되어 있지 않을경우 설치합니다.&lt;/h3&gt;

&lt;p&gt;제 쿠버네티 클러스터는 1 개의 마스터노드, 3개의 워커노드로 구성되어 있습니다. googld cloud compute engine 인스턴스를 사용하여 구성하였으며 모든 노드는 Ubuntu 18.04.5 LTS 버전입니다.&lt;/p&gt;

&lt;p&gt;아래 커맨드를 이용해 etcd-client를 설치해줍니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;etcd-client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step2---복구시킬-환경-구성&quot;&gt;STEP2 - 복구시킬 환경 구성&lt;/h3&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#depl.yaml&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;apps/v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Deployment&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-deployment&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp-pod&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;myapp&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx-container&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;nginx:1.19&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;replicas&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;selector&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;matchLabels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;front-end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;간단한 yaml파일을 통해 3개의 nginx 파드를 배포합니다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl apply &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; depl.yml 
deployment.apps/myapp-deployment created
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 현재 어떤 리소스들이 돌아가고있는지 확인해주고 이 상황의 스냅샷을 생성할겁니다&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ kubectl get all
NAME                                    READY   STATUS    RESTARTS   AGE
pod/myapp-deployment-7f6679cc7d-5qwxx   1/1     Running   0          32s
pod/myapp-deployment-7f6679cc7d-855lp   1/1     Running   0          32s
pod/myapp-deployment-7f6679cc7d-bxxjx   1/1     Running   0          32s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    &amp;lt;none&amp;gt;        443/TCP   8d

NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/myapp-deployment   3/3     3            3           32s

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/myapp-deployment-7f6679cc7d   3         3         3       32s
shjeong920522@master:~/Pod$ 

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;스냅샷-생성하기&quot;&gt;스냅샷 생성하기&lt;/h2&gt;

&lt;p&gt;etcdctl의 스냅샷을 생성하기위해선 아래와같은 옵션이 필요합니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;etcdctl &lt;span class=&quot;nt&quot;&gt;--cacert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;옵션값 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--cert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;옵션값 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;--key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;옵션값 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
snapshot save 백업경로 및 파일이름
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;그렇다면 이 옵션값은 어디서 확인가능할까요?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ps명령어 와 grep을 를 활용하면 된답니다&lt;/p&gt;

&lt;p&gt;아래 명령어를 사용하여 다 찾아서 값을 가져와도되지만&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;se&quot;&gt;\$&lt;/span&gt; ps &lt;span class=&quot;nt&quot;&gt;-ef&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;etcd
root      2863  2764  1 05:36 ?        00:00:23 etcd &lt;span class=&quot;nt&quot;&gt;--advertise-client-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2379 &lt;span class=&quot;nt&quot;&gt;--cert-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.crt &lt;span class=&quot;nt&quot;&gt;--client-cert-auth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--data-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/etcd &lt;span class=&quot;nt&quot;&gt;--initial-advertise-peer-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;nt&quot;&gt;--initial-cluster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;nt&quot;&gt;--key-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.key &lt;span class=&quot;nt&quot;&gt;--listen-client-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://127.0.0.1:2379,https://10.178.0.2:2379 &lt;span class=&quot;nt&quot;&gt;--listen-metrics-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://127.0.0.1:2381 &lt;span class=&quot;nt&quot;&gt;--listen-peer-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;master &lt;span class=&quot;nt&quot;&gt;--peer-cert-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/peer.crt &lt;span class=&quot;nt&quot;&gt;--peer-client-cert-auth&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--peer-key-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/peer.key &lt;span class=&quot;nt&quot;&gt;--peer-trusted-ca-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/ca.crt &lt;span class=&quot;nt&quot;&gt;--snapshot-count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10000 &lt;span class=&quot;nt&quot;&gt;--trusted-ca-file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/ca.crt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;표에 들어간 커맨드로 원하는 부분을 강조시켜 찾는방법을 추천드립니다. 눈알굴려서 찾는것보다 훨씬 빠르더라구요&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;etcdctl 명령 옵션&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;etcd &lt;br /&gt;프로세스 실행옵션&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;값&lt;/center&gt;&lt;/th&gt;
      &lt;th&gt;&lt;center&gt;커맨드로 빨리찾기&lt;/center&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cacert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--trusted-ca-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/ca.crt&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep trusted&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cert-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/server.crt&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--cert&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--key&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--key-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/server.key&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--key&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;그리고 값 부분은 항상 같은것이 아닐 수도 있기에 커맨드로 직접 확인하셔야 합니다.&lt;/p&gt;

&lt;p&gt;자 이제 스냅샷을 생성하기위하여 우선 루트계정으로 전환해줍니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아래와 같이 환경변수를 등록해줍니다
ETCDCTL_API 3버전을 사용하기 위함입니다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root# &lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ETCDCTL_API&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root# etcdctl &lt;span class=&quot;nt&quot;&gt;--cacert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/ca.crt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--cert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.crt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.key &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; snapshot save /opt/backup
Snapshot saved at /opt/backup
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;스냅샷을 생성하였으니 아까 배포하였던 deployment 를 delete하고 etcdctl 복구를하여
정말 동작하던 deployment를 다시 배포해주는지 확인해봅시다&lt;/p&gt;

&lt;p&gt;우선 루트계정에서 로그아웃 해주시구요&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root# &lt;span class=&quot;nb&quot;&gt;exit
logout&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;deployment를 삭제시켜줍니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl delete &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; depl.yml 
deployment.apps &lt;span class=&quot;s2&quot;&gt;&quot;myapp-deployment&quot;&lt;/span&gt; deleted
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;복구하기로 넘어갑니다.&lt;/p&gt;

&lt;h2 id=&quot;스냅샷으로-복구하기&quot;&gt;스냅샷으로 복구하기&lt;/h2&gt;

&lt;p&gt;복구할때는 스냅샷을 만들때 넣었던 옵션에서 네가지의 옵션이 더 추가됩니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;etcdctl 명령 옵션&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;etcd &lt;br /&gt;프로세스 실행옵션&lt;/center&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;center&gt;값&lt;/center&gt;&lt;/th&gt;
      &lt;th&gt;&lt;center&gt;커맨드로 빨리찾기&lt;/center&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cacert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--trusted-ca-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/ca.crt&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep trusted&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cert&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--cert-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/server.crt&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--cert&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--key&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--key-file&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/etc/kubernetes/pki/etcd/server.key&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--key&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--initial-advertise-peer-urls&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--initial-advertise-peer-urls&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;https://10.178.0.2:2380&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep initial&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--initial-cluster=master&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--initial-cluster=master&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;https://10.178.0.2:2380&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep initial&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--data-dir&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--data-dir&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;/var/lib/etcd_backup&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--data-dir&quot; &lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--name&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;--name&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;master(마스터노드이름)&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ps -ef | grep etcd | grep &quot;\--name&quot;&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;자 여기까지가 restore 할때 필요한 모든 옵션입니다.&lt;/p&gt;

&lt;p&gt;이제 아까 찍어놨던 스냅샷으로 복구되는지 확인해봅시다.&lt;/p&gt;

&lt;p&gt;우선 루트 계정으로 전환하구요&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;restore 명령어를 입력해주고 로그아웃해줍니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root# etcdctl &lt;span class=&quot;nt&quot;&gt;--cacert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/ca.crt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--cert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.crt &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/pki/etcd/server.key &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--initial-advertise-peer-urls&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--initial-cluster&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;master&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;https://10.178.0.2:2380 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--data-dir&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/etcd_backup &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;master &lt;span class=&quot;se&quot;&gt;\ &lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; snapshot restore /opt/backup

root# &lt;span class=&quot;nb&quot;&gt;exit
logout&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;/opt/backup 에 생성해뒀던 스냅샷을이용해서 /var/lib 위치에 etcd_backup 파일을 생성합니다
staticpod에서 실행되는 etcd가 이를 바라보도록 해줘야하겠지요&lt;/p&gt;

&lt;p&gt;staticpod의 위치인 /etc/kubernetes/manifest로 이동후 etcd.yaml을 수정해야합니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /etc/kubernetes/manifest

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;vim etcd.yaml

~~~yaml
&lt;span class=&quot;c&quot;&gt;#etcd.yaml&lt;/span&gt;
...중략

volumes:
- hostPath:
    path: /etc/kubernetes/pki/etcd
    &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: DirectoryOrCreate
  name: etcd-certs
- hostPath:
    path: /var/lib/etcd_backup     &amp;lt;&lt;span class=&quot;nt&quot;&gt;-----------&lt;/span&gt;  backup한 스냅샷을 바라보게 수정해줍니다
    &lt;span class=&quot;nb&quot;&gt;type&lt;/span&gt;: DirectoryOrCreate
  name: etcd-data

...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;변경사항을 저장해주면 새로 로드될때까지 시간이 조금걸립니다&lt;/p&gt;

&lt;p&gt;잠시후 정말 실행 중이던 deployment가 실행중인지 확인해봅시다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get deploy
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
myapp-deployment   3/3     3            3           20s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;짜잔~ 잘 복구된것을 확인할 수 있었습니다&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Kubernetes" /><category term="maintenance" /><category term="static" /><category term="pod" /><category term="strategy" /><category term="쿠버네티스" /><category term="update" /><summary type="html">이번 포스트에서는 ETCD database를 이용한 클러스터 백업 및 복구 방법에 대해서 다뤄보겠습니다. etcd란 etcd는 모든 클러스터 데이터에 대한 Kubernetes의 백업 저장소로 사용되는 일관되고 가용성이 높은 키 값 저장소입니다 그리고 ETCD는 각 마스터노드에 존재하고, key=value의 데이터는 마스터 노드의 /var/lib/etcd 에 저장됩니다. ETCD는 built in 스냅샷 solution을 가지고 있는데요 이를통해 현재 실행중인 모든 리소스의 정보를 백업하고, 복구할 수 있습니다. STEP1 - etcd가 설치되어 있지 않을경우 설치합니다. 제 쿠버네티 클러스터는 1 개의 마스터노드, 3개의 워커노드로 구성되어 있습니다. googld cloud compute engine 인스턴스를 사용하여 구성하였으며 모든 노드는 Ubuntu 18.04.5 LTS 버전입니다. 아래 커맨드를 이용해 etcd-client를 설치해줍니다 $ sudo apt update $ sudo apt install etcd-client STEP2 - 복구시킬 환경 구성 #depl.yaml apiVersion: apps/v1 kind: Deployment metadata: name: myapp-deployment labels: app: myapp type: front-end spec: template: metadata: name: myapp-pod labels: app: myapp type: front-end spec: containers: - name: nginx-container image: nginx:1.19 replicas: 3 selector: matchLabels: type: front-end 간단한 yaml파일을 통해 3개의 nginx 파드를 배포합니다 $ kubectl apply -f depl.yml deployment.apps/myapp-deployment created 그리고 현재 어떤 리소스들이 돌아가고있는지 확인해주고 이 상황의 스냅샷을 생성할겁니다 $ kubectl get all NAME READY STATUS RESTARTS AGE pod/myapp-deployment-7f6679cc7d-5qwxx 1/1 Running 0 32s pod/myapp-deployment-7f6679cc7d-855lp 1/1 Running 0 32s pod/myapp-deployment-7f6679cc7d-bxxjx 1/1 Running 0 32s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/kubernetes ClusterIP 10.96.0.1 &amp;lt;none&amp;gt; 443/TCP 8d NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/myapp-deployment 3/3 3 3 32s NAME DESIRED CURRENT READY AGE replicaset.apps/myapp-deployment-7f6679cc7d 3 3 3 32s shjeong920522@master:~/Pod$ 스냅샷 생성하기 etcdctl의 스냅샷을 생성하기위해선 아래와같은 옵션이 필요합니다. etcdctl --cacert=옵션값 \ --cert=옵션값 \ --key=옵션값 \ snapshot save 백업경로 및 파일이름 그렇다면 이 옵션값은 어디서 확인가능할까요? ps명령어 와 grep을 를 활용하면 된답니다 아래 명령어를 사용하여 다 찾아서 값을 가져와도되지만 $ ps -ef | grep etcd root 2863 2764 1 05:36 ? 00:00:23 etcd --advertise-client-urls=https://10.178.0.2:2379 --cert-file=/etc/kubernetes/pki/etcd/server.crt --client-cert-auth=true --data-dir=/var/lib/etcd --initial-advertise-peer-urls=https://10.178.0.2:2380 --initial-cluster=master=https://10.178.0.2:2380 --key-file=/etc/kubernetes/pki/etcd/server.key --listen-client-urls=https://127.0.0.1:2379,https://10.178.0.2:2379 --listen-metrics-urls=http://127.0.0.1:2381 --listen-peer-urls=https://10.178.0.2:2380 --name=master --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt --peer-client-cert-auth=true --peer-key-file=/etc/kubernetes/pki/etcd/peer.key --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt --snapshot-count=10000 --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt 표에 들어간 커맨드로 원하는 부분을 강조시켜 찾는방법을 추천드립니다. 눈알굴려서 찾는것보다 훨씬 빠르더라구요 etcdctl 명령 옵션 etcd 프로세스 실행옵션 값 커맨드로 빨리찾기 --cacert --trusted-ca-file /etc/kubernetes/pki/etcd/ca.crt ps -ef | grep etcd | grep trusted --cert --cert-file /etc/kubernetes/pki/etcd/server.crt ps -ef | grep etcd | grep &quot;\--cert&quot; --key --key-file /etc/kubernetes/pki/etcd/server.key ps -ef | grep etcd | grep &quot;\--key&quot; 그리고 값 부분은 항상 같은것이 아닐 수도 있기에 커맨드로 직접 확인하셔야 합니다. 자 이제 스냅샷을 생성하기위하여 우선 루트계정으로 전환해줍니다 $ sudo -i 아래와 같이 환경변수를 등록해줍니다 ETCDCTL_API 3버전을 사용하기 위함입니다. root# export ETCDCTL_API=3 root# etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \ &amp;gt; --cert=/etc/kubernetes/pki/etcd/server.crt \ &amp;gt; --key=/etc/kubernetes/pki/etcd/server.key \ &amp;gt; snapshot save /opt/backup Snapshot saved at /opt/backup 스냅샷을 생성하였으니 아까 배포하였던 deployment 를 delete하고 etcdctl 복구를하여 정말 동작하던 deployment를 다시 배포해주는지 확인해봅시다 우선 루트계정에서 로그아웃 해주시구요 root# exit logout deployment를 삭제시켜줍니다. $ kubectl delete -f depl.yml deployment.apps &quot;myapp-deployment&quot; deleted 복구하기로 넘어갑니다. 스냅샷으로 복구하기 복구할때는 스냅샷을 만들때 넣었던 옵션에서 네가지의 옵션이 더 추가됩니다. etcdctl 명령 옵션 etcd 프로세스 실행옵션 값 커맨드로 빨리찾기 --cacert --trusted-ca-file /etc/kubernetes/pki/etcd/ca.crt ps -ef | grep etcd | grep trusted --cert --cert-file /etc/kubernetes/pki/etcd/server.crt ps -ef | grep etcd | grep &quot;\--cert&quot; --key --key-file /etc/kubernetes/pki/etcd/server.key ps -ef | grep etcd | grep &quot;\--key&quot; --initial-advertise-peer-urls --initial-advertise-peer-urls https://10.178.0.2:2380 ps -ef | grep etcd | grep initial --initial-cluster=master --initial-cluster=master https://10.178.0.2:2380 ps -ef | grep etcd | grep initial --data-dir --data-dir /var/lib/etcd_backup ps -ef | grep etcd | grep &quot;\--data-dir&quot; --name --name master(마스터노드이름) ps -ef | grep etcd | grep &quot;\--name&quot; 자 여기까지가 restore 할때 필요한 모든 옵션입니다. 이제 아까 찍어놨던 스냅샷으로 복구되는지 확인해봅시다. 우선 루트 계정으로 전환하구요 $ sudo -i restore 명령어를 입력해주고 로그아웃해줍니다 root# etcdctl --cacert=/etc/kubernetes/pki/etcd/ca.crt \ &amp;gt; --cert=/etc/kubernetes/pki/etcd/server.crt \ &amp;gt; --key=/etc/kubernetes/pki/etcd/server.key \ &amp;gt; --initial-advertise-peer-urls=https://10.178.0.2:2380 \ &amp;gt; --initial-cluster=master=https://10.178.0.2:2380 \ &amp;gt; --data-dir=/var/lib/etcd_backup \ &amp;gt; --name=master \ &amp;gt; snapshot restore /opt/backup root# exit logout /opt/backup 에 생성해뒀던 스냅샷을이용해서 /var/lib 위치에 etcd_backup 파일을 생성합니다 staticpod에서 실행되는 etcd가 이를 바라보도록 해줘야하겠지요 staticpod의 위치인 /etc/kubernetes/manifest로 이동후 etcd.yaml을 수정해야합니다 $ cd /etc/kubernetes/manifest $ sudo vim etcd.yaml ~~~yaml #etcd.yaml ...중략 volumes: - hostPath: path: /etc/kubernetes/pki/etcd type: DirectoryOrCreate name: etcd-certs - hostPath: path: /var/lib/etcd_backup &amp;lt;----------- backup한 스냅샷을 바라보게 수정해줍니다 type: DirectoryOrCreate name: etcd-data ... 변경사항을 저장해주면 새로 로드될때까지 시간이 조금걸립니다 잠시후 정말 실행 중이던 deployment가 실행중인지 확인해봅시다 $ kubectl get deploy NAME READY UP-TO-DATE AVAILABLE AGE myapp-deployment 3/3 3 3 20s 짜잔~ 잘 복구된것을 확인할 수 있었습니다</summary></entry><entry><title type="html">[ #8 ] 클러스터 유지보수</title><link href="https://shjeong92.github.io/2021/06/03/Learning-Kubernetes-08.html" rel="alternate" type="text/html" title="[ #8 ] 클러스터 유지보수" /><published>2021-06-03T00:00:00+09:00</published><updated>2021-06-03T00:00:00+09:00</updated><id>https://shjeong92.github.io/2021/06/03/Learning-Kubernetes-08</id><content type="html" xml:base="https://shjeong92.github.io/2021/06/03/Learning-Kubernetes-08.html">&lt;p&gt;오늘은 클러스터의 유지보수에 관련한 포스트를 써볼까 합니다.&lt;/p&gt;

&lt;p&gt;쿠버네티스를 이용하여 서비스를 구축하고나서 언젠가는 시스템을 업데이트 시켜야할 일이 생길 것이며, 오류로 인하여 노드가 먹통이 되는일도 생길 것입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 노드의 작동을 중지시키면, 또는 오류로 중지된다면 어떻게 될까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;master node의 kube-contoller-manager에는 pod-eviction-timeout이 존재합니다&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;컨디션&quot;&gt;컨디션&lt;/h2&gt;

&lt;p&gt;각 노드에는 아래와 같이 여러가지 condition이 존재합니다&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;노드 컨디션&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;**Ready**&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;노드가 상태 양호하며 파드를 수용할 준비가 되어 있는 경우 True, 노드의 상태가 불량하여 파드를 수용하지 못할 경우 False, 그리고 노드 컨트롤러가 마지막 node-monitor-grace-period (기본값 40 기간 동안 노드로부터 응답을 받지 못한 경우) Unknown&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;**DiskPressure**&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;디스크 사이즈 상에 압박이 있는 경우, 즉 디스크 용량이 넉넉치 않은 경우 True, 반대의 경우 False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;**MemoryPressure**&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;노드 메모리 상에 압박이 있는 경우, 즉 노드 메모리가 넉넉치 않은 경우 True, 반대의 경우 False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;**PIDPressure**&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프로세스 상에 압박이 있는 경우, 즉 노드 상에 많은 프로세스들이 존재하는 경우 True, 반대의 경우 False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;**NetworkUnavailable**&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;노드에 대해 네트워크가 올바르게 구성되지 않은 경우 True, 반대의 경우 False&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;또한 노드 lifecycle controller는 컨디션을 아래와 같은 &lt;strong&gt;&lt;em&gt;built-in taint&lt;/em&gt;&lt;/strong&gt;를 자동으로 생성합니다.&lt;/p&gt;

&lt;h3 id=&quot;built-in-taints&quot;&gt;built-in taints&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;node.kubernetes.io/not-ready: 노드가 준비되지 않음. 이는 NodeCondition Ready 가 “False”로 됨에 해당.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/unreachable: 노드가 노드 컨트롤러에서 도달할 수 없음. 이는  NodeCondition Ready 가 “Unknown”로 됨에 해당.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/memory-pressure: 노드에 메모리 할당 압박이 있음.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/disk-pressure: 노드에 디스크 할당 압박이 있음.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/pid-pressure: 노드에 PID 할당 압박이 있음.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/network-unavailable: 노드의 네트워크를 사용할 수 없음.&lt;/li&gt;
  &lt;li&gt;node.kubernetes.io/unschedulable: 노드를 스케줄할 수 없음.&lt;/li&gt;
  &lt;li&gt;node.cloudprovider.kubernetes.io/uninitialized: “외부” 클라우드 공급자로 kubelet을 시작하면, 이 테인트가 노드에서 사용 불가능으로 표시되도록 설정됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 중에서도 &lt;code&gt;ready&lt;/code&gt; 컨디션은 좀 특별한데요. 
ready 컨디션의 상태가 pod-eviction-timeout (kube-controller-manager에 전달된 인수) 보다 더 길게 Unknown 또는 False로 유지되는 경우, 노드 상에 모든 파드는 노드 컨트롤러에 의해 삭제되도록 스케줄 됩니다.&lt;/p&gt;

&lt;p&gt;클라우드-컨트롤러-관리자의 컨트롤러가 이 노드를 초기화하면, kubelet이 이 테인트를 제거합니다 즉 다시 pod가 배정될 수 있는 상태가 되는것이죠. 기본 축출 타임아웃 기간은 기본 5분으로 설정되어 있습니다. 만약 노드가 다운되었다가 5분안에 복구가 되었다면 노드 내의 pod들은 그대로 존재하지만, 설정된 타임아웃 시간을 초과한다면 그안의 파드들은 모두 중단 되는것입니다.&lt;/p&gt;

&lt;p&gt;만약 수정하고 싶다면 마스터 노드의 kube-system 네임스페이스에 있는 kube-controller-manager-master을 edit해주면됩니다.&lt;/p&gt;

&lt;p&gt;그런데 말이죠 이 pod는 static pod입니다. 
&lt;a href=&quot;https://shjeong92.github.io/2021/05/31/Learning-Kubernetes-06.html&quot;&gt;6번째 포스트&lt;/a&gt;에서 설명 했었는데 static pod 를 수정하려면 
static pod을 생성한 yaml파일 자체를 수정한다고 했었죠?&lt;/p&gt;

&lt;p&gt;static pod의 위치를 찾는것 부터 복습해봅시다&lt;/p&gt;

&lt;p&gt;우선 config.yaml파일의 위치를 찾아줍니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;se&quot;&gt;\$&lt;/span&gt; ps &lt;span class=&quot;nt&quot;&gt;-ef&lt;/span&gt; | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;kubelet | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&quot;\-&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-config&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&quot;&lt;/span&gt;

root     10476     1  3 May28 ?        05:09:26 /usr/bin/kubelet &lt;span class=&quot;nt&quot;&gt;--bootstrap-kubeconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/bootstrap-kubelet.conf &lt;span class=&quot;nt&quot;&gt;--kubeconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/etc/kubernetes/kubelet.conf &lt;span class=&quot;nt&quot;&gt;--config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/var/lib/kubelet/config.yaml &lt;span class=&quot;nt&quot;&gt;--network-plugin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;cni &lt;span class=&quot;nt&quot;&gt;--pod-infra-container-image&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;k8s.gcr.io/pause:3.4.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;config.yaml파일 내에서 staticpath를 찾아냅시다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo grep&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; static /var/lib/kubelet/config.yaml
staticPodPath: /etc/kubernetes/manifests
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;staticPodPath로 이동후 뭐가있나 확인해봅니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /etc/kubernetes/manifests

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls
&lt;/span&gt;etcd.yaml  kube-apiserver.yaml  kube-controller-manager.yaml  kube-scheduler.yaml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자 이제 이 yaml파일을 수정하면 됩니다.
저는 이 기본 5분인 eviction-timeout을 60초로 바꾸어 보겠습니다.&lt;/p&gt;

&lt;p&gt;command에 &lt;code&gt;--pod-eviction-timeout=60s&lt;/code&gt; 옵션을 추가해 줌으로써 말이죠.&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Pod&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;metadata&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;annotations&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/config.hash&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;47cace34a635d6f3e305eee20e0e7b30&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/config.mirror&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;47cace34a635d6f3e305eee20e0e7b30&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/config.seen&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2021-05-28T03:40:42.961803243Z&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;kubernetes.io/config.source&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;file&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;creationTimestamp&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;2021-05-28T03:40:55Z&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;labels&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-controller-manager&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tier&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;control-plane&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-controller-manager-master&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;namespace&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-system&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;ownerReferences&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;apiVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;v1&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;controller&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;kind&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Node&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;master&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;69f4d243-9420-45a9-928e-672a1d3b977a&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;resourceVersion&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;478&quot;&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;uid&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;4cfad35d-8664-42cf-9ed9-5fd5b4d771a4&lt;/span&gt;
&lt;span class=&quot;na&quot;&gt;spec&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;containers&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;kube-controller-manager&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--allocate-node-cidrs=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--pod-eviction-timeout=60s&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;#&amp;lt;----------- 해당라인을 추가하면 이제 5분이아닌 60초로 변경됩니다.&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--authentication-kubeconfig=/etc/kubernetes/controller-manager.conf&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--authorization-kubeconfig=/etc/kubernetes/controller-manager.conf&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--bind-address=127.0.0.1&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--client-ca-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--cluster-cidr=10.244.0.0/16&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--cluster-name=kubernetes&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--cluster-signing-key-file=/etc/kubernetes/pki/ca.key&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--controllers=*,bootstrapsigner,tokencleaner&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--kubeconfig=/etc/kubernetes/controller-manager.conf&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--leader-elect=true&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--port=0&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--root-ca-file=/etc/kubernetes/pki/ca.crt&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--service-account-private-key-file=/etc/kubernetes/pki/sa.key&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--service-cluster-ip-range=10.96.0.0/12&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;--use-service-account-credentials=true&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;k8s.gcr.io/kube-controller-manager:v1.21.1&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;...중략&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;저장해주면 멈췄다가&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kube-controller-manager-master    0/1     Running   0          3s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;옵션을 적용시켜 pod시 재시동됩니다~&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kube-controller-manager-master    1/1     Running   0          3s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;eviction-timeout의-존재이유&quot;&gt;eviction timeout의 존재이유?&lt;/h2&gt;
&lt;p&gt;위에서 eviction timeout의 값을 바꾸는 실습을 해보았는데요 이 timeout은 무엇과 연관이 있는지 두가지 케이스를 통해서 알아보겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;case1: node가 먹통이 되었다가 설정해놓은 eviction-timeout보다 짦은시간안에 복구된경우&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;노드내에 있던 pod들이 kubectl에 의해 다시 해당노드에서 재시작됩니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;case2: node가 먹통이 된후 eviction-timeout을 초과한경우&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 노드에있는 pod들을 모두 축출한 후에 노드가 재시동됩니다.&lt;/li&gt;
      &lt;li&gt;해당 노드에있던 pod이 replicaset을 통해 생성되었다면 다시 다른노드에 잘 생성이 되겠지만, 일반 pod이라면 다시 살아나지 못할겁니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;노드관련-명령어&quot;&gt;노드관련 명령어&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code&gt; kubectl drain node &lt;/code&gt;
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl drain node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;해당 노드에있는 pod들을 종료시키고, 다른노드에 재시작시킵니다 (graceful node shutdown) 또한 해당 노드를 unschedulable하게 만든다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;kubernetes의 버전 또는 리눅스 커널등의 업그레이드할 때 사용할 수 있겠습니다(kubeadm, kubelet, kubectl, …)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt; kubectl cordon node &lt;/code&gt;
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl cordon node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 노드를 unschedulable하게 만듭니다&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;실행 중인 Pod를 축출하지는 않습니다&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt; kubectl uncordon node &lt;/code&gt;
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl uncordon node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;ul&gt;
      &lt;li&gt;해당 노드를 schedulable하게 만든다&lt;/li&gt;
      &lt;li&gt;업그레이드를 마친 노드를 스케쥴러블하게 만듭니다 (taint를 제거)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;drain명령에 의해서 집나간 pod들이 다시 집을 찾아오진 않습니다.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;쿠버네티스-버전-및-버전차이-지원&quot;&gt;쿠버네티스 버전 및 버전차이 지원&lt;/h2&gt;

&lt;h3 id=&quot;버전&quot;&gt;버전&lt;/h3&gt;
&lt;p&gt;쿠버네티스 버전은 x.y.z로 표현되는데, 여기서 x는 메이저 버전, y는 마이너 버전, z는 시맨틱 버전 용어에 따른 패치 버전입니다.
kubernetes에는 여러가지 컴포넌트가 있습니다.
각각의 버전은 전부 동일해야할까요? 아닙니다.&lt;/p&gt;

&lt;p&gt;kube-apiserver의 버전이 주축이되고, 나머지 컴포넌트는 각각 다르게 한 두단계 버전이 낮거나 같아도 상관이 없습니다. 특별하게 &lt;strong&gt;kubectl&lt;/strong&gt;의 경우는 kube-apiserver의 버전보다 한단계 높은경우도 지원이 됩니다.&lt;/p&gt;

&lt;p&gt;더 자세한 내용은 &lt;a href=&quot;https://kubernetes.io/ko/docs/setup/release/version-skew-policy/&quot;&gt;공식문서&lt;/a&gt;에서 확인가능 합니다&lt;/p&gt;

&lt;h2 id=&quot;클러스터-업그레이드&quot;&gt;클러스터 업그레이드&lt;/h2&gt;

&lt;p&gt;kubernets는 latest버전부터 두단계 낮은버전까지 서비스를 지원하는데요, 만약에 현재 1.19버전을 사용하고 있는데 1.22버전이 출시 된다면 업그레이드를 해야겠죠.&lt;/p&gt;

&lt;p&gt;그렇다면 1.19버전에서 한번에 1.22번으로 업그레이드 시키면될까요? 추천되는 방법에 의하면
한단계 한단계씩 차례차례로 업그레이드 해야된다고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;업그레이드-방법&quot;&gt;업그레이드 방법&lt;/h3&gt;

&lt;p&gt;쿠버네티스 환경을 어떻게 구성하였는가에 따라 업그레이드 방법이 다양합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;구글의 GKE, AWS의 EKS등의 kubernete를 지원하는 cloud의 경우&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;간단한 클릭 몇번으로 업그레이드 가능&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The hard way로 설치한경우&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한땀한땀 설치한 것처럼 업그레이드 또한 한땀한땀 해야합니다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;저는 &lt;strong&gt;kubeadm&lt;/strong&gt;을 이용하여 kubernetes환경을 구축하였고, &lt;strong&gt;kubeadm&lt;/strong&gt;을 통한 업그레이드 방법에 대해 자세히 설명해 보겠습니다.&lt;/p&gt;

&lt;p&gt;저의 쿠버네티스 환경은 한개의 master노드, 3개의 worker노드로 구성되어있습니다. 1.20버전을 이용하고 있는데 1.21버전으로 업그레이드 해보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;step1---마스터-노드에-kubeadm-업그레이드-시키기&quot;&gt;STEP1 - 마스터 노드에 kubeadm 업그레이드 시키기.&lt;/h3&gt;

&lt;p&gt;마스터 노드에 접속합니다&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh gcloud
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ssh config&lt;/strong&gt;에 설정을 해놨기에 이렇게 간단하게 접속가능합니다. &lt;strong&gt;ssh config 설정방법&lt;/strong&gt;이 궁금하시면 &lt;a href=&quot;https://shjeong92.github.io/2021/06/01/Handling-ssh-config.html&quot;&gt;여기&lt;/a&gt;로 이동하세요.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그리고  kubernetes환경을 구축할때 hold시켜놨었던 kubeadm을 unhold시켜주고, apt-get 색인 업데이트후, kubeadm을 업데이트 한다음 다시 kubeadm을 hold시켜 줄겁니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 1.21.x-00에서 x를 최신 패치 버전으로 바꿉니다&lt;/span&gt;
apt-mark unhold kubeadm &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;kubeadm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.x-00 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
apt-mark hold kubeadm

&lt;span class=&quot;c&quot;&gt;#버전 확인해주기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm version
kubeadm version: &amp;amp;version.Info&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;Major:&lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;, Minor:&lt;span class=&quot;s2&quot;&gt;&quot;21&quot;&lt;/span&gt;, GitVersion:&lt;span class=&quot;s2&quot;&gt;&quot;v1.21.1&quot;&lt;/span&gt;, GitCommit:&lt;span class=&quot;s2&quot;&gt;&quot;5e58841cce77d4bc13713ad2b91fa0d961e69192&quot;&lt;/span&gt;, GitTreeState:&lt;span class=&quot;s2&quot;&gt;&quot;clean&quot;&lt;/span&gt;, BuildDate:&lt;span class=&quot;s2&quot;&gt;&quot;2021-05-12T14:17:27Z&quot;&lt;/span&gt;, GoVersion:&lt;span class=&quot;s2&quot;&gt;&quot;go1.16.4&quot;&lt;/span&gt;, Compiler:&lt;span class=&quot;s2&quot;&gt;&quot;gc&quot;&lt;/span&gt;, Platform:&lt;span class=&quot;s2&quot;&gt;&quot;linux/amd64&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;apt-mark unhold&lt;/strong&gt;와 &lt;strong&gt;apt-mark hold&lt;/strong&gt; 해주는 이유는 kubeadm을 업그레이드하면 설치시 kubelet과 같은 다른 구성 요소가 기본적으로 최신 버전 으로 자동으로 업그레이드되기 때문입니다. (kubernetes는 여러버전을 한꺼번에 업그레이드 권장하지 않기때문입니다!) 이를 해결하기 위해 보류를 사용하여 패키지를 보류 된 것으로 표시하여 패키지가 자동으로 설치, 업그레이드 또는 제거되지 않도록합니다.&lt;/p&gt;

&lt;h3 id=&quot;step2---업그레이드-정보-확인하기&quot;&gt;STEP2 - 업그레이드 정보 확인하기&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade plan

...

COMPONENT            CURRENT AVAILABLE

API Server           v1.20.0 v1.21.1

Controller Manager   v1.20.0 v1.21.1

Scheduler            v1.20.0 v1.21.1

Kube Proxy           v1.20.0 v1.21.1

...

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step3---업그레이드-적용시키기&quot;&gt;STEP3 - 업그레이드 적용시키기&lt;/h3&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade plan apply v1.21.1
&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;조금 오래걸릴 수도 있습니다&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

아래와같이뜨면 성공
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;upgrade/successful] SUCCESS! Your cluster was upgraded to &lt;span class=&quot;s2&quot;&gt;&quot;v1.21.1&quot;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; Enjoy!

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;you haven&lt;span class=&quot;s1&quot;&gt;&apos;t already done so.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step4---node-drain후-kubelet-kubectl-업데이트후-재시작하기&quot;&gt;STEP4 - node drain후 kubelet, kubectl 업데이트후 재시작하기&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#노드 드레인하기(모든 pod 종료후 다른노드에 새로 실행하기 및 해당노드 unschedulable하게 만듬)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl drain &amp;lt;node-to-drain&amp;gt; &lt;span class=&quot;nt&quot;&gt;--ignore-daemonsets&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark unhold kubelet kubectl &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;kubelet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.1-00 &lt;span class=&quot;nv&quot;&gt;kubectl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.1-00 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark hold kubelet kubectl

&lt;span class=&quot;c&quot;&gt;#설정 수정사항 재로딩&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl daemon-reload
&lt;span class=&quot;c&quot;&gt;#kubelet 재시작&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl restart kubelet

&lt;span class=&quot;c&quot;&gt;#업데이트가 끝났으므로 다시 schedulable하게 만들어주기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl uncordon &amp;lt;node-to-uncordon&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기까지가 마스터노드의 업그레이드 방법이었습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;h1 id=&quot;rocket-여기서부터는-워커노드들을-업그레이드-합니다&quot;&gt;:rocket: 여기서부터는 워커노드들을 업그레이드 합니다.&lt;/h1&gt;

&lt;h3 id=&quot;step5---워커-노드에-kubeadm-설치하기&quot;&gt;STEP5 - 워커 노드에 kubeadm 설치하기&lt;/h3&gt;

&lt;p&gt;우선 3개의 워커노드중 하나인 worker-1에 접속합니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssh worker-1 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그 다음, 마스터노드에 설치했던과 같은방법으로 kubeadm를 설치합니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark unhold kubeadm &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;kubeadm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.x-00 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark hold kubeadm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아까 마스터노드에서 아래의 커맨드를 이용해 upgrade가능 버전을 확인하고 v1.21.1로 apply했었습니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade plan
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade apply v1.21.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;하지만 워커노드에서는 아래의 커맨드를 이용하여 클러스터에서 kubeadm ClusterConfiguration 을 가져오며,
이 노드의 kubelet 구성을 업그레이드 합니다.&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubeadm upgrade node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 마스터 노드로 이동하여 업그레이드 할 워커노드를 드레인 해줍니다. (마스터 노드에서 워커노드로 접속했었기에 접속 종료하면 마스터노드로 이동합니다.)&lt;/p&gt;
&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit
logout
&lt;/span&gt;Connection to 10.128.0.5 closed.

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl drain worker-1 &lt;span class=&quot;nt&quot;&gt;--ignore-daemonsets&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step6---워커노드의-kubelet-및-kubectl-업그레이드&quot;&gt;STEP6 - 워커노드의 kubelet 및 kubectl 업그레이드&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 다시 워커노드로 접속하기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh worker-1
 

&lt;span class=&quot;c&quot;&gt;# kubectl 과 kubelet 업데이트하기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark unhold kubectl kubelet &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-get update &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; apt-get &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-y&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;kubectl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.1-00 &lt;span class=&quot;nv&quot;&gt;kubelet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1.21.1-00 &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;apt-mark hold kubectl kubelet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step7---kubelet-다시-시작하기&quot;&gt;STEP7 - kubelet 다시 시작하기&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl daemon-reload
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl restart kubelet
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step8---cordon-해재하기&quot;&gt;STEP8 - cordon 해재하기&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#마스터노드로 이동하기&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl uncordon worker-1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;step9---반복하기&quot;&gt;STEP9 - 반복하기&lt;/h3&gt;

&lt;p&gt;업그레이드 할 워커노드에
STEP5 ~ STEP8을 똑같이 진행해줍니다&lt;/p&gt;

&lt;p&gt;마지막으로 업데이트가 잘 되었는지 확인해줍니다&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;kubectl get nodes
NAME         STATUS   ROLES                  AGE    VERSION
master       Ready    control-plane,master   6d8h   v1.21.1
worker-1     Ready    &amp;lt;none&amp;gt;                 6d8h   v1.21.1
worker-2     Ready    &amp;lt;none&amp;gt;                 6d8h   v1.21.1
worker-3     Ready    &amp;lt;none&amp;gt;                 6d8h   v1.21.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;버전이 v1.21.1로 잘 업그레이드 된것을 확인할 수 있습니다.&lt;/p&gt;</content><author><name>Sanghyuk Jeong</name><email>shjeong920522@gmail.com</email></author><category term="Kubernetes" /><category term="maintenance" /><category term="static" /><category term="pod" /><category term="strategy" /><category term="쿠버네티스" /><category term="update" /><summary type="html">오늘은 클러스터의 유지보수에 관련한 포스트를 써볼까 합니다. 쿠버네티스를 이용하여 서비스를 구축하고나서 언젠가는 시스템을 업데이트 시켜야할 일이 생길 것이며, 오류로 인하여 노드가 먹통이 되는일도 생길 것입니다. 그렇다면 노드의 작동을 중지시키면, 또는 오류로 중지된다면 어떻게 될까요? master node의 kube-contoller-manager에는 pod-eviction-timeout이 존재합니다 컨디션 각 노드에는 아래와 같이 여러가지 condition이 존재합니다 노드 컨디션 설명 Ready 노드가 상태 양호하며 파드를 수용할 준비가 되어 있는 경우 True, 노드의 상태가 불량하여 파드를 수용하지 못할 경우 False, 그리고 노드 컨트롤러가 마지막 node-monitor-grace-period (기본값 40 기간 동안 노드로부터 응답을 받지 못한 경우) Unknown DiskPressure 디스크 사이즈 상에 압박이 있는 경우, 즉 디스크 용량이 넉넉치 않은 경우 True, 반대의 경우 False MemoryPressure 노드 메모리 상에 압박이 있는 경우, 즉 노드 메모리가 넉넉치 않은 경우 True, 반대의 경우 False PIDPressure 프로세스 상에 압박이 있는 경우, 즉 노드 상에 많은 프로세스들이 존재하는 경우 True, 반대의 경우 False NetworkUnavailable 노드에 대해 네트워크가 올바르게 구성되지 않은 경우 True, 반대의 경우 False 또한 노드 lifecycle controller는 컨디션을 아래와 같은 built-in taint를 자동으로 생성합니다. built-in taints node.kubernetes.io/not-ready: 노드가 준비되지 않음. 이는 NodeCondition Ready 가 “False”로 됨에 해당. node.kubernetes.io/unreachable: 노드가 노드 컨트롤러에서 도달할 수 없음. 이는 NodeCondition Ready 가 “Unknown”로 됨에 해당. node.kubernetes.io/memory-pressure: 노드에 메모리 할당 압박이 있음. node.kubernetes.io/disk-pressure: 노드에 디스크 할당 압박이 있음. node.kubernetes.io/pid-pressure: 노드에 PID 할당 압박이 있음. node.kubernetes.io/network-unavailable: 노드의 네트워크를 사용할 수 없음. node.kubernetes.io/unschedulable: 노드를 스케줄할 수 없음. node.cloudprovider.kubernetes.io/uninitialized: “외부” 클라우드 공급자로 kubelet을 시작하면, 이 테인트가 노드에서 사용 불가능으로 표시되도록 설정됨. 그 중에서도 ready 컨디션은 좀 특별한데요. ready 컨디션의 상태가 pod-eviction-timeout (kube-controller-manager에 전달된 인수) 보다 더 길게 Unknown 또는 False로 유지되는 경우, 노드 상에 모든 파드는 노드 컨트롤러에 의해 삭제되도록 스케줄 됩니다. 클라우드-컨트롤러-관리자의 컨트롤러가 이 노드를 초기화하면, kubelet이 이 테인트를 제거합니다 즉 다시 pod가 배정될 수 있는 상태가 되는것이죠. 기본 축출 타임아웃 기간은 기본 5분으로 설정되어 있습니다. 만약 노드가 다운되었다가 5분안에 복구가 되었다면 노드 내의 pod들은 그대로 존재하지만, 설정된 타임아웃 시간을 초과한다면 그안의 파드들은 모두 중단 되는것입니다. 만약 수정하고 싶다면 마스터 노드의 kube-system 네임스페이스에 있는 kube-controller-manager-master을 edit해주면됩니다. 그런데 말이죠 이 pod는 static pod입니다. 6번째 포스트에서 설명 했었는데 static pod 를 수정하려면 static pod을 생성한 yaml파일 자체를 수정한다고 했었죠? static pod의 위치를 찾는것 부터 복습해봅시다 우선 config.yaml파일의 위치를 찾아줍니다. $ ps -ef | grep kubelet | grep &quot;\--config&quot; root 10476 1 3 May28 ? 05:09:26 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kubernetes/kubelet.conf --config=/var/lib/kubelet/config.yaml --network-plugin=cni --pod-infra-container-image=k8s.gcr.io/pause:3.4.1 config.yaml파일 내에서 staticpath를 찾아냅시다 $ sudo grep -i static /var/lib/kubelet/config.yaml staticPodPath: /etc/kubernetes/manifests staticPodPath로 이동후 뭐가있나 확인해봅니다. $ cd /etc/kubernetes/manifests $ ls etcd.yaml kube-apiserver.yaml kube-controller-manager.yaml kube-scheduler.yaml 자 이제 이 yaml파일을 수정하면 됩니다. 저는 이 기본 5분인 eviction-timeout을 60초로 바꾸어 보겠습니다. command에 --pod-eviction-timeout=60s 옵션을 추가해 줌으로써 말이죠. apiVersion: v1 kind: Pod metadata: annotations: kubernetes.io/config.hash: 47cace34a635d6f3e305eee20e0e7b30 kubernetes.io/config.mirror: 47cace34a635d6f3e305eee20e0e7b30 kubernetes.io/config.seen: &quot;2021-05-28T03:40:42.961803243Z&quot; kubernetes.io/config.source: file creationTimestamp: &quot;2021-05-28T03:40:55Z&quot; labels: component: kube-controller-manager tier: control-plane name: kube-controller-manager-master namespace: kube-system ownerReferences: - apiVersion: v1 controller: true kind: Node name: master uid: 69f4d243-9420-45a9-928e-672a1d3b977a resourceVersion: &quot;478&quot; uid: 4cfad35d-8664-42cf-9ed9-5fd5b4d771a4 spec: containers: - command: - kube-controller-manager - --allocate-node-cidrs=true - --pod-eviction-timeout=60s #&amp;lt;----------- 해당라인을 추가하면 이제 5분이아닌 60초로 변경됩니다. - --authentication-kubeconfig=/etc/kubernetes/controller-manager.conf - --authorization-kubeconfig=/etc/kubernetes/controller-manager.conf - --bind-address=127.0.0.1 - --client-ca-file=/etc/kubernetes/pki/ca.crt - --cluster-cidr=10.244.0.0/16 - --cluster-name=kubernetes - --cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt - --cluster-signing-key-file=/etc/kubernetes/pki/ca.key - --controllers=*,bootstrapsigner,tokencleaner - --kubeconfig=/etc/kubernetes/controller-manager.conf - --leader-elect=true - --port=0 - --requestheader-client-ca-file=/etc/kubernetes/pki/front-proxy-ca.crt - --root-ca-file=/etc/kubernetes/pki/ca.crt - --service-account-private-key-file=/etc/kubernetes/pki/sa.key - --service-cluster-ip-range=10.96.0.0/12 - --use-service-account-credentials=true image: k8s.gcr.io/kube-controller-manager:v1.21.1 ...중략 저장해주면 멈췄다가 kube-controller-manager-master 0/1 Running 0 3s 옵션을 적용시켜 pod시 재시동됩니다~ kube-controller-manager-master 1/1 Running 0 3s eviction timeout의 존재이유? 위에서 eviction timeout의 값을 바꾸는 실습을 해보았는데요 이 timeout은 무엇과 연관이 있는지 두가지 케이스를 통해서 알아보겠습니다. case1: node가 먹통이 되었다가 설정해놓은 eviction-timeout보다 짦은시간안에 복구된경우 노드내에 있던 pod들이 kubectl에 의해 다시 해당노드에서 재시작됩니다. case2: node가 먹통이 된후 eviction-timeout을 초과한경우 해당 노드에있는 pod들을 모두 축출한 후에 노드가 재시동됩니다. 해당 노드에있던 pod이 replicaset을 통해 생성되었다면 다시 다른노드에 잘 생성이 되겠지만, 일반 pod이라면 다시 살아나지 못할겁니다. 노드관련 명령어 kubectl drain node $ kubectl drain node 해당 노드에있는 pod들을 종료시키고, 다른노드에 재시작시킵니다 (graceful node shutdown) 또한 해당 노드를 unschedulable하게 만든다. kubernetes의 버전 또는 리눅스 커널등의 업그레이드할 때 사용할 수 있겠습니다(kubeadm, kubelet, kubectl, …) kubectl cordon node $ kubectl cordon node 해당 노드를 unschedulable하게 만듭니다 실행 중인 Pod를 축출하지는 않습니다 kubectl uncordon node $ kubectl uncordon node 해당 노드를 schedulable하게 만든다 업그레이드를 마친 노드를 스케쥴러블하게 만듭니다 (taint를 제거) drain명령에 의해서 집나간 pod들이 다시 집을 찾아오진 않습니다. 쿠버네티스 버전 및 버전차이 지원 버전 쿠버네티스 버전은 x.y.z로 표현되는데, 여기서 x는 메이저 버전, y는 마이너 버전, z는 시맨틱 버전 용어에 따른 패치 버전입니다. kubernetes에는 여러가지 컴포넌트가 있습니다. 각각의 버전은 전부 동일해야할까요? 아닙니다. kube-apiserver의 버전이 주축이되고, 나머지 컴포넌트는 각각 다르게 한 두단계 버전이 낮거나 같아도 상관이 없습니다. 특별하게 kubectl의 경우는 kube-apiserver의 버전보다 한단계 높은경우도 지원이 됩니다. 더 자세한 내용은 공식문서에서 확인가능 합니다 클러스터 업그레이드 kubernets는 latest버전부터 두단계 낮은버전까지 서비스를 지원하는데요, 만약에 현재 1.19버전을 사용하고 있는데 1.22버전이 출시 된다면 업그레이드를 해야겠죠. 그렇다면 1.19버전에서 한번에 1.22번으로 업그레이드 시키면될까요? 추천되는 방법에 의하면 한단계 한단계씩 차례차례로 업그레이드 해야된다고 합니다. 업그레이드 방법 쿠버네티스 환경을 어떻게 구성하였는가에 따라 업그레이드 방법이 다양합니다. 구글의 GKE, AWS의 EKS등의 kubernete를 지원하는 cloud의 경우 간단한 클릭 몇번으로 업그레이드 가능 The hard way로 설치한경우 한땀한땀 설치한 것처럼 업그레이드 또한 한땀한땀 해야합니다 저는 kubeadm을 이용하여 kubernetes환경을 구축하였고, kubeadm을 통한 업그레이드 방법에 대해 자세히 설명해 보겠습니다. 저의 쿠버네티스 환경은 한개의 master노드, 3개의 worker노드로 구성되어있습니다. 1.20버전을 이용하고 있는데 1.21버전으로 업그레이드 해보겠습니다. STEP1 - 마스터 노드에 kubeadm 업그레이드 시키기. 마스터 노드에 접속합니다 $ ssh gcloud ssh config에 설정을 해놨기에 이렇게 간단하게 접속가능합니다. ssh config 설정방법이 궁금하시면 여기로 이동하세요. 그리고 kubernetes환경을 구축할때 hold시켜놨었던 kubeadm을 unhold시켜주고, apt-get 색인 업데이트후, kubeadm을 업데이트 한다음 다시 kubeadm을 hold시켜 줄겁니다. # 1.21.x-00에서 x를 최신 패치 버전으로 바꿉니다 apt-mark unhold kubeadm &amp;amp;&amp;amp; \ apt-get update &amp;amp;&amp;amp; apt-get install -y kubeadm=1.21.x-00 &amp;amp;&amp;amp; \ apt-mark hold kubeadm #버전 확인해주기 $ kubeadm version kubeadm version: &amp;amp;version.Info{Major:&quot;1&quot;, Minor:&quot;21&quot;, GitVersion:&quot;v1.21.1&quot;, GitCommit:&quot;5e58841cce77d4bc13713ad2b91fa0d961e69192&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2021-05-12T14:17:27Z&quot;, GoVersion:&quot;go1.16.4&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;} apt-mark unhold와 apt-mark hold 해주는 이유는 kubeadm을 업그레이드하면 설치시 kubelet과 같은 다른 구성 요소가 기본적으로 최신 버전 으로 자동으로 업그레이드되기 때문입니다. (kubernetes는 여러버전을 한꺼번에 업그레이드 권장하지 않기때문입니다!) 이를 해결하기 위해 보류를 사용하여 패키지를 보류 된 것으로 표시하여 패키지가 자동으로 설치, 업그레이드 또는 제거되지 않도록합니다. STEP2 - 업그레이드 정보 확인하기 $ kubeadm upgrade plan ... COMPONENT CURRENT AVAILABLE API Server v1.20.0 v1.21.1 Controller Manager v1.20.0 v1.21.1 Scheduler v1.20.0 v1.21.1 Kube Proxy v1.20.0 v1.21.1 ... STEP3 - 업그레이드 적용시키기 $ kubeadm upgrade plan apply v1.21.1 (조금 오래걸릴 수도 있습니다) 아래와같이뜨면 성공 [upgrade/successful] SUCCESS! Your cluster was upgraded to &quot;v1.21.1&quot;. Enjoy! [upgrade/kubelet] Now that your control plane is upgraded, please proceed with upgrading your kubelets if you haven&apos;t already done so. STEP4 - node drain후 kubelet, kubectl 업데이트후 재시작하기 #노드 드레인하기(모든 pod 종료후 다른노드에 새로 실행하기 및 해당노드 unschedulable하게 만듬) $ kubectl drain &amp;lt;node-to-drain&amp;gt; --ignore-daemonsets $ apt-mark unhold kubelet kubectl &amp;amp;&amp;amp; \ $ apt-get update &amp;amp;&amp;amp; apt-get install -y kubelet=1.21.1-00 kubectl=1.21.1-00 &amp;amp;&amp;amp; \ $ apt-mark hold kubelet kubectl #설정 수정사항 재로딩 $ sudo systemctl daemon-reload #kubelet 재시작 $ sudo systemctl restart kubelet #업데이트가 끝났으므로 다시 schedulable하게 만들어주기 $ kubectl uncordon &amp;lt;node-to-uncordon&amp;gt; 여기까지가 마스터노드의 업그레이드 방법이었습니다. :rocket: 여기서부터는 워커노드들을 업그레이드 합니다. STEP5 - 워커 노드에 kubeadm 설치하기 우선 3개의 워커노드중 하나인 worker-1에 접속합니다. ssh worker-1 그 다음, 마스터노드에 설치했던과 같은방법으로 kubeadm를 설치합니다. $ apt-mark unhold kubeadm &amp;amp;&amp;amp; \ $ apt-get update &amp;amp;&amp;amp; apt-get install -y kubeadm=1.21.x-00 &amp;amp;&amp;amp; \ $ apt-mark hold kubeadm 아까 마스터노드에서 아래의 커맨드를 이용해 upgrade가능 버전을 확인하고 v1.21.1로 apply했었습니다. $ kubeadm upgrade plan $ kubeadm upgrade apply v1.21.1 하지만 워커노드에서는 아래의 커맨드를 이용하여 클러스터에서 kubeadm ClusterConfiguration 을 가져오며, 이 노드의 kubelet 구성을 업그레이드 합니다. $ kubeadm upgrade node 그리고 마스터 노드로 이동하여 업그레이드 할 워커노드를 드레인 해줍니다. (마스터 노드에서 워커노드로 접속했었기에 접속 종료하면 마스터노드로 이동합니다.) $ exit logout Connection to 10.128.0.5 closed. $ kubectl drain worker-1 --ignore-daemonsets STEP6 - 워커노드의 kubelet 및 kubectl 업그레이드 # 다시 워커노드로 접속하기 $ ssh worker-1 # kubectl 과 kubelet 업데이트하기 $ apt-mark unhold kubectl kubelet &amp;amp;&amp;amp; \ $ apt-get update &amp;amp;&amp;amp; apt-get install -y kubectl=1.21.1-00 kubelet=1.21.1-00 &amp;amp;&amp;amp; \ $ apt-mark hold kubectl kubelet STEP7 - kubelet 다시 시작하기 $ sudo systemctl daemon-reload $ sudo systemctl restart kubelet STEP8 - cordon 해재하기 #마스터노드로 이동하기 $ exit $ kubectl uncordon worker-1 STEP9 - 반복하기 업그레이드 할 워커노드에 STEP5 ~ STEP8을 똑같이 진행해줍니다 마지막으로 업데이트가 잘 되었는지 확인해줍니다 $ kubectl get nodes NAME STATUS ROLES AGE VERSION master Ready control-plane,master 6d8h v1.21.1 worker-1 Ready &amp;lt;none&amp;gt; 6d8h v1.21.1 worker-2 Ready &amp;lt;none&amp;gt; 6d8h v1.21.1 worker-3 Ready &amp;lt;none&amp;gt; 6d8h v1.21.1 버전이 v1.21.1로 잘 업그레이드 된것을 확인할 수 있습니다.</summary></entry></feed>